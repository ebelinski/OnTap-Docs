import Combine
import CoreData
import CoreFoundation
import CoreGraphics
import Darwin
import DeveloperToolsSupport
import Foundation
import SwiftUI
import UIKit
import UniformTypeIdentifiers
import os.log
import os
import os.signpost

/// An object that publishes its changes.
///
/// ### Understanding `ObservableObject`
///
/// The `ObservableObject` protocol definition is as follows:
/// ```
/// public protocol ObservableObject: AnyObject {
///     associatedtype ObjectWillChangePublisher: Publisher
///
///     var objectWillChange: ObjectWillChangePublisher { get }
/// }
/// ```
///
/// `ObservableObject` has one simple requirement - the `objectWillChange` publisher. The `objectWillChange` publisher is responsible for emitting just before the object changes.
///
/// This requirement is fundamental to how the SwiftUI runtime interacts with your object-based data models. It allows the runtime to react to changes in your data, and queue view updates for the UI's next render cycle.
///
/// ### Using `ObservableObject`
///
/// To conform to `ObservableObject`, simply add it to the class definition.
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var foo: Bool = false
/// }
/// ```
///
/// `ObservableObject` provides a default implementation for `objectWillChange` using `Combine/ObservableObjectPublisher`.
///
/// To trigger `objectWillChange` events when your data changes, annotate your properties with the `@Published` property wrapper. Adding `@Published` to a variable causes the object to emit an `objectWillChange` event any time that variable is modified.
///
/// Note: This only works if you are using the default `ObservableObject` implementation, or if `objectWillChange` is an instance of `ObservableObjectPublisher`. If you use a custom `Publisher` type, you are responsible for triggering updates yourself.
///
/// ### Manually triggering `objectWillChange`
///
/// You can also manually trigger updates by calling `ObservableObjectPublisher/send()`.
///
/// This is useful for cases where `@Published` does not suffice. For example:
///
/// ```
/// class AppModel: ObservableObject {
///     class ChildModel {
///         var foo: String = "Apple"
///     }
///
///     var childModel = ChildModel()
///
///     func updateChildModel() {
///         childModel.foo = "Banana"
///
///         objectWillChange.send()
///     }
/// }
/// ```
///
/// In this example, `AppModel` holds a reference to a child model, `ChildModel`. Adding a `@Published` to the `childModel` variable would have no effect because `ChildModel` is a class and not a value type. Therefore, to emit a change event, you must manually call `objectWillChange.send()` when updating the child model.
///
/// ### Using a custom publisher
///
/// In some cases, you may want to use a custom `Publisher` type for `objectWillChange`. For example:
///
/// ```
/// class AppModel: ObservableObject {
///     public let objectWillChange = PassthroughSubject<Void, Never>()
/// }
/// ```
///
/// This example uses a `Combine/PassthroughSubject` for its `objectWillChange` requirement. A passthrough subject is a publisher that lets you send values manually (i.e. "passes through" any values sent to it).
///
/// **Note:** The `@Published` property wrapper does not work with custom publishers. If you use a custom publisher, you are responsible for updating the object yourself. For example:
///
/// ```
/// class AppModel: ObservableObject {
///     public let objectWillChange = PassthroughSubject<Void, Never>()
///
///     var foo: Bool = false {
///         willSet {
///             objectWillChange.send()
///         }
///     }
/// }
/// ```
///
/// Here `objectWillChange.send()` is manually called everytime `foo` is about to update, using the `willSet` observer.
///
/// ### Using `ObservableObject` with SwiftUI
///
/// An observable object can be used to drive changes in a `View`, via three property wrapper types:
///
/// - `@ObservedObject`
/// - `@EnvironmentObject`
/// - `@StateObject`
///
/// #### Usage with `@StateObject`
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var foo: Bool = false
/// }
///
/// struct ContentView: View {
///     @StateObject var appModel = AppModel()
///
///     var body: some View {
///         Toggle("Foo", isOn: $appModel.foo)
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol ObservableObject : AnyObject {

    /// The type of publisher that emits before the object has changed.
    associatedtype ObjectWillChangePublisher : Publisher = ObservableObjectPublisher where Self.ObjectWillChangePublisher.Failure == Never

    /// A publisher that emits before the object has changed.
    var objectWillChange: Self.ObjectWillChangePublisher { get }
}

/// AccessibilityActionKind denotes the type of action for an Accessibility Action to support.
///
/// This struct is almost always found as an input to the `View/accessibilityAction(_:_:)` View modifier.
/// To learn more about delivering exceptional accessibility experiences, see [Delivering an Exceptional Accessibility Experience](https://developer.apple.com/documentation/uikit/accessibility_for_ios_and_tvos/delivering_an_exceptional_accessibility_experience) or [iOS Accessibility Tutorial](https://www.raywenderlich.com/4720178-ios-accessibility-tutorial-making-custom-controls-accessible).
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct AccessibilityActionKind : Equatable {

    /// The inferred accessibility action inherited from the view type.
    ///
    /// This constant will default to the accessibility action associated with the modified object.
    /// For example, a button, label, or text would all default to their unique accessibility behaviors.
    public static let `default`: AccessibilityActionKind

    /// A two finger scrub gesture performed while VoiceOver focus is on or inside the component.
    public static let escape: AccessibilityActionKind

    /// A double tap with two fingers while VoiceOver focus is on or inside the component.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    @available(macOS, unavailable)
    public static let magicTap: AccessibilityActionKind

    /// Initialize an `AccessibilityActionKind` with the name of the action type.
    ///
    /// An example of an accessibility action name could be "Open address in Maps" or
    /// "Call Fred" where "Fred" is a string variable. When VoiceOver is on the iPhone
    /// will read this name to the user.
    public init(named name: Text) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityActionKind, b: AccessibilityActionKind) -> Bool { }
}

/// A directional indicator you use when making an accessibility adjustment.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum AccessibilityAdjustmentDirection {

    /// Increment an adjustable component.
    ///
    /// VoiceOver generates this action when the component has a role of `adjustable` and the user places focus on it and swipes upward.
    case increment

    /// Decrement an adjustable component.
    ///
    /// VoiceOver generates this action when the component has a role of `adjustable` and the user places focus on it and swipes downward.
    case decrement

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityAdjustmentDirection, b: AccessibilityAdjustmentDirection) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AccessibilityAdjustmentDirection : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AccessibilityAdjustmentDirection : Hashable {
}

/// A `ViewModifier` used to provide accessibility content.
///
/// The `AccessibilityAttachmentModifier` is most commonly found as the modified content in an accessibility modifiers attached to a View.
/// See `View/accessibilityAction(_:_:)` for example usage. See [Creating Accessible Views](https://developer.apple.com/documentation/swiftui/view/accessibility/creating_accessible_views?changes=_8) for an example accessibility project.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct AccessibilityAttachmentModifier : ViewModifier {

    /// The type of view representing the body.
    public typealias Body = Never
}

/// Defines the children's behavior of accessibility elements.
///
/// See [Accessibility in SwiftUI](https://swiftwithmajid.com/2019/09/10/accessibility-in-swiftui/) for more information on implementing accessibility functionality.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct AccessibilityChildBehavior : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AccessibilityChildBehavior, rhs: AccessibilityChildBehavior) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AccessibilityChildBehavior {

    /// Child accessibility elements are ignored
    public static let ignore: AccessibilityChildBehavior

    /// Any child accessibility elements become children of the new
    /// accessibility element
    public static let contain: AccessibilityChildBehavior

    /// Combine any child accessibility element's properties for the
    /// new accessibility element
    public static let combine: AccessibilityChildBehavior
}

/// Pair related views such that one view serves as the view content, and one view serves as the view label.
///
/// `AccessibilityLabeledPairRole` is almost always used in conjunction with the `View/accessibilityLabeledPair(role:id:in:)` modifier.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public enum AccessibilityLabeledPairRole {

    /// This element represents the label part of the label / content pair.
    ///
    /// For example, it might be the explanatory text to the left of a control,
    /// describing what the control does.
    case label

    /// This element represents the content part of the label / content pair.
    ///
    /// For example, it might be the custom control itself.
    case content

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityLabeledPairRole, b: AccessibilityLabeledPairRole) -> Bool { }
}

extension AccessibilityLabeledPairRole : Hashable {

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

/// A struct used to define the characteristics of a view when accessed for accessibility.
///
/// `AccessibilityTraits` are almost always used in conjunction with the `View/accessibilityAddTraits(_:)` view modifier.
/// They are used to tell an assistive accessibility application (such as VoiceOver)
/// how an element should be treated.
///
/// For example:
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        Button("I'm a button! 😏") {
///            // Do something on button click
///        }.accessibilityAddTraits(.isButton)
///    }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct AccessibilityTraits : SetAlgebra {

    /// The accessibility element is a button.
    public static let isButton: AccessibilityTraits

    /// The accessibility element is a header that divides content into sections, like the title of a navigation bar.
    public static let isHeader: AccessibilityTraits

    /// The accessibility element is currently selected.
    public static let isSelected: AccessibilityTraits

    /// The accessibility element is a link.
    public static let isLink: AccessibilityTraits

    /// The accessibility element is a search field.
    public static let isSearchField: AccessibilityTraits

    /// The accessibility element is an image.
    public static let isImage: AccessibilityTraits

    /// The accessibility element plays its own sound when activated.
    public static let playsSound: AccessibilityTraits

    /// The accessibility element behaves as a keyboard key.
    public static let isKeyboardKey: AccessibilityTraits

    /// The accessibility element is a static text that cannot be modified by the user.
    public static let isStaticText: AccessibilityTraits

    /// The accessibility element provides summary information when the application starts.
    ///
    /// Use this trait to characterize an accessibility element that provides a summary of
    /// current conditions, settings, or state, like the temperature in the Weather app.
    public static let isSummaryElement: AccessibilityTraits

    /// The accessibility element frequently updates its label or value.
    ///
    /// Include this trait when you want an assistive application to poll for changes
    /// when it needs updated information. For example, you might use this trait to
    /// characterize the readout of a stopwatch.
    public static let updatesFrequently: AccessibilityTraits

    /// The accessibility element starts a media session when it is activated.
    ///
    /// Use this trait to silence the audio output of an assistive technology,
    /// such as VoiceOver, during a media session that should not be interrupted.
    /// For example, you might use this trait to silence VoiceOver speech while the user is recording audio.
    public static let startsMediaSession: AccessibilityTraits

    /// The accessibility element allows direct touch interaction for VoiceOver users.
    public static let allowsDirectInteraction: AccessibilityTraits

    /// The accessibility element causes an automatic page turn when VoiceOver finishes reading the text within it.
    public static let causesPageTurn: AccessibilityTraits

    /// The siblings of this accessibility element will be ignored by accessibility.
    public static let isModal: AccessibilityTraits

    /// Creates an empty set.
    ///
    /// This initializer is equivalent to initializing with an empty array
    /// literal. For example, you create an empty `Set` instance with either
    /// this initializer or with an empty array literal.
    ///
    ///     var emptySet = Set<Int>()
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptySet = []
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    public init() { }

    /// Adds the elements of the given set to the set.
    ///
    /// In the following example, the elements of the `visitors` set are added to
    /// the `attendees` set:
    ///
    ///     var attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors: Set = ["Diana", "Marcia", "Nathaniel"]
    ///     attendees.formUnion(visitors)
    ///     print(attendees)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     var initialIndices = Set(0..<5)
    ///     initialIndices.formUnion([2, 3, 6, 7])
    ///     print(initialIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formUnion(_ other: AccessibilityTraits) { }

    /// Returns a new set with the elements that are common to both this set and
    /// the given set.
    ///
    /// In the following example, the `bothNeighborsAndEmployees` set is made up
    /// of the elements that are in *both* the `employees` and `neighbors` sets.
    /// Elements that are in only one or the other are left out of the result of
    /// the intersection.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func intersection(_ other: AccessibilityTraits) -> AccessibilityTraits { }

    /// Removes the elements of this set that aren't also in the given set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// not also members of the `neighbors` set are removed. In particular, the
    /// names `"Alicia"`, `"Chris"`, and `"Diana"` are removed.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formIntersection(neighbors)
    ///     print(employees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formIntersection(_ other: AccessibilityTraits) { }

    /// Returns a new set with the elements that are either in this set or in the
    /// given set, but not in both.
    ///
    /// In the following example, the `eitherNeighborsOrEmployees` set is made up
    /// of the elements of the `employees` and `neighbors` sets that are not in
    /// both `employees` *and* `neighbors`. In particular, the names `"Bethany"`
    /// and `"Eric"` do not appear in `eitherNeighborsOrEmployees`.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
    ///     print(eitherNeighborsOrEmployees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func symmetricDifference(_ other: AccessibilityTraits) -> AccessibilityTraits { }

    /// Removes the elements of the set that are also in the given set and adds
    /// the members of the given set that are not already in the set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of `neighbors` are removed from `employees`, while the
    /// elements of `neighbors` that are not members of `employees` are added to
    /// `employees`. In particular, the names `"Bethany"` and `"Eric"` are
    /// removed from `employees` while the name `"Forlani"` is added.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type.
    public mutating func formSymmetricDifference(_ other: AccessibilityTraits) { }

    /// Returns a Boolean value that indicates whether the given element exists
    /// in the set.
    ///
    /// This example uses the `contains(_:)` method to test whether an integer is
    /// a member of a set of prime numbers.
    ///
    ///     let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    ///     let x = 5
    ///     if primes.contains(x) {
    ///         print("\(x) is prime!")
    ///     } else {
    ///         print("\(x). Not prime.")
    ///     }
    ///     // Prints "5 is prime!"
    ///
    /// - Parameter member: An element to look for in the set.
    /// - Returns: `true` if `member` exists in the set; otherwise, `false`.
    public func contains(_ member: AccessibilityTraits) -> Bool { }

    /// Returns a new set with the elements of both this and the given set.
    ///
    /// In the following example, the `attendeesAndVisitors` set is made up
    /// of the elements of the `attendees` and `visitors` sets:
    ///
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Marcia", "Nathaniel"]
    ///     let attendeesAndVisitors = attendees.union(visitors)
    ///     print(attendeesAndVisitors)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     let initialIndices = Set(0..<5)
    ///     let expandedIndices = initialIndices.union([2, 3, 6, 7])
    ///     print(expandedIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set with the unique elements of this set and `other`.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func union(_ other: AccessibilityTraits) -> AccessibilityTraits { }

    /// Removes the given element and any elements subsumed by the given element.
    ///
    /// - Parameter member: The element of the set to remove.
    /// - Returns: For ordinary sets, an element equal to `member` if `member` is
    ///   contained in the set; otherwise, `nil`. In some cases, a returned
    ///   element may be distinguishable from `newMember` by identity comparison
    ///   or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the set
    ///   and `[member]`, or `nil` if the intersection is empty.
    public mutating func remove(_ member: AccessibilityTraits) -> AccessibilityTraits? { }

    /// Inserts the given element in the set if it is not already present.
    ///
    /// If an element equal to `newMember` is already contained in the set, this
    /// method has no effect. In this example, a new element is inserted into
    /// `classDays`, a set of days of the week. When an existing element is
    /// inserted, the `classDays` set does not change.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.wednesday, .friday]
    ///     print(classDays.insert(.monday))
    ///     // Prints "(true, .monday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    ///     print(classDays.insert(.friday))
    ///     // Prints "(false, .friday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in the
    ///   set. If an element equal to `newMember` was already contained in the
    ///   set, the method returns `(false, oldMember)`, where `oldMember` is the
    ///   element that was equal to `newMember`. In some cases, `oldMember` may
    ///   be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func insert(_ newMember: AccessibilityTraits) -> (inserted: Bool, memberAfterInsert: AccessibilityTraits) { }

    /// Inserts the given element into the set unconditionally.
    ///
    /// If an element equal to `newMember` is already contained in the set,
    /// `newMember` replaces the existing element. In this example, an existing
    /// element is inserted into `classDays`, a set of days of the week.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.monday, .wednesday, .friday]
    ///     print(classDays.update(with: .monday))
    ///     // Prints "Optional(.monday)"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: For ordinary sets, an element equal to `newMember` if the set
    ///   already contained such a member; otherwise, `nil`. In some cases, the
    ///   returned element may be distinguishable from `newMember` by identity
    ///   comparison or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the
    ///   set and `[newMember]`, or `nil` if the intersection is empty.
    public mutating func update(with newMember: AccessibilityTraits) -> AccessibilityTraits? { }

    /// A type for which the conforming type provides a containment test.
    public typealias Element = AccessibilityTraits

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = AccessibilityTraits

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AccessibilityTraits, b: AccessibilityTraits) -> Bool { }
}

/// A storage type for an action sheet presentation.
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
public struct ActionSheet {

    /// Creates an action sheet with the provided buttons.
    public init(title: Text, message: Text? = nil, buttons: [ActionSheet.Button] = [.cancel()]) { }

    /// A button representing an operation of an action sheet presentation.
    public typealias Button = Alert.Button
}

/// A representation for an alert presentation.
///
/// An ``Alert`` is a modal-like presentation which contains a title, message, and
/// between one and two action buttons. Alerts often convey important information
/// about the state of the app and typically request feedback from the user. While the
/// styling of alerts is semi-fixed, there are three available styles for the buttons to choose from:
/// `.default`, `.destructive`, and `.cancel`. To actually present an alert, see
/// ``View/alert(_:_:)``.
///
/// An alert can be created with one of two initializers, depending on if one button
/// or two is required. For example, to create an Alert with one button:
///
/// ![Example alert 1](alert-example-1.gif)
///
/// ```
/// struct ExampleAlertView: View {
///    @State private var showAlert = false
///
///    var body: some View {
///        Button("Tap to view alert") {
///            showAlert = true
///        }
///        .alert(isPresented: $showAlert) {
///            Alert(
///                title: Text("An important title!"),
///                message: Text("A message that adds additional context on the alert.")
///            )
///        }
///    }
/// }
/// ```
///
/// If the `dismissButton` value is left unspecified (as it was in this example),
/// it will default to a dismiss button with the text "Ok".
///
/// In order to customize the type of button (or to create an alert with two buttons),
/// create a new ``Alert/Button`` instance and pass it in as a part of the initializer.
/// For example, to make an alert with a cancel and destructive button:
///
/// ![Example alert 2](alert-example-2.gif)
///
/// ```
/// struct ExampleAlertView: View {
///    @State private var showAlert = false
///
///    var body: some View {
///        Button("Tap to view alert") {
///            showAlert = true
///        }
///        .alert(isPresented: $showAlert) {
///            Alert(
///                title: Text("Are you sure?"),
///                message: Text("The following action will delete everything. Please confirm."),
///                primaryButton: Alert.Button.destructive(Text("Delete")),
///                secondaryButton: Alert.Button.cancel(Text("No, take me back!"))
///            )
///        }
///    }
/// }
/// ```
///
/// For illustrative purposes, the alert button values used the expanded syntax in this example.
/// It is also valid to use the shorthand syntax when declaring alert buttons: `.default(_:action:)`,
/// `.cancel(_:)`, or `.destructive(_:action:)`
///
/// Notes:
///  - Stylistically, `.default` and `.cancel` alert button styles are nearly identical with
///  the exception that `.cancel` has a bolded font weight.
///  - Alert is the equivalent to UIKit's UIAlertView.
///  - For information on the human interface guidelines for alerts, see:
///  [https://developer.apple.com/design/human-interface-guidelines/ios/views/alerts/](https://developer.apple.com/design/human-interface-guidelines/ios/views/alerts/)
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Alert {

    /// Creates an alert with one button.
    ///
    /// If the `dismissButton` parameter is left unspecified, it will default to a button with the text "Ok".
    ///
    /// For example, to create a new Alert with this initializer and present it:
    ///
    /// ![Example alert 3](alert-example-3.gif)
    ///
    /// ```
    /// struct ExampleAlertView: View {
    ///    @State private var showAlert = false
    ///
    ///    var body: some View {
    ///        Button("Tap to view alert") {
    ///            showAlert = true
    ///        }
    ///        .alert(isPresented: $showAlert) {
    ///            Alert(
    ///                title: Text("An important title!"),
    ///                message: Text("A message that adds additional context on the alert."),
    ///                dismissButton: .default(Text("I understand."))
    ///            )
    ///        }
    ///    }
    /// }
    /// ```
    public init(title: Text, message: Text? = nil, dismissButton: Alert.Button? = nil) { }

    /// Creates an alert with two buttons.
    ///
    /// When the screen is too small to display both buttons horizontally, they will
    /// switch to being vertically stacked. The system determines the visual ordering of the buttons based on their type and
    /// if they are a primary or secondary button.
    ///
    /// For example, to create a new Alert with this initializer and present it:
    ///
    /// ![Example alert 4](alert-example-2.gif)
    ///
    /// ```
    /// struct ExampleAlertView: View {
    ///    @State private var showAlert = false
    ///
    ///    var body: some View {
    ///        Button("Tap to view alert") {
    ///            showAlert = true
    ///        }
    ///        .alert(isPresented: $showAlert) {
    ///            Alert(
    ///                title: Text("Are you sure?"),
    ///                message: Text("The following action will delete everything. Please confirm."),
    ///                primaryButton: .destructive(Text("Delete")),
    ///                secondaryButton: .cancel(Text("No, take me back!"))
    ///            )
    ///        }
    ///    }
    /// }
    /// ```
    public init(title: Text, message: Text? = nil, primaryButton: Alert.Button, secondaryButton: Alert.Button) { }

    /// A button representing an ``Alert`` button action.
    public struct Button {

        /// Creates an ``Alert/Button`` with the default style. The `.default` alert
        /// button is styled nearly identically with `.cancel` except that `.cancel`
        /// has a bolded font weight.
        ///
        /// For example, to create a new alert button with the default style:
        ///
        /// ```
        /// Alert(
        ///    title: Text("An important title!"),
        ///    message: Text("A message that adds additional context on the alert."),
        ///    dismissButton: .default(Text("A default button"), action: {
        ///        print("Default button pressed, do something.")
        ///    })
        /// )
        /// ```
        public static func `default`(_ label: Text, action: (() -> Void)? = {}) -> Alert.Button { }

        /// Creates an ``Alert/Button`` that indicates cancellation of some
        /// operation. The `.cancel` alert button is styled nearly identically with
        /// `.default` except that `.cancel` has a bolded font weight.
        ///
        /// For example, to create a new alert button with the cancel style:
        ///
        /// ```
        /// Alert(
        ///    title: Text("An important title!"),
        ///    message: Text("A message that adds additional context on the alert."),
        ///    dismissButton: .cancel(Text("A cancel button"), action: {
        ///        print("Cancel button pressed, do something.")
        ///    })
        /// )
        /// ```
        public static func cancel(_ label: Text, action: (() -> Void)? = {}) -> Alert.Button { }

        /// Creates an ``Alert/Button`` that indicates cancellation of some
        /// operation. The `.cancel` alert button is styled nearly identically with
        /// `.default` except that `.cancel` has a bolded font weight.
        ///
        /// The system automatically chooses the label of the button for the appropriate locale.
        /// For the English locale, this defaults to "Cancel"
        ///
        /// For example, to create a new alert button with the cancel style:
        ///
        /// ```
        /// Alert(
        ///    title: Text("An important title!"),
        ///    message: Text("A message that adds additional context on the alert."),
        ///    dismissButton: .cancel(action: {
        ///        print("Cancel button pressed, do something.")
        ///    })
        /// )
        /// ```
        public static func cancel(_ action: (() -> Void)? = {}) -> Alert.Button { }

        /// Creates an ``Alert/Button`` with a style indicating destruction of
        /// some data.
        ///
        /// For example, to create a new alert button with the destructive style:
        ///
        /// ```
        /// Alert(
        ///    title: Text("An important title!"),
        ///    message: Text("A message that adds additional context on the alert."),
        ///    dismissButton: .destructive(Text("A destructive button"), action: {
        ///        print("Destructive button pressed, do something.")
        ///    })
        /// )
        /// ```
        public static func destructive(_ label: Text, action: (() -> Void)? = {}) -> Alert.Button { }
    }
}

/// An alignment in both axes.
///
/// Use this structure to align a view when it has both a vertical and
/// horizontal degree of freedom.
///
/// It is used in 4 places:
/// - ``ZStack``, in the initializer
/// - ``View/overlay(_:alignment:)``, in the view modifier
/// - ``View/background(_:alignment:)``, in the view modifier
/// - ``View/frame(width:height:alignment:)``, in the view modifier
///
/// See those pages for more on how to use them.
///
/// There are 9 out-of-the-box alignments:
/// 1. ``Alignment/topLeading``
/// 2. ``Alignment/topCenter``
/// 3. ``Alignment/topTrailing``
/// 4. ``Alignment/leading``
/// 5. ``Alignment/center``
/// 6. ``Alignment/trailing``
/// 7. ``Alignment/bottomLeading``
/// 8. ``Alignment/bottom``
/// 9. ``Alignment/bottomTrailing``
///
/// In addition, you can also create your own alignments from the
/// ``Alignment/init(horizontal:vertical)`` initializer.
///
/// See the example below.
///
/// ```
/// struct AlignmentView: View {
///     var body: some View {
///         ZStack(alignment: Alignment.top) { //Try changing this!
///             Text("Move me around 🤠")
///             Color.clear
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Alignment : Equatable {

    /// The alignment on the horizontal axis.
    ///
    /// An ``Alignment`` is simply a combination of a vertical alignment
    /// and a horizontal alignment. This is the ``HorizontalAlignment``
    /// component.
    ///
    /// This is usually specified indirectly using one of the pre-defined
    /// alignments or through the ``Alignment/init(horizontal:vertical)``
    /// initializer. However, you can also specify it directly:
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         var alignment = Alignment.topLeading
    ///         alignment.horizontal = .center
    ///
    ///         return ZStack(alignment: alignment) {
    ///             Text("Move me around 🤠")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public var horizontal: HorizontalAlignment

    /// The alignment on the vertical axis.
    ///
    /// An ``Alignment`` is simply a combination of a vertical alignment
    /// and a horizontal alignment. This is the ``VerticalAlignment``
    /// component.
    ///
    /// This is usually specified indirectly using one of the pre-defined
    /// alignments or through the ``Alignment/init(horizontal:vertical)``
    /// initializer. However, you can also specify it directly:
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         var alignment = Alignment.topLeading
    ///         alignment.vertical = .center
    ///
    ///         return ZStack(alignment: alignment) {
    ///             Text("Move me around 🤠")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public var vertical: VerticalAlignment

    /// Creates an instance with the given horizontal and vertical alignments.
    ///
    /// An ``Alignment`` is simply a combination of a vertical alignment
    /// and a horizontal alignment. Use this initializer to specify
    /// the components directly.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         let alignment = Alignment(horizontal: .top, vertical: .leading)
    ///
    ///         return ZStack(alignment: alignment) {
    ///             Text("Move me around 🤠")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - horizontal: The alignment on the horizontal axis.
    ///   - vertical: The alignment on the vertical axis.
    @inlinable public init(horizontal: HorizontalAlignment, vertical: VerticalAlignment) { }

    /// A guide marking the center of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .center) {
    ///             Text("🤠")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let center: Alignment

    /// A guide marking the leading edge of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .leading) {
    ///             Text("⬅️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let leading: Alignment

    /// A guide marking the trailing edge of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .trailing) {
    ///             Text("➡️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let trailing: Alignment

    /// A guide marking the top edge of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .top) {
    ///             Text("⬆️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let top: Alignment

    /// A guide marking the bottom edge of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .bottom) {
    ///             Text("⬇️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let bottom: Alignment

    /// A guide marking the top and leading edges of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .topLeading) {
    ///             Text("↖️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let topLeading: Alignment

    /// A guide marking the top and trailing edges of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .topTrailing) {
    ///             Text("↖️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let topTrailing: Alignment

    /// A guide marking the bottom and leading edges of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .bottomLeading) {
    ///             Text("↙️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let bottomLeading: Alignment

    /// A guide marking the bottom and trailing edges of the view.
    ///
    /// ```
    /// struct AlignmentView: View {
    ///     var body: some View {
    ///         ZStack(alignment: .center) {
    ///             Text("↘️")
    ///             Color.clear
    ///     }
    /// }
    /// ```
    public static let bottomTrailing: Alignment

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Alignment, b: Alignment) -> Bool { }
}

/// Types used to identify alignment guides.
///
/// Use this protocol to create custom alignment guides. Custom
/// alignment guides are needed to align views which are not
/// in the same container.
///
/// To conform to this protocol, there is only one requirement:
/// ``AlignmentID/defaultValue(in:)``.
///
/// The most convenient way to create a custom alignment is with an
/// extension.
///
/// A custom vertical alignment:
///
/// ```
/// extension VerticalAlignment {
///     enum CustomAlignment: AlignmentID {
///        static func defaultVAlue(in d: ViewDimensions) -> CGFloat {
///             d[VerticalAlignment.center]
///         }
///     }
///     static let custom = VerticalAlignment(CustomAlignment.self)
/// }
/// ```
///
/// To create a custom alignment for a ``ZStack``, extend both
/// ``VerticalAlignment`` and ``HorizontalAlignment``:
///
/// ```
/// extension VerticalAlignment {
///     enum CustomAlignment: AlignmentID {
///        static func defaultVAlue(in d: ViewDimensions) -> CGFloat {
///             d[.top]
///         }
///     }
///     static let vertical = VerticalAlignment(CustomAlignment.self)
/// }
///
/// extension HorizontalAlignment {
///     enum CustomAlignment: AlignmentID {
///        static func defaultVAlue(in d: ViewDimensions) -> CGFloat {
///             d[.leading]
///         }
///     }
///     static let horizontal = HorizontalAlignment(CustomAlignment.self)
/// }
///
/// extension Alignment {
///     static let custom = Alignment(horizontal: .horizontal, vertical: .vertical)
/// }
/// ```
///
/// For more on creating your own alignments, check out
/// [this article](https://swiftui-lab.com/alignment-guides/).
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol AlignmentID { }
extension AlignmentID {

    /// The value of the corresponding guide in the given context when not
    /// otherwise set in that context.
    ///
    /// This is the only requirement of conforming to the ``AlignmentID``
    /// protocol.
    ///
    /// See ``ViewDimensions`` for information on the parameter of this
    /// function.
    ///
    /// For more on creating your own alignments, check out
    /// [this article](https://swiftui-lab.com/alignment-guides/).
    ///
    /// Here is a simple example of implementing this function:
    ///
    /// ```
    /// extension VerticalAlignment {
    ///     enum CustomAlignment: AlignmentID {
    ///        static func defaultVAlue(in d: ViewDimensions) -> CGFloat {
    ///             d[VerticalAlignment.center]
    ///         }
    ///     }
    ///     static let custom = VerticalAlignment(CustomAlignment.self)
    /// }
    /// ```
    ///
    /// - Parameter context: The view dimensions for aligning the view.
    ///
    /// - Returns: A default alignment value for the custom alignment.
    static func defaultValue(in context: ViewDimensions) -> CGFloat { }
}

/// An opaque value derived from an anchor source and a particular view.
///
/// You can convert the anchor to a `Value` in the coordinate space of a target
/// view by using a `GeometryProxy` to specify the target view.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Anchor<Value> {

    /// A type-erased geometry value that produces an anchored value of a given
    /// type.
    ///
    /// SwiftUI passes anchored geometry values around the view tree via
    /// preference keys. It then converts them back into the local coordinate
    /// space using a `GeometryProxy` value.
    @frozen public struct Source {
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Anchor.Source where Value == CGRect {

    /// Returns an anchor source rect defined by `r` in the current view.
    public static func rect(_ r: CGRect) -> Anchor<Value>.Source { }

    /// An anchor source rect defined as the entire bounding rect of the current
    /// view.
    public static var bounds: Anchor<CGRect>.Source { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Anchor.Source where Value == CGPoint {

	/// Returns an anchor source point defined by a point `p` in the current view.
	///
	/// - Parameter p: The `CGPoint` to anchor.
    public static func point(_ p: CGPoint) -> Anchor<Value>.Source { }

    /// Returns an anchor source point defined by a point `p` in the current view.
    ///
    /// - Parameter p: The `UnitPoint` to anchor.
    public static func unitPoint(_ p: UnitPoint) -> Anchor<Value>.Source { }

    /// An anchor source point defined by the top leading corner of the current view.
    public static var topLeading: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the center of the top edge of the current view.
    public static var top: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the top trailing corner of the current view.
    public static var topTrailing: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the center of the leading edge of the current view.
    public static var leading: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the center point of the current view.
    public static var center: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the center of the trailing edge of the current view.
    public static var trailing: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the bottom leading corner of the current view.
    public static var bottomLeading: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the center of the bottom edge of the current view.
    public static var bottom: Anchor<CGPoint>.Source { get }

    /// An anchor source point defined by the bottom trailing corner of the current view.
    public static var bottomTrailing: Anchor<CGPoint>.Source { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Anchor.Source {

	/// Creates an anchor source with generic type array from an array of anchor source.
	///
	/// - Parameter array: The array of anchor source points.
    public init<T>(_ array: [Anchor<T>.Source]) where Value == [T] { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Anchor.Source {

	/// Creates an anchor source with generic type optional from an optional anchor source.
	///
	/// - Parameter anchor: The optional anchor source.
    public init<T>(_ anchor: Anchor<T>.Source?) where Value == T? { }
}

/// A geometric angle whose value is accessible in radians or degrees.
///
/// An Angle can be created using either radians or degrees, and its value can
/// be accessed in either radians or degrees. An angle can be passed into the 
/// `Shape/rotation(:anchor:)` modifier to rotate a Shape:
///
/// ![Angle rotation basic example](angle-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Rectangle()
///             .rotation(Angle(degrees: 45))
///             .fill(Color.blue)
///             .frame(width: 250, height: 75)
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Angle {

	/// The size of the angle, as measured in radians.
    ///
    /// ```
    /// let angle1 = Angle(degrees: 45)
    /// print(angle1.radians) // 0.7853981633974483
    /// 
    /// let angle2 = Angle(radians: 1)
    /// print(angle2.radians) // 1.0
    /// ```
    public var radians: Double

    /// The size of the angle, as measured in degrees.
    ///
    /// ```
    /// let angle1 = Angle(degrees: 45)
    /// print(angle1.degrees) // 45.0
    /// 
    /// let angle2 = Angle(radians: 1)
    /// print(angle2.degrees) // 57.29577951308232
    /// ```
    @inlinable public var degrees: Double

    /// Creates an angle with a value of 0 degrees/0.
    ///
    /// ```
    /// let angle = Angle()
    /// print(angle.degrees) // 0.0
    /// print(angle.radians) // 0.0
    /// ```
    @inlinable public init() { }

    /// Creates an angle with a specified number of radians.
    ///
    /// - Parameter radians: The number of radians for the new angle.
    ///
    /// ```
    /// let angle = Angle(radians: 1)
    /// print(angle.degrees) // 57.29577951308232
    /// print(angle.radians) // 1.0
    /// ```
    @inlinable public init(radians: Double) { }

    /// Creates an angle with a specified number of degrees.
    ///
    /// - Parameter degrees: The number of degrees for the new angle.
    ///
    /// ```
    /// let angle = Angle(degrees: 45)
    /// print(angle.degrees) // 45.0
    /// print(angle.radians) // 0.7853981633974483
    /// ```
    @inlinable public init(degrees: Double) { }

    /// > Changes the size of an angle to a specified number of radians.
    ///
    /// - Parameter radians: The number of radians the new angle should be.
    @inlinable public static func radians(_ radians: Double) -> Angle { }

    /// > Changes the size of an angle to a specified number of degrees.
    ///
    /// - Parameter degrees: The number of degrees the new angle should be.
    @inlinable public static func degrees(_ degrees: Double) -> Angle { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Angle : Hashable, Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: An Angle to compare.
    ///   - rhs: Another Angle to compare.
    ///
    /// ```
    /// let angle1 = Angle(degrees: 45)
    /// let angle2 = Angle(degrees: 45)
    /// let angle3 = Angle(degrees: 90)
    /// print(angle1 < angle2) // false
    /// print(angle1 < angle3) // true
    /// ```
    @inlinable public static func < (lhs: Angle, rhs: Angle) -> Bool { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// - Parameters:
    ///   - lhs: An Angle to compare.
    ///   - rhs: Another Angle to compare.
    ///
    /// ```
    /// let angle1 = Angle(degrees: 45)
    /// let angle2 = Angle(degrees: 45)
    /// let angle3 = Angle(degrees: 90)
    /// print(angle1 == angle2) // true
    /// print(angle1 == angle3) // false
    /// ```
    public static func == (a: Angle, b: Angle) -> Bool { }

    /// The hash value of the Angle.
    ///
    /// Hash values are not guaranteed to be equal across different executions 
    /// of your program. Do not save hash values to use during a future 
    /// execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///
    /// ```
    /// let angle = Angle(degrees: 45)
    /// print(angle.hashValue) // -6958825055113283289
    /// ```
    public var hashValue: Int { get }

    /// Hashes the essential components of the Angle by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this Angle.
    ///
    /// ```
    /// let angle = Angle(degrees: 45)
    /// var hasher = Hasher()
    /// angle.hash(into: &hasher)
    /// ```
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Angle : Animatable {

    /// > The data to animate.
    public var animatableData: Double

    @inlinable public static var zero: Angle { get }

    /// > The type defining the data to animate.
    public typealias AnimatableData = Double
}

/// An angular gradient.
///
/// An angular gradient is also known as a "conic" gradient. This gradient
/// applies the color function as the angle changes, relative to a center point
/// and defined start and end angles. If `endAngle - startAngle > 2π`, the
/// gradient only draws the last complete turn. If `endAngle - startAngle < 2π`,
/// the gradient fills the missing area with the colors defined by gradient
/// locations one and zero, transitioning between the two halfway across the
/// missing area. The gradient maps the unit-space center point into the
/// bounding rectangle of each shape filled with the gradient.
///
/// There are 3 main cases where AngularGradient can change:
///
/// 1. `endAngle - startAngle = 2π`
/// 2. `endAngle - startAngle > 2π`
/// 3. `endAngle - startAngle < 2π`
///
/// Note: Angles default to a clockwise rotation, but angles can be a negative value which will rotate the color counter-clockwise.
///
/// ## End Angle - Start Angle = 2π
///
/// This is the normal case where the start and end angles make a complete circle.
/// Every color will evenly distribute.
///
/// ![AngularGradient Example 1](angular-gradient-example-1.png)
///
/// ```
///  struct AngularGradientView: View {
///     let colors: [Color] = [.yellow, .red,.blue, .purple]
///
///     var body: some View {
///         Rectangle()
///            .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center))
///            .frame(width:200, height:200)
///     }
/// }
/// ```
///
/// ## End Angle - Start Angle > 2π
///
/// This is the case where the total angle is greater than a circle.
/// The gradient will only draw the last complete turn which effectively writes over the first circle portion
///
/// ![AngularGradient Example 2](angular-gradient-example-2.png)
///
/// ```
///  struct AngularGradientView: View {
///     let colors: [Color] = [.yellow, .red,.blue, .purple]
///
///     var body: some View {
///         VStack{
///             Rectangle()
///                .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center))
///                .frame(width:200, height:200)
///             Rectangle()
///                 .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center,startAngle: .degrees(0), endAngle: .degrees(360 + 45)))
///                 .frame(width:200, height:200)
///         }
///     }
/// }
/// ```
///
/// ## End Angle - Start Angle < 2π
///
/// This is the case where the total angle is less than a circle.
/// The gradient will not make a complete circle, but the missing area between the start and end will be evenly colored with the
/// first and last color of the gradient.
///
/// ![AngularGradient Example 3](angular-gradient-example-3.png)
///
/// ```
///  struct AngularGradientView: View {
///     let colors: [Color] = [.yellow, .red,.blue, .purple]
///
///     var body: some View {
///         VStack{
///             Rectangle()
///                .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center))
///                .frame(width:200, height:200)
///             Rectangle()
///                 .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center,startAngle: .degrees(0), endAngle: .degrees(180)))
///                 .frame(width:200, height:200)
///         }
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct AngularGradient : ShapeStyle, View {

	/// Creates an angular gradient from a starting and ending angle.
	///
    /// Gradient behavior acts differently according to whether the end angle - start angle is greater than, less than or equal to 2π.
    /// See ``AngularGradient`` for more information.
    /// An example,
    ///
    /// ![AngularGradient Example 3](angular-gradient-example-3.png)
    ///
    /// ```
    ///  struct AngularGradientView: View {
    ///     let colors: [Color] = [.yellow, .red,.blue, .purple]
    ///
    ///     var body: some View {
    ///         VStack{
    ///             Rectangle()
    ///                .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center))
    ///                .frame(width:200, height:200)
    ///             Rectangle()
    ///                 .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center,startAngle: .degrees(0), endAngle: .degrees(180)))
    ///                 .frame(width:200, height:200)
    ///         }
    ///     }
    /// }
    /// ```
    ///
	/// - Parameters:
	///   - gradient: The gradient with the colors to use.
	///   - center: The unit point that is center of the angular gradient.
	///   - startAngle: The `Angle` where the gradient starts. Defaults to zero.
	///   - endAngle: The `Angle` where the gradient ends. Defaults to zero.
    public init(gradient: Gradient, center: UnitPoint, startAngle: Angle = .zero, endAngle: Angle = .zero) { }

    /// Creates an angular gradient starting at and angle and going all the way around in a circle.
    ///
    /// For example,
    ///
    /// ![AngularGradient Example 1](angular-gradient-example-1.png)
    ///
    /// ```
    ///  struct ExampleView: View {
    ///     let colors: [Color] = [.yellow, .red,.blue, .purple]
    ///
    ///     var body: some View {
    ///         Rectangle()
    ///            .fill(AngularGradient(gradient: Gradient(colors: colors), center: .center))
    ///            .frame(width:200, height:200)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - gradient: The gradient with the colors to use.
    ///   - center: The unit point that is center of the angular gradient.
    ///   - angle: The `Angle` where the gradient starts. Defaults to zero.
    public init(gradient: Gradient, center: UnitPoint, angle: Angle = .zero) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

/// Animate a view when data changes.
///
/// `Animatable` describes how to animate a view with respect to some change in the view's data.
///
/// Use `Animatable` when you are unable to achieve the animation you want with `View/animation(_:)` or `withAnimation`.
///
/// `Animtable` allows fine-grained control over the animation of a SwiftUI view's animatable values. It does so by requiring `animatableData: AnimatableData`, which represents a view's animatable data.
///
/// By conforming to `Animatable`, you are able to effectively **decouple** the animation of your view from the concept of *duration*, as you give SwiftUI the ability to interpolate arbitrarily between two different values for `animatableData`. This is also the reason why `AnimatableData` must conform to `VectorArithmetic`, which provides the runtime means to add, subtract and scale the animated values as necessary to generate data points for each frame of the animation over an arbitrary time interval.
/// [animatable-modifier ->]
/// ### Implementations
///
/// #### Using `AnimatableModifier` to implement a shake effect
///
/// `Animatable` is best used via `AnimatableModifier`, which is nothing but a simple protocol that combines `Animatable` and `ViewModifier`. This allows you to decouple the animation effect from the view you want to animate.
///
/// For example:
///
/// ![Animatable Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Animatable-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var numberOfShakes: CGFloat = 0
///
///     var body: some View {
///         VStack {
///             Text("Banana🍌🍌")
///                 .font(.largeTitle)
///                 .modifier(ShakeEffect(shakeNumber: numberOfShakes))
///                 .onAppear {
///                     withAnimation(.easeIn(duration: 2.0)) {
///                         numberOfShakes = 10
///                     }
///                 }
///         }
///     }
/// }
///
/// struct ShakeEffect: AnimatableModifier {
///     var shakeNumber: CGFloat = 0
///
///     var animatableData: CGFloat {
///         get {
///             shakeNumber
///         } set {
///             shakeNumber = newValue
///         }
///     }
///
///     func body(content: Content) -> some View {
///         content
///             .offset(x: sin(shakeNumber * .pi * 2) * 10)
///     }
/// }
/// ```
///
/// This example demonstrates a horizontal "shake effect", applied on a `Text`. When run, the text animates by shaking 10 times. This is achieved by triggering an animation using `withAnimation`, and modifying the `shakeNumber` to go from `0` to `10`.
///
/// Note:
///
/// - `shakeNumber` represents the *progress* of the animation. The SwiftUI runtime can set this value through `animatableData`, and it can be any value between the initial and the final value (`0.0` and `10.0` in this case).
///
/// - `shakeNumber` is a `CGFloat` and not an `Int`. This is because the runtime needs to be able to interpolate fractionally between `0.0` and `10.0` 'shakes' - and it does so by making use of `CGFloat`'s `VectorArithmetic` conformance.
///
/// - The exact mathematical function used to interpolate `shakeNumber` is determined by what type of `Animation` is used in `withAnimation`, to animate the change from `0` shakes to `10` shakes.
///
/// #### Using `AnimatableModifier` to continuously animate a view along a circle
///
/// `AnimatableModifier`, used with `Animation/repeatForever(autoreverses:)` can also be used to create a continuous animation.
///
/// ![Animatable Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Animatable-example-2.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var progress: CGFloat = 0
///
///     var body: some View {
///         VStack {
///             Text("Banana🍌🍌")
///                 .font(.largeTitle)
///                 .modifier(CircleAnimation(radius: 24, progress: progress))
///                 .onAppear {
///                     withAnimation(Animation.easeInOut(duration: 2.0).repeatForever(autoreverses: false)) {
///                         progress = 1.0
///                     }
///                 }
///         }
///     }
/// }
///
/// struct CircleAnimation: AnimatableModifier {
///     let radius: CGFloat
///     var progress: CGFloat = 0
///
///     var animatableData: CGFloat {
///         get {
///             progress
///         } set {
///             progress = newValue
///         }
///     }
///
///     func body(content: Content) -> some View {
///         content.offset(
///             x: radius * cos(progress * (2 * CGFloat.pi)),
///             y: radius * sin(progress * (2 * CGFloat.pi))
///         )
///     }
/// }
/// ```
///
/// In this example, `Text("Banana🍌🍌")` is animated along a circle continuously.
///
/// `CircleAnimation` is an implementation of an `AnimatableModifier` that uses a simple mathematical function to calculate the `x` and `y` offset of a view, given a radius and a progress value between `0.0` and `1.0`.
///
/// When the view appears, the `CircleAnimation` modifier is animated from a progress value of `0.0` to `1.0` using `withAnimation`. The `Animation` used in `withAnimation` is modified using `Animation/repeatForever(autoreverses:)`, in order to create a loop. Note that `autoreverses` is explicitly set as `false` to prevent the animation from being reversed.
/// [<-]
/// ### Further notes
///
/// - `Animatable` along with `View` is currently broken on iOS 14, please use `AnimatableModifier`
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol Animatable{ }
extension Animatable {

    /// The type defining the data to animate.
    associatedtype AnimatableData : VectorArithmetic

    /// The data to animate.
    var animatableData: Self.AnimatableData { get set }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animatable where Self : VectorArithmetic {

    /// The data to animate.
    public var animatableData: Self
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animatable where Self.AnimatableData == EmptyAnimatableData {

    /// The data to animate.
    public var animatableData: EmptyAnimatableData
}

/// A modifier that can create another modifier with animation.
///
/// `AnimatableModifier` is closely coupled with `Animatable`.
///
/// [[animatable-modifier]]
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol AnimatableModifier : Animatable, ViewModifier{ }
extension AnimatableModifier : Animatable, ViewModifier {
}

/// A pair of animatable values, which is itself animatable.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct AnimatablePair<First, Second> : VectorArithmetic where First : VectorArithmetic, Second : VectorArithmetic {

    /// The first value.
    public var first: First

    /// The second value.
    public var second: Second

    /// Creates an animated pair with the provided values.
    @inlinable public init(_ first: First, _ second: Second) { }

    /// The zero value.
    ///
    /// Zero is the identity element for addition. For any value,
    /// `x + .zero == x` and `.zero + x == x`.
    public static var zero: AnimatablePair<First, Second> { get }

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout AnimatablePair<First, Second>, rhs: AnimatablePair<First, Second>) { }

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout AnimatablePair<First, Second>, rhs: AnimatablePair<First, Second>) { }

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: AnimatablePair<First, Second>, rhs: AnimatablePair<First, Second>) -> AnimatablePair<First, Second> { }

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: AnimatablePair<First, Second>, rhs: AnimatablePair<First, Second>) -> AnimatablePair<First, Second> { }

    /// Multiplies each component of this value by the given value.
    public mutating func scale(by rhs: Double) { }

    /// The dot-product of this animated pair with itself.
    public var magnitudeSquared: Double { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AnimatablePair<First, Second>, b: AnimatablePair<First, Second>) -> Bool { }
}

/// Specifies the timing curve of a changing on-screen value, such as spring or linear.
///
/// Functions such as ``view/animation(_:)`` and ``binding/animation(_:)`` take in the Animation structure.
///
///
/// SwiftUI includes basic animations with predefined or custom easing, as well as spring and fluid animations.
/// You can adjust an animation’s speed, set a delay before an animation starts, or specify that an animation repeats.
///
/// For example,
///
/// ![Animation Example 1](animation-example.gif)
///
/// ```
/// struct AnimateView: View {
///     @State private var flag = true
///
///     var body: some View {
///
///         VStack {
///             Rectangle()
///                 .foregroundColor(flag ? Color.yellow : Color.red)
///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
///                 .animation(.easeInOut)
///
///             Button("Animate") {
///                 self.flag.toggle()
///             }
///         }
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Animation : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Animation, rhs: Animation) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation {

    /// A persistent spring animation. When mixed with other `spring()`
    /// or `interactiveSpring()` animations on the same property, each
    /// animation will be replaced by their successor, preserving
    /// velocity from one animation to the next. Optionally blends the
    /// response values between springs over a time period.
    ///
    /// - Parameters:
    ///   - response: The stiffness of the spring, defined as an
    ///     approximate duration in seconds. A value of zero requests
    ///     an infinitely-stiff spring, suitable for driving
    ///     interactive animations.
    ///   - dampingFraction: The amount of drag applied to the value
    ///     being animated, as a fraction of an estimate of amount
    ///     needed to produce critical damping.
    ///   - blendDuration: The duration in seconds over which to
    ///     interpolate changes to the response value of the spring.
    /// - Returns: a spring animation.
    public static func spring(response: Double = 0.55, dampingFraction: Double = 0.825, blendDuration: Double = 0) -> Animation { }

    /// A convenience for a `spring()` animation with a lower
    /// `response` value, intended for driving interactive animations.
    public static func interactiveSpring(response: Double = 0.15, dampingFraction: Double = 0.86, blendDuration: Double = 0.25) -> Animation { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation {

	/// An identity animation, meaning the object appears and disappears without
	/// any motion or opacity changes.
    public static let `default`: Animation
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation {

	/// An animation where the effect starts out slower and ends slower, while
	/// moving most quickly in the middle.
	///
    /// ![Animation Example 2](animation-example-2.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.easeInOut(duration: 3.0))
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
	/// - Parameter duration: How long the effect should last.
    public static func easeInOut(duration: Double) -> Animation { }

    /// An animation where the effect starts out slower and ends slower, while
	/// moving most quickly in the middle.
	///
	/// Uses the default timing of 1 second.
    ///
    /// ![Animation Example 1](animation-example.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.easeInOut)
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    public static var easeInOut: Animation { get }

    /// An animation where the effect starts out slower and then ends more quickly.
    ///
    /// For example,
    ///
    /// ![Animation Example 3](animation-example-3.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.easeIn(duration: 3.0))
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter duration: How long the effect should last.
    public static func easeIn(duration: Double) -> Animation { }

    /// An animation where the effect starts out slower and then ends more quickly.
    ///
    /// Uses the default timing of 1 second.
    ///
    /// For example,
    ///
    /// ![Animation Example 4](animation-example-4.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.easeIn)
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    public static var easeIn: Animation { get }

    /// An animation where the effect starts out more quickly and then slows down.
    ///
    /// For example,
    ///
    /// ![Animation Example 5](animation-example-5.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.easeOut(duration: 3.0))
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter duration: How long the effect should last.
    public static func easeOut(duration: Double) -> Animation { }

    /// An animation where the effect starts out more quickly and then slows down.
    ///
    /// Uses the default timing of 1 second.
    ///
    /// For example,
    ///
    /// ![Animation Example 6](animation-example-6.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.easeOut)
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    public static var easeOut: Animation { get }

    /// An animation where the effect happens at a constant speed throughout.
    ///
    /// For example,
    ///
    /// ![Animation Example 7](animation-example-7.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.linear(duration: 3.0))
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter duration: How long the effect should last.
    public static func linear(duration: Double) -> Animation { }

    /// An animation where the effect happens at a constant speed throughout.
    ///
    /// Uses the default timing of 1 second.
    ///
    /// For example,
    ///
    /// ![Animation Example 8](animation-example-8.gif)
    ///
    /// ```
    /// struct AnimateView: View {
    ///     @State private var flag = true
    ///
    ///     var body: some View {
    ///
    ///         VStack {
    ///             Rectangle()
    ///                 .foregroundColor(flag ? Color.yellow : Color.red)
    ///                 .frame(width: flag ? 50 : 100, height: flag ? 50: 100)
    ///                 .rotationEffect(Angle(degrees: flag ? 90 : 0))
    ///                 .animation(.linear)
    ///
    ///             Button("Animate") {
    ///                 self.flag.toggle()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    public static var linear: Animation { get }

    /// An animation with a fully customized timing curve.
    ///
    /// - Parameters:
    ///   - c0x: The first x coefficient.
    ///   - c0y: The first y coefficient.
    ///   - c1x: The second x coefficient.
    ///   - c1y: The second y coefficient.
    ///   - duration: How long the effect should last.
    public static func timingCurve(_ c0x: Double, _ c0y: Double, _ c1x: Double, _ c1y: Double, duration: Double = 0.35) -> Animation { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation {

    /// An interpolating spring animation that uses a damped spring
    /// model to produce values in the range [0, 1] that are then used
    /// to interpolate within the [from, to] range of the animated
    /// property. Preserves velocity across overlapping animations by
    /// adding the effects of each animation.
    ///
    /// - Parameters:
    ///   - mass: The mass of the object attached to the spring.
    ///   - stiffness: The stiffness of the spring.
    ///   - damping: The spring damping value.
    ///   - initialVelocity: the initial velocity of the spring, as
    ///     a value in the range [0, 1] representing the magnitude of
    ///     the value being animated.
    /// - Returns: a spring animation.
    public static func interpolatingSpring(mass: Double = 1.0, stiffness: Double, damping: Double, initialVelocity: Double = 0.0) -> Animation { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation {

	/// Adds delay to your animation that runs before it starts.
	///
	/// - Parameter delay: How long the animation will wait before starting, in seconds.
    public func delay(_ delay: Double) -> Animation { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation {

    /// Returns an animation that has its speed multiplied by `speed`. For
    /// example, if you had `oneSecondAnimation.speed(0.25)`, it would be at 25%
    /// of its normal speed, so you would have an animation that would last 4
    /// seconds.
    public func speed(_ speed: Double) -> Animation { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation {

	/// Adjusts the number of times the animation should repeat itself.
	///
	/// - Parameters:
	///   - repeatCount: The number of times the animation should repeat.
	///   - autoreverses: Whether the animation should reverse when repeating.
    public func repeatCount(_ repeatCount: Int, autoreverses: Bool = true) -> Animation { }

    /// Adjusts whether the animation repeats forever.
    ///
    /// ![Animatable Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Animatable-example-2.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var progress: CGFloat = 0
    ///
    ///     var body: some View {
    ///         VStack {
    ///             Text("Banana🍌🍌")
    ///                 .font(.largeTitle)
    ///                 .modifier(CircleAnimation(radius: 24, progress: progress))
    ///                 .onAppear {
    ///                     withAnimation(Animation.easeInOut(duration: 2.0).repeatForever(autoreverses: false)) {
    ///                         progress = 1.0
    ///                     }
    ///                 }
    ///         }
    ///     }
    /// }
    ///
    /// struct CircleAnimation: AnimatableModifier {
    ///     let radius: CGFloat
    ///     var progress: CGFloat = 0
    ///
    ///     var animatableData: CGFloat {
    ///         get {
    ///             progress
    ///         } set {
    ///             progress = newValue
    ///         }
    ///     }
    ///
    ///     func body(content: Content) -> some View {
    ///         content.offset(
    ///             x: radius * cos(progress * (2 * CGFloat.pi)),
    ///             y: radius * sin(progress * (2 * CGFloat.pi))
    ///         )
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter autoreverses: Whether the animation should reverse when repeating.
    public func repeatForever(autoreverses: Bool = true) -> Animation { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Animation : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A type-erased gesture.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct AnyGesture<Value> : Gesture {

    /// Creates an instance from another gesture.
    ///
    /// - Parameter gesture: A gesture that you use to create a new gesture.
    public init<T>(_ gesture: T) where Value == T.Value, T : Gesture { }

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

/// A transition to use for animating a view on and off the screen.
///
/// Use this structure along with the ``View/transition(_:)``
/// view modifier to animate the way a ``View`` comes onto and leaves the
/// screen.
///
/// Examples of transitions include:
/// - ``AnyTransition/scale``
/// - ``AnyTransition/opacity`` (default)
/// - ``AnyTransition/slide``
/// - etc.
///
/// A transition is only one half of animating a view. You also must specify
/// a timing curve, (somewhat confusingly) called an "animation."
/// See ``Animation`` for more info on creating one of these timing curves.
///
/// ### Creating a transition
///
/// The easiest way to creat a transition is using one of
/// the many pre-made static members available in ``AnyTransition``.
/// See the sliding banana example at the bottom of this page.
///
/// You can also create your own static members by extending this
/// struct.
///
/// ```
/// extension AnyTransition {
///     static var slideAndFade: AnyTransition {
///         return AnyTransition.slide.combined(with: .opacity)
///     }
/// }
/// ```
///
/// ### Using a transition
///
/// Transitions are most often used by attaching them to views that have
/// "if" statements on them.
///
/// As long as a timing curve (``Animation``) is specified, whenever the
/// view is added to or removed from the screen, it will do so with
/// the specified transition.
///
/// There are many ways to add an animation to the transition:
/// - Using ``withAnimation(_:_:)``
/// - Using `AnyTransition`'s own ``AnyTransition/animation(_:)`` modifier.
/// - Using `View`'s ``View/animation(_:)`` modifier.
///
/// The following example applies the ``AnyTransition/slide`` transition:
///
/// ```
/// struct TransitioningBananaView: View {
///     @State var showBanana = true
///
///     var body: some View {
///         Button("Slide the banana ➡️") {
///             withAnimation { showBanana.toggle() }
///         }
///         if showBanana {
///             Text("🍌")
///                 .transition(.slide)
///         }
///     }
/// }
/// ```
///
/// - Note: By default, views transition using ``AnyTransition/opacity``.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct AnyTransition {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

	/// A transition that moves a view from its current place on screen to another place using a CGSize.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Offset the banana ↘️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.offset(CGSize(width: 100, height: 100)))
    ///         }
    ///     }
    /// }
    /// ```
	///
	/// - Parameter offset: The amount you want to move the view during the transition.
    public static func offset(_ offset: CGSize) -> AnyTransition { }

    /// A transition that moves a view from its current place on screen to another place using x and y offsets.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Offset the banana ↘️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.offset(x: 100, y: 100))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - x: The number of points you want to move the view to the right. Negative means move left. Defaults to 0.
    ///   - y: The number of points you want to move the view down. Negative means move up. Defaults to 0.
    public static func offset(x: CGFloat = 0, y: CGFloat = 0) -> AnyTransition { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

	/// A transition that scales a view from its current size down to zero size.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Scale the banana ⤵️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.scale))
    ///         }
    ///     }
    /// }
    /// ```
    public static var scale: AnyTransition { get }

    /// A transition that scales a view from its current size to a new size.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("SCALE THE BANANA ⤴️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.scale(scale: 100, anchor: .center))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - scale: The amount you want to scale the view.
    ///   - anchor: The unit point to have the view scale from.
    public static func scale(scale: CGFloat, anchor: UnitPoint = .center) -> AnyTransition { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// A transition from transparent to opaque on insertion, and from opaque to
    /// transparent on removal.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// - Note: This is the default transition when a view's transition isn't
    /// specified.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Fade the banana 🎚") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.opacity)
    ///         }
    ///     }
    /// }
    /// ```
    public static let opacity: AnyTransition
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// A transition that inserts by moving in from the leading edge, and
    /// removes by moving out towards the trailing edge.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Slide the banana ➡️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.slide)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - SeeAlso: `AnyTransition.move(edge:)`
    public static var slide: AnyTransition { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// Combines this transition with another, returning a new transition that
    /// is the result of both transitions being applied.
    ///
    /// Use this transition to combine multiple transitions at once.
    ///
    /// For example, below we combine ``AnyTransition/opacity`` with
    /// ``AnyTransition/slide`` for a new transition that both
    /// slides and fades.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Slide AND fade the banana ➡️🎚") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(AnyTransition.opacity.combined(with: .slide))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    public func combined(with other: AnyTransition) -> AnyTransition { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// Returns a transition defined between an active modifier and an identity
    /// modifier.
    ///
    /// Use this transition for maximum customization. It allows you to
    /// pass in any two ``ViewModifier``s and create your own custom
    /// transition from them.
    ///
    /// The first view modifier, `active`, is what you want to apply to the
    /// view at the very moment it is removed from the screne. The second
    /// view modifier, `identity`, is what you want to apply right as the
    /// transition has finished.
    ///
    /// See ``ViewModifier`` for more on how to create your own modifiers.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// The following simple example just recreates the
    /// ``AnyTransition/opacity`` transition.
    ///
    /// ```
    /// struct OpacityModifier: ViewModifier {
    ///     let opacity: Double
    ///
    ///     func body(content: Content) {
    ///         content.opacity(opacity)
    ///     }
    /// }
    ///
    /// extension AnyTransition {
    ///     static var opOpacity: AnyTransition {
    ///         .modifier(active: CustomModifier(opacity: 0),
    ///                   identity: CustomModifier(opacity: 1))
    ///     }
    /// }
    ///
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("OP fade the banana 🎚❗️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.opOpacity)
    ///         }
    ///     }
    /// }
    /// ```
    public static func modifier<E>(active: E, identity: E) -> AnyTransition where E : ViewModifier { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// Attaches an animation to this transition.
    ///
    /// Use this modifier to control the timing curve
    /// directly on the transition itself.
    ///
    /// For some reason, this method only works on some of the transitions.
    ///
    /// Transitions where this works:
    /// - ``AnyTransition/scale``
    /// - ``AnyTransition/opacity``
    ///
    /// Transition where this doesn't work:
    /// - ``AnyTransition/offset(x:y:)``
    /// - ``AnyTransition/slide``
    /// - ``AnyTransition/move(edge:)``
    ///
    /// Compare the following two examples that do the same thing.
    /// The second one uses this modifier; the first one does not.
    ///
    /// ```
    /// struct FirstBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Scale the banana ⤴️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.scale)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ```
    /// struct SecondBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Scale the banana ⤴️") { showBanana.toggle() }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(AnyTransition.scale.animation(Animation.easeInOut))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    public func animation(_ animation: Animation?) -> AnyTransition { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// A transition that does nothing.
    ///
    /// Since the default transition is ``AnyTransition/opacity``,
    /// use this modifier to specify a transition that does nothing.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct IdentityBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Apparate the banana.") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.identity)
    ///         }
    ///     }
    /// }
    /// ```
    public static let identity: AnyTransition
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// Returns a transition that moves the view away, towards the specified
    /// edge of the view.
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Move the banana ➡️") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.move(edge: .trailing))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    public static func move(edge: Edge) -> AnyTransition { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension AnyTransition {

    /// Provides a composite transition that uses a different transition for
    /// insertion versus removal.
    ///
    /// ```
    /// struct TransitioningBananaView: View {
    ///     @State var showBanana = true
    ///
    ///     var body: some View {
    ///         Button("Slide the banana in ➡️, fade banana out 🎚") {
    ///             withAnimation { showBanana.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.asymmetric(insertion: .slide, removal: .opacity))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// See ``AnyTransition`` for more on how to use this transition.
    public static func asymmetric(insertion: AnyTransition, removal: AnyTransition) -> AnyTransition { }
}

/// A view that provides type-erasure for views of other types.
///
/// An `AnyView` hides the type of the `View` value passed to it (similar to how `AnyHashable` hides the type of `Hashable` value passed to it).
///
/// To type-erase your view, pass it to `AnyView/init(_:)` like this:
///
///  ![AnyView Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/anyview-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         AnyView(Text("Hello, world!"))
///     }
/// }
/// ```
///
/// Changing the type of view using with `AnyView` destroys the view hierarchy for the old type and creates a new hierarchy for the new type. In the following example, `Text` is destroyed and `Color` is created when `foo` is set to `false`:
///
///  ![AnyView Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/anyview-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     let foo: Bool = false
///
///     var body: some View {
///         if foo {
///             AnyView(Text("Hello, world!"))
///         } else {
///             AnyView(Color.red)
///         }
///     }
/// }
/// ```
///
/// Avoid frequently changing the underlying type of view being erased, especially for complex views, as poor performance may result. `AnyView` is best suited for use in the deepest part of your view hierarchy, such as a list's row content in `List/init(_:id:selection:rowContent:)`. It is also suited for use in different layers of your view hierarchy, via either `View/overlay(_:alignment:)` or `View/background(_:alignment:)`.
///
/// Consider whether the usage of `AnyView` is appropriate, or even necessary. A common mistake is to use `AnyView` like this:
///
/// ```
/// func makeHelperView() -> some View {
///     if foo {
///         return AnyView(Text("Hello, world!"))
///     } else {
///         return AnyView(Color.red)
///     }
/// }
/// ```
///
/// Wherein adding a `@ViewBuilder` would be more appropriate:
///
/// ```
/// @ViewBuilder
/// func makeHelperView() -> some View {
///     if foo {
///         Text("Hello, world!")
///     } else {
///         Color.red
///     }
/// }
/// ```
///
/// The latter example performs better as the SwiftUI runtime is given a more explicit type hierarchy, where the switch between `foo` being true or false can only result in a `Text` or a `Color`. The former example erases that information, forcing the SwiftUI runtime to evaluate the actual view type lazily, and thus requires more work to compute and render.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct AnyView : View {

    /// Create an instance that type-erases `view`.
    public init<V>(_ view: V) where V : View { }

    /// Creates an instance that type-erases the parameter.
    public init<V>(erasing view: V) where V : View { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A type that represents the structure and behavior of an app.
///
/// Create an app by declaring a structure that conforms to the `App` protocol.
/// Implement the required `SwiftUI/App/body-swift.property` computed property
/// to define the app's content:
///
///     @main
///     struct MyApp: App {
///         var body: some Scene {
///             WindowGroup {
///                 Text("Hello, world!")
///             }
///         }
///     }
///
/// Precede the structure's declaration with the
/// [@main](https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626)
/// attribute to indicate that your custom `App` protocol conformer provides the
/// entry point into your app. The protocol provides a default implementation of
/// the `SwiftUI/App/main()` method that the system calls to launch your app.
/// You can have exactly one entry point among all of your app's files.
///
/// Compose the app's body from instances that conform to the `SwiftUI/Scene`
/// protocol. Each scene contains the root view of a view hierarchy and has a
/// life cycle managed by the system. SwiftUI provides some concrete scene types
/// to handle common scenarios, like for displaying documents or settings. You
/// can also create custom scenes.
///
///     @main
///     struct Mail: App {
///         var body: some Scene {
///             WindowGroup {
///                 MailViewer()
///             }
///             Settings {
///                 SettingsView()
///             }
///         }
///     }
///
/// You can declare state in your app to share across all of its scenes. For
/// example, you can use the `SwiftUI/StateObject` attribute to initialize a
/// data model, and then provide that model on a view input as an
/// `SwiftUI/ObservedObject` or through the environment as an
/// `SwiftUI/EnvironmentObject` to scenes in the app:
///
///     @main
///     struct Mail: App {
///         @StateObject private var model = MailModel()
///
///         var body: some Scene {
///             WindowGroup {
///                 MailViewer()
///                     .environmentObject(model) // Passed through the environment.
///             }
///             Settings {
///                 SettingsView(model: model) // Passed as an observed object.
///             }
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol App { }
extension App {

    /// The type of scene representing the content of the app.
    ///
    /// When you create a custom app, Swift infers this type from your
    /// implementation of the required `SwiftUI/App/body-swift.property`
    /// property.
    associatedtype Body : Scene

    /// The content and behavior of the app.
    ///
    /// For any app that you create, provide a computed `body` property that
    /// defines your app's scenes, which are instances that conform to the
    /// `SwiftUI/Scene` protocol. For example, you can create a simple app
    /// with a single scene containing a single view:
    ///
    ///     @main
    ///     struct MyApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 Text("Hello, world!")
    ///             }
    ///         }
    ///     }
    ///
    /// Swift infers the app's `SwiftUI/App/Body-swift.associatedtype`
    /// associated type based on the scene provided by the `body` property.
    @SceneBuilder var body: Self.Body { get }

    /// Creates an instance of the app using the body that you define for its
    /// content.
    ///
    /// Swift synthesizes a default initializer for structures that don't
    /// provide one. You typically rely on the default initializer for
    /// your app.
    init() { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension App {

    /// Initializes and runs the app.
    ///
    /// If you precede your `SwiftUI/App` conformer's declaration with the
    /// [@main](https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626)
    /// attribute, the system calls the conformer's `main()` method to launch
    /// the app. SwiftUI provides a
    /// default implementation of the method that manages the launch process in
    /// a platform-appropriate way.
    public static func main() { }
}

/// A property wrapper type that reads from and writes to the device's storage.
///
/// Use this property wrapper to read to and write from permanent storage
/// on the user's device, also known as "UserDefaults".
///
/// Check out ``Scene/defaultAppStorage()`` for ``Scene``s and
/// ``View/defaultAppStorage()`` for ``View``s to learn more about
/// setting the default app storage location for a view.
///
///
/// Below shows a simple example using a `String`.
///
///     struct ContentView: View {
/// 		@AppStorage("name") var name: String = "Javier"
///
/// 		var body: some View {
/// 			TextField(name, text: $name)
/// 		}
/// 	}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen @propertyWrapper public struct AppStorage<Value> : DynamicProperty {

	/// The user default value for the given key.
	///
	/// This is rarely used directly. Instead, you normally use the property wrapper syntax:
	///
	///     struct ContentView: View {
    /// 		@AppStorage("name") var name: String = "Javier"
    ///
    /// 		var body: some View {
    /// 			TextField(name, text: $name)
    /// 		}
    /// 	}
    public var wrappedValue: Value { get nonmutating set }

    /// Provides a binding for the wrapped value.
    ///
    /// You can access this using the $ prefix:
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("name") var name: String = "Javier"
    ///
    /// 		var body: some View {
    /// 			TextField(name, text: $name)
    /// 		}
    /// 	}
    public var projectedValue: Binding<Value> { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AppStorage {

    /// Creates a property that can read and write to a boolean user default.
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("airplane-mode") var on: Bool = false
    ///
    /// 		var body: some View {
    /// 			Toggle("Airplane Mode", isOn: $on)
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a boolean value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Bool { }

    /// Creates a property that can read and write to an integer user default.
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("donuts") var count: Int = 0
    ///
    /// 		var body: some View {
    /// 			Stepper("🍩 count: \(count)", value: $count)
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if an integer value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Int { }

    /// Creates a property that can read and write to a double user default.
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("brightness") var level: Double = 0
    ///
    /// 		var body: some View {
    /// 			Text("🔆 \(level)")
    ///             Slider(value: $level)
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a double value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Double { }

    /// Creates a property that can read and write to a string user default.
    ///
    ///     struct ContentView: View {
    /// 		@AppStorage("name") var name: String = "Javier"
    ///
    /// 		var body: some View {
    /// 			TextField(name, text: $name)
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a string value is not specified
    ///     for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == String { }

    /// Creates a property that can read and write to a url user default.
    ///
    ///     struct ContentView: View {
    /// 		@AppStorage("site") var url = URL(string: "bananadocs.org")!
    ///
    /// 		var body: some View {
    /// 			Text("Check out \(url)")
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a url value is not specified for
    ///     the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == URL { }

    /// Creates a property that can read and write to a user default as data.
    ///
    /// Avoid storing large data blobs in user defaults, such as image data,
    /// as it can negatively affect performance of your app. On tvOS, a
    /// `NSUserDefaultsSizeLimitExceededNotification` notification is posted
    /// if the total user default size reaches 512kB.
    ///
    ///     struct Human: Codable {
    ///         var name: String
    ///         var age: Int
    ///     }
    ///
    //      struct ContentView: View {
    ///         @AppStorage("goat") var person = Data()
    ///
    ///         var body: some View {
    ///             Button("Make Aaron the 🐐") {
    ///                 let aaron = Human(name: "Aaron", age: 21)
    ///                 let aaronData = try! JSONEncoder().encode(aaron)
    ///
    ///                 person = aaronData
    ///                 print("success.")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a data value is not specified for
    ///    the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value == Data { }

    /// Creates a property that can read and write to an integer user default,
    /// transforming that to `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///    enum MyEnum: Int {
    ///        case a
    ///        case b
    ///        case c
    ///    }
    ///    struct MyView: View {
    ///        @AppStorage("MyEnumValue") private var value = MyEnum.a
    ///
    ///        var body: some View {
    ///             Picker("Choose!", selection: $value) {
    ///                 Text("a").tag(MyEnum.a)
    ///                 Text("b").tag(MyEnum.b)
    ///                 Text("c").tag(MyEnum.c)
    ///             }
    ///         }
    ///    }
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if an integer value
    ///     is not specified for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value : RawRepresentable, Value.RawValue == Int { }

    /// Creates a property that can read and write to a string user default,
    /// transforming that to `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///    enum MyEnum: String {
    ///        case a
    ///        case b
    ///        case c
    ///    }
    ///    struct MyView: View {
    ///        @AppStorage("MyEnumValue") private var value = MyEnum.a
    ///        var body: some View {
    ///             Picker("Choose!", selection: $value) {
    ///                 Text("a").tag(MyEnum.a)
    ///                 Text("b").tag(MyEnum.b)
    ///                 Text("c").tag(MyEnum.c)
    ///             }
    ///         }
    ///    }
    ///
    /// - Parameters:
    ///   - wrappedValue: The default value if a string value
    ///     is not specified for the given key.
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(wrappedValue: Value, _ key: String, store: UserDefaults? = nil) where Value : RawRepresentable, Value.RawValue == String { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension AppStorage where Value : ExpressibleByNilLiteral {

    /// Creates a property that can read and write an Optional boolean user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("airplane-mode") var on: Bool?
    ///
    /// 		var body: some View {
    /// 			Button("on") { on = true }
    ///             Button("off") { on = false }
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Bool? { }

    /// Creates a property that can read and write an Optional integer user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("donuts") var count: Int?
    ///
    /// 		var body: some View {
    /// 			Button("none ☹️") { count = 0 }
    ///             Button("LOTS 🍩") { count = 100 }
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Int? { }

    /// Creates a property that can read and write an Optional double user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("brightness") var level: Double?
    ///
    /// 		var body: some View {
    /// 			Button("MAX 🔆") { level = 1.0 }
    ///             Button("min 🔅") { level = 0.0 }
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Double? { }

    /// Creates a property that can read and write an Optional string user
    /// default.
    ///
    ///     struct ContentView: View {
    /// 		@AppStorage("name") var name: String?
    ///
    /// 		var body: some View {
    /// 			Button("Save 🐐") { name = "Javier" }
    /// 		}
    /// 	}
    ///
    /// Defaults to nil if there is no restored value.
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == String? { }

    /// Creates a property that can read and write an Optional URL user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    ///     struct ContentView: View {
    /// 		@AppStorage("site") var url: URL?
    ///
    /// 		var body: some View {
    /// 			Text("Save the 🍌") { url = URL(string: "bananadocs.org" }
    /// 		}
    /// 	}
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == URL? { }

    /// Creates a property that can read and write an Optional data user
    /// default.
    ///
    /// Defaults to nil if there is no restored value.
    ///
    ///     struct Human: Codable {
    ///         var name: String
    ///         var age: Int
    ///     }
    ///
    //      struct ContentView: View {
    ///         @AppStorage("goat") var person: Data?
    ///
    ///         var body: some View {
    ///             Button("Make Aaron the 🐐") {
    ///                 let aaron = Human(name: "Aaron", age: 21)
    ///                 let aaronData = try! JSONEncoder().encode(aaron)
    ///
    ///                 person = aaronData
    ///                 print("success.")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - key: The key to read and write the value to in the user defaults
    ///     store.
    ///   - store: The user defaults store to read and write to. A value
    ///     of `nil` will use the user default store from the environment.
    public init(_ key: String, store: UserDefaults? = nil) where Value == Data? { }
}

/// The horizontal or vertical dimension in a 2D coordinate system.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public enum Axis : Int8, CaseIterable {

    /// The horizontal dimension.
    case horizontal

    /// The vertical dimension.
    case vertical

    /// An efficient set of axes.
    @frozen public struct Set : OptionSet {

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        public typealias Element = Axis.Set

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int8

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: Int8) { }

        /// The option set corresponding to the horizontal axis.
        public static let horizontal: Axis.Set

        /// The option set corresponding to the vertical axis.
        public static let vertical: Axis.Set

        /// The type of the elements of an array literal.
        public typealias ArrayLiteralElement = Axis.Set.Element

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = Int8
    }

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int8

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: Int8 { get }

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: Int8) { }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [Axis]

    /// A collection of all values of this type.
    public static var allCases: [Axis] { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Axis : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Axis : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Axis : Hashable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Axis : RawRepresentable {
}

/// A style that looks solid white in light mode and solid black in dark mode.
///
/// Use this ``ShapeStyle`` to intelligently stroke and fill shapes based
/// on what color will look good against the current background.
///
/// In light mode, this will fill as solid white. In dark mode, it will fill
/// as solid black.
///
/// In the following example, the top circle is always invisible, since
/// it is filled the same color as the background.
///
/// ```
/// struct CircleOnButtomView: View {
///     var body: some View {
///         Circle()
///             .fill(BackgroundStyle())
///         Circle()
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public struct BackgroundStyle {

	/// Creates a new background style.
    ///
    /// Use this to fill or stroke a shape. It will appear as solid white
    /// in light mode and solid black in dark mode.
    ///
    /// In the following example, the top circle is always invisible, since
    /// it is filled the same color as the background.
    ///
    /// ```
    /// struct CircleOnButtomView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .fill(BackgroundStyle())
    ///         Circle()
    ///     }
    /// }
    /// ```
    @inlinable public init() { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension BackgroundStyle : ShapeStyle {
}

/// This type handles shared values across views.
///
/// `Binding` is a property wrapper that creates a connection between stored data, and a view that displays and changes that data. It is a **two-way connection** to a source of truth. It is used to both read the latest value, as well as to set a new value. `Binding` defines a **getter** and a **setter** for a value.
///
/// ### Structure of a `Binding`
///
/// A `Binding` is essentially the following structure:
///
/// ```
/// struct Binding<Value> {
///     let get: () -> Value
///     let set: (Value) -> ()
/// }
/// ```
///
/// ### Creating a `Binding` from `@State `
///
/// A `Binding` typically represents a reference to a mutable source of truth - such as `@State`, `@ObservedObject` or a reference-writable keypath of an object. To create a `Binding` from a mutable source of truth, prefix the variable name for the source of truth with a dollar sign (`$`).
///
/// For example, a `TextField` can be bound to a state variable:
///
/// ![Binding Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Binding-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var text: String = "🍌🍌"
///
///     var body: some View {
///         Text(text)
///         TextField("Placeholder", text: $text)
///     }
/// }
/// ```
///
/// In the example above, the source of truth is a `@State` variable, named `text`. `text`  represents a `String`, whereas `$text` represents a `Binding<String>`. `TextField`'s initializer accepts a placeholder `String` and a `Binding<String>`. In this example, `TextField` requires a `Binding` to the source of truth as `TextField` must be able to *write back* to the `@State` variable (a **mutable** source of truth).
///
/// Recall, a `Binding` is a **two-way connection** to a source of truth. It is used to both read the latest value, as well as to set a new value. In the previous example, the view's initial render will display an editable text of "🍌🍌" on the screen - `TextField` reads the current value of the source of truth `text` via the  `Binding` `$text`. When the user starts editing, `TextField` *writes back* new values to the source of truth `text` via the `Binding`  `$text` once again.
///
/// ### Creating a `Binding` from an `ObservableObject`
///
/// In this example, the source of truth is an observable object `ExampleModel` - stored in a `@StateObject` owned by `ExampleView`:
///
/// ![Binding Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Binding-example-2.gif)
///
/// ```
/// struct ExampleView: View {
///     @StateObject var viewModel = ExampleModel()
///
///     var text: String {
///         viewModel.isEnabled ? "Enabled" : "Disabled"
///     }
///
///     var body: some View {
///         Toggle(text, isOn: $viewModel.isEnabled)
///     }
/// }
///
/// class ExampleModel: ObservableObject {
///     @Published var isEnabled: Bool = false
/// }
/// ```
///
/// The binding between the model's `isEnabled` variable and a toggle is established using `$viewModel.isEnabled` within `ExampleView`'s body. Note that the dollar sign must prefix the **root** variable, even in the case where a child member is being referenced. `$viewModel.isEnabled` and `viewModel.$isEnabled` are **not** equivalent. The former creates a `Binding` to `isEnabled`, whereas the latter unwraps the projected value of the `@Published` property wrapper wrapping `isEnabled`.
///
/// ### Animating Updates via a `Binding`
///
/// Since a `Binding` is capable of updating a view's state, the state update can be made to animate with `Binding/animation(_:)`. Usage looks as follows:
///
/// ```
/// $myVariable.animation(.default)
/// ```
///
/// ### Creating a `Binding` from a constant
///
/// At times, you may want to pass a fixed value as a `Binding`. This is possible via `Binding/constant(_:)`, which creates a `Binding` to a fixed value, ignoring any updates from the consumer of the binding.
///
/// Consider `EnvironmentValues/editMode`, for example. A `List` can be forced into active editing by passing a binding to `EditMode.active`.
///
/// ![Binding Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Binding-example-3.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits = ["🍌", "🍏", "🍑"]
///
///     var body: some View {
///         List {
///             ForEach(fruits, id: \.self) { fruit in
///                 Text(fruit)
///             }
///             .onDelete { offets in
///                 fruits.remove(atOffsets: offets)
///             }
///         }
///         .environment(\.editMode, .constant(.active))
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen @propertyWrapper @dynamicMemberLookup public struct Binding<Value> {

    /// The binding's transaction.
    ///
    /// The transaction captures the information needed to update the view when
    /// the binding value changes.
    public var transaction: Transaction

    /// Creates a binding with closures that read and write the binding value.
    ///
    /// - Parameters:
    ///   - get: A closure that retrieves the binding value. The closure has no
    ///     parameters, and returns a value.
    ///   - set: A closure that sets the binding value. The closure has the
    ///     following parameter:
    ///       - newValue: The new value of the binding value.
    public init(get: @escaping () -> Value, set: @escaping (Value) -> Void) { }

    /// Creates a binding with a closure that reads from the binding value, and
    /// a closure that applies a transaction when writing to the binding value.
    ///
    /// - Parameters:
    ///   - get: A closure to retrieve the binding value. The closure has no
    ///     parameters, and returns a value.
    ///   - set: A closure to set the binding value. The closure has the
    ///     following parameters:
    ///       - newValue: The new value of the binding value.
    ///       - transaction: The transaction to apply when setting a new value.
    public init(get: @escaping () -> Value, set: @escaping (Value, Transaction) -> Void) { }

    /// Creates a binding with an immutable value.
    ///
    /// Use this method to create a binding to a value that cannot change.
    /// This can be useful when using a `PreviewProvider` to see how a view
    /// represents different values.
    ///
    ///     // Example of binding to an immutable value.
    ///     PlayButton(isPlaying: Binding.constant(true))
    ///
    /// Another use case is for prototyping. For example:
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         Toggle("Banana On", isOn: .constant(true))
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter value: An immutable value.
    public static func constant(_ value: Value) -> Binding<Value> { }

    /// The underlying value referenced by the binding variable.
    ///
    /// This property provides primary access to the value's data. However, you
    /// don't access `wrappedValue` directly. Instead, you use the property
    /// variable created with the `@Binding` attribute. For instance, in the
    /// following code example the binding variable `isPlaying` returns the
    /// value of `wrappedValue`:
    ///
    ///     struct PlayButton: View {
    ///         @Binding var isPlaying: Bool
    ///
    ///         var body: some View {
    ///             Button(action: {
    ///                 self.isPlaying.toggle()
    ///             }) {
    ///                 Image(systemName: isPlaying ? "pause.circle" : "play.circle")
    ///             }
    ///         }
    ///     }
    ///
    /// When a mutable binding value changes, the new value is immediately
    /// available. However, updates to a view displaying the value happens
    /// asynchronously, so the view may not show the change immediately.
    public var wrappedValue: Value { get nonmutating set }

    /// A projection of the binding value that returns a binding.
    ///
    /// Use the projected value to pass a binding value down a view hierarchy.
    /// To get the `projectedValue`, prefix the property variable with `$`. For
    /// example, in the following code example `PlayerView` projects a binding
    /// of the state property `isPlaying` to the `PlayButton` view using
    /// `$isPlaying`.
    ///
    ///     struct PlayerView: View {
    ///         var episode: Episode
    ///         @State private var isPlaying: Bool = false
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Text(episode.title)
    ///                 Text(episode.showTitle)
    ///                 PlayButton(isPlaying: $isPlaying)
    ///             }
    ///         }
    ///     }
    public var projectedValue: Binding<Value> { get }

    /// Returns a binding to the resulting value of a given key path.
    ///
    /// - Parameter keyPath: A key path to a specific resulting value.
    ///
    /// - Returns: A new binding.
    public subscript<Subject>(dynamicMember keyPath: WritableKeyPath<Value, Subject>) -> Binding<Subject> { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Binding {

    /// Creates a binding by projecting the base value to an optional value.
    ///
    /// - Parameter base: A value to project to an optional value.
    public init<V>(_ base: Binding<V>) where Value == V? { }

    /// Creates a binding by projecting the base value to an unwrapped value.
    ///
    /// - Parameter base: A value to project to an unwrapped value.
    ///
    /// - Returns: A new binding or `nil` when `base` is `nil`.
    public init?(_ base: Binding<Value?>) { }

    /// Creates a binding by projecting the base value to a hashable value.
    ///
    /// - Parameters:
    ///   - base: A `Hashable` value to project to an `AnyHashable` value.
    public init<V>(_ base: Binding<V>) where Value == AnyHashable, V : Hashable { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Binding {

    /// Specifies a transaction for the binding.
    ///
    /// - Parameter transaction  : An instance of a `Transaction`.
    ///
    /// - Returns: A new binding.
    public func transaction(_ transaction: Transaction) -> Binding<Value> { }

    /// Specifies an animation to perform when the binding value changes.
    ///
    /// - Parameter animation: An animation sequence performed when the binding
    ///   value changes.
    ///
    /// - Returns: A new binding.
    public func animation(_ animation: Animation? = .default) -> Binding<Value> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Binding : DynamicProperty {
}

/// Modes for compositing a view with overlapping content.
///
/// There are 21 different types of blend modes. To use the following example, drag in the following two photos and label them "ocean" and "space".
///
/// ![Ocean](ocean.jpg)
///
/// ![Space](space.jpg)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ZStack {
///             Image("ocean")
///                 .resizable()
///                 .scaledToFit()
///
///             Image("space")
///                 .resizable()
///                 .scaledToFit()
///                 .blendMode(.softLight)
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum BlendMode {

	/// Regular overlapping, with opacity taken into account.
  ///
  /// ![Blend Mode](blendmode-normal.png)
  ///
  /// ```
  /// struct ExampleView: View {
  ///     var body: some View {
  ///         ZStack {
  ///             Image("ocean")
  ///                 .resizable()
  ///                 .scaledToFit()
  ///
  ///             Image("space")
  ///                 .resizable()
  ///                 .scaledToFit()
  ///                 .blendMode(.normal)
  ///         }
  ///     }
  /// }
  /// ```
    case normal

    /// Multiplies the RGB channel numbers (0.0 - 1.0) of each pixel.
    ///
    /// The result is always a darker picture.
    /// ![Blend Mode](blendmode-multiply.png)
    ///
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.multiply)
    ///         }
    ///     }
    /// }
    /// ```
    case multiply

    /// Each RGB pixel value is inverted (subtracted from 1), multiplied together,
    /// and then inverted back.
    ///
    /// The result is the opposite effect of multiply, and always a lighter
    /// picture. The results are also symmetric, so changing which layer is on
    /// top does not change the final picture.
    ///
    /// The formula for screen is this:
    ///
    ///     func screen(a: Double, b: Double) {{}
    ///         return 1 - (1 - a) * (1 - b)
    ///     }
    ///
    /// ![Blend Mode](blendmode-screen.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.screen)
    ///         }
    ///     }
    /// }
    /// ```
    case screen

    /// The parts were the bottom layer is light become lighter, and dark becomes darker.
    ///
    /// Overlay is a combo of multiply and screen. The formula is this:
    ///
    ///     func overlay(a: Double, b: Double) -> Double {{}
    ///     	if a > 0.5 {
    ///     		return 2 * a * b
    ///     	} else {
    ///     		return 1 - 2 * (1 - a) * (1 - b)
    ///     	}
    ///     }
    ///
    /// ![Blend Mode](blendmode-overlay.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.overlay)
    ///         }
    ///     }
    /// }
    /// ```
    case overlay

    /// Takes the darker of the top and bottom picture pixels.
    ///
    /// ![Blend Mode](blendmode-darken.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.overlay)
    ///         }
    ///     }
    /// }
    /// ```
    case darken

    /// Takes the lighter of the top and bottom picture pixels.
    case lighten

    /// Divides the bottom layer by the inversion of the top layer.
    ///
    /// Color dodge is inspired by dodging in a darkroom. The bottom layer is
    /// lightened by an amount determined by the top layer - a brighter top
    /// layer results in a more brightened bottom layer.
    ///
    /// Blending any pixel with white will result in a white pixel. Blending any
    /// color with black will result in an unchanged pixel.
    ///
    /// This operation is not invertible.
    ///
    /// ![Blend Mode](blendmode-colorDodge.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.colorDodge)
    ///         }
    ///     }
    /// }
    /// ```
    case colorDodge

    /// Divides the inverted bottom layer by the top layer, then inverts the result.
    ///
    /// The top layer is darkened by an amount determined by the bottom layer.
    ///
    /// Blending any pixel by white results in no change.
    ///
    /// This operation is not invertible.
    ///
    /// ![Blend Mode](blendmode-colorBurn.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.colorBurn)
    ///         }
    ///     }
    /// }
    /// ```
    case colorBurn

    /// Basically, every light color gets a little lighter, and every dark color gets darker.
    ///
    /// The actual formula for the operation is this:
    ///
    ///     func softLight(a: Double, b: Double) -> Double {{}
    ///         if b < 0.5 {
    ///             return 2*a*b + a*a*(1 - 2*b)
    ///         } else {
    ///         	return 2*a*(1 - b) + sqrt(a)*(2*b - 1)
    ///         }
    ///     }
    ///
    /// ![Blend Mode](blendmode-overlay.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.softLight)
    ///         }
    ///     }
    /// }
    /// ```
    case softLight

    /// A combination of multiply and screen are applied.
    ///
    /// Hard light affects the bottom layer the way that overlay affects the top
    /// layer, and vice-versa.
    ///
    /// ![Blend Mode](blendmode-hardLight.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.hardLight)
    ///         }
    ///     }
    /// }
    /// ```
    case hardLight

    /// Subtracts the bottom layer from the top layer, and then makes the result positive.
    ///
    /// If either layer is black, nothing changes. Blending with white inverts
    /// the picture.
    ///
    /// ![Blend Mode](blendmode-difference.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.difference)
    ///         }
    ///     }
    /// }
    /// ```
    case difference

    /// Subtracts the bottom layer from the top layer, and then makes the result positive.
    ///
    /// The difference between difference and exclusion is that blending with
    /// 50% gray will produce 50% gray.
    ///
    /// ![Blend Mode](blendmode-exclusion.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.exclusion)
    ///         }
    ///     }
    /// }
    /// ```
    case exclusion

    /// Keeps the brightness and saturation of the bottom layer, while taking the hue of the top layer.
    ///
    /// ![Blend Mode](blendmode-hu.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.hu)
    ///         }
    ///     }
    /// }
    /// ```
    case hue

    /// Keeps the brightness and hue of the bottom layer, while taking the saturation of the top layer.
    ///
    /// ![Blend Mode](blendmode-saturation.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.saturation)
    ///         }
    ///     }
    /// }
    /// ```
    case saturation

    /// Keeps the brightness of the bottom layer, while taking the hue and saturation of the top layer.
    ///
    /// ![Blend Mode](blendmode-color.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.color)
    ///         }
    ///     }
    /// }
    /// ```
    case color

    /// Keeps the hue and saturation of the bottom layer, while taking the brightness of the top layer.
    ///
    /// ![Blend Mode](blendmode-luminosity.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.luminosity)
    ///         }
    ///     }
    /// }
    /// ```
    case luminosity

    /// Shows the bottom layer fully, with the top layer drawn only where it
    /// intersect the bottom.
    ///
    /// ![Blend Mode](blendmode-sourceAtop.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.sourceAtop)
    ///         }
    ///     }
    /// }
    /// ```
    case sourceAtop

    /// The bottom is drawn over the top, and the top is only visible where the
    /// bottom is transparent.
    ///
    /// ![Blend Mode](blendmode-destinationOver.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.destinationOver)
    ///         }
    ///     }
    /// }
    /// ```
    case destinationOver

    /// Displays only the bottom layer, and only where the top is transparent.
    ///
    /// ![Blend Mode](blendmode-destinationOut.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.destinationOut)
    ///         }
    ///     }
    /// }
    /// ```
    case destinationOut

    /// Adds the top layer pixels to the bottom layer.
    ///
    /// Displays white where the addition is greater than 1.0.
    ///
    /// ![Blend Mode](blendmode-plusDarker.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.plusDarker)
    ///         }
    ///     }
    /// }
    /// ```
    case plusDarker

    /// Adds the top layer pixels to the bottom layer, than subtracts the result from 1.
    ///
    /// Displays black where the result is less than 0.0.
    ///
    /// ![Blend Mode](blendmode-plusLighter.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.plusLighter)
    ///         }
    ///     }
    /// }
    /// ```
    case plusLighter

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: BlendMode, b: BlendMode) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension BlendMode : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension BlendMode : Hashable {
}

/// A menu style that displays a borderless button that toggles the display of
/// the menu's contents when pressed.
///
/// On macOS, the button optionally displays an arrow indicating that it presents
/// a menu.
///
/// Pressing and then dragging into the contents triggers the chosen action on
/// release.
///
/// For example,
///
/// ![DefaultMenu Example 1](default-menu-example.gif)
///
/// ```
/// struct BorderlessButtonMenuView: View {
///     var body: some View {
///         Menu("PDF") {
///             Button("Open in Preview", action: { })
///             Button("Save as PDF", action: { })
///         }
///         .menuStyle(BorderlessButtonMenuStyle())
///     }
/// }
/// ```
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct BorderlessButtonMenuStyle : MenuStyle {

    /// Creates a borderless button menu style.
    ///
    /// By default, the borderless style displays a visual indicator that it
    /// represents a menu.
    ///
    /// For example,
    ///
    /// ![DefaultMenu Example 1](default-menu-example.gif)
    ///
    /// ```
    /// struct BorderlessButtonMenuView: View {
    ///     var body: some View {
    ///         Menu("PDF") {
    ///             Button("Open in Preview", action: { })
    ///             Button("Save as PDF", action: { })
    ///         }
    ///         .menuStyle(BorderlessButtonMenuStyle())
    ///     }
    /// }
    /// ```
    public init() { }

    /// Creates a view that represents the body of a menu.
    ///
    /// - Parameter configuration: The properties of the menu.
    ///
    /// The system calls this method for each `Menu` instance in a view
    /// hierarchy where this style is the current menu style.
    public func makeBody(configuration: BorderlessButtonMenuStyle.Configuration) -> some View { }


    /// A view that represents the body of a menu.
    public typealias Body = some View
}

/// A button style that doesn't apply a border.
///
/// ![DefaultButtonStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/buttonstyle-plain-border-default-example-1.png)
///
///
///     struct ExampleView: View {
///         var body: some View {
///              VStack {
///                  Button("Plain Banana🍌🍌") { tap() }
///                      .buttonStyle(PlainButtonStyle())
///
///                  Button("Borderless Banana🍌🍌") { tap() }
///                      .buttonStyle(BorderlessButtonStyle())
///
///                  Button("Default Banana🍌🍌") { tap() }
///                      .buttonStyle(DefaultButtonStyle())
///              }
///              .font(.title2)
///          }
///
///          func tap() {}
///      }
///
///
/// To apply this style to a button, or to a view that contains buttons, use the
/// `View/buttonStyle(_:)-66fbx` modifier.
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct BorderlessButtonStyle : PrimitiveButtonStyle {

    /// Creates a borderless button style.
    public init() { }

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each `Button` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    public func makeBody(configuration: BorderlessButtonStyle.Configuration) -> some View { }


    /// A view that represents the body of a button.
    public typealias Body = some View
}

/// A control that performs an action when triggered.
///
/// You create a button by providing an action and a label. The action is either
/// a method or closure property that does something when a user clicks or taps
/// the button. The label is a view that describes the button's action, for
/// example, by showing text such as Cancel or an icon such as a back arrow.
///
///     Button(action: signIn) {
///         Text("Sign In")
///     }
///
/// For the common case of text-only labels, you can use the convenience
/// initializer that takes a title string (or localized string key) as its first
/// parameter, instead of a trailing closure:
///
///     Button("Sign In", action: signIn)
///
/// The method of triggering the button varies by platform:
/// - In iOS and watchOS, the user triggers a standard button by tapping on it.
/// - In macOS, the user triggers a standard button by clicking on it.
/// - In tvOS, the user triggers a standard button by pressing "select" on an
///   external remote, like the Siri Remote, while focusing on the button.
///
/// ### Adding Buttons to Containers
///
/// Use buttons for any user interface element that triggers actions on press.
/// Buttons automatically adapt their visual style to match the expected style
/// within these different containers and contexts. For example, to create a
/// list cell that triggers an action when selected by the user, add a button to
/// the list's content. For example:
///
///     // A list of items, where the last row, when triggered,
///     // opens a UI for adding a new item.
///     List {
///         ForEach(items) { item in
///             Text(item.title)
///         }
///         Button("Add Item", action: addItem)
///     }
///
/// Similarly, to create a context menu item that triggers an action, add a
/// button to the menu's content:
///
///     .contextMenu {
///         Button("Cut", action: cut)
///         Button("Copy", action: copy)
///         Button("Paste", action: paste)
///     }
///
/// This pattern extends to most other container views in SwiftUI that have
/// customizable, interactive content, like forms (instances of `Form`).
///
/// ### Styling Buttons
///
/// You can customize a button's appearance and interaction behavior. To add a
/// custom appearance with standard interaction behavior, create a style that
/// conforms to the `ButtonStyle` protocol. To customize both appearance and
/// interaction behavior, create a style that conforms to the
/// `PrimitiveButtonStyle` protocol. To set a specific style for all button
/// instances within a view, use the `View/buttonStyle(_:)-66fbx` modifier:
///
///     HStack {
///         Button("Sign In", action: signIn)
///         Button("Register", action: register)
///     }
///     .buttonStyle(BorderedButtonStyle())
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Button<Label> : View where Label : View {

    /// Creates a button that displays a custom label.
    ///
    /// - Parameters:
    ///   - action: The action to perform when the user triggers the button.
    ///   - label: A view that describes the purpose of the button's `action`.
    public init(action: @escaping () -> Void, @ViewBuilder label: () -> Label) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Button where Label == Text {

    /// Creates a button that generates its label from a localized string key.
    ///
    /// This initializer creates a `Text` view on your behalf, and treats the
    /// localized key similar to `Text/init(_:tableName:bundle:comment:)`. See
    /// `Text` for more information about localizing strings.
    ///
    /// To initialize a button with a string variable, use
    /// `Button/init(_:action:)-lpm7` instead.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the button's localized title, that describes
    ///     the purpose of the button's `action`.
    ///   - action: The action to perform when the user triggers the button.
    public init(_ titleKey: LocalizedStringKey, action: @escaping () -> Void) { }

    /// Creates a button that generates its label from a string.
    ///
    /// This initializer creates a `Text` view on your behalf, and treats the
    /// title similar to `Text/init(_:)-9d1g4`. See `Text` for more
    /// information about localizing strings.
    ///
    /// To initialize a button with a localized string key, use
    /// `Button/init(_:action:)-1asy` instead.
    ///
    /// - Parameters:
    ///   - title: A string that describes the purpose of the button's `action`.
    ///   - action: The action to perform when the user triggers the button.
    public init<S>(_ title: S, action: @escaping () -> Void) where S : StringProtocol { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Button where Label == PrimitiveButtonStyleConfiguration.Label {

    /// Creates a button based on a configuration for a style with a custom
    /// appearance and custom interaction behavior.
    ///
    /// Use this initializer within the
    /// `PrimitiveButtonStyle/makeBody(configuration:)` method of a
    /// `PrimitiveButtonStyle` to create an instance of the button that you
    /// want to style. This is useful for custom button styles that modify the
    /// current button style, rather than implementing a brand new style.
    ///
    /// For example, the following style adds a red border around the button,
    /// but otherwise preserves the button's current style:
    ///
    ///     struct RedBorderedButtonStyle : PrimitiveButtonStyle {
    ///         func makeBody(configuration: Configuration) -> some View {{}
    ///             Button(configuration)
    ///                 .border(Color.red)
    ///         }
    ///     }
    ///
    /// - Parameter configuration: A configuration for a style with a custom
    ///   appearance and custom interaction behavior.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    public init(_ configuration: PrimitiveButtonStyleConfiguration) { }
}


/// This protocol is used to create a custom button style.
///
/// The `ButtonStyle` protocol provides a template to create a reusable style for your buttons. It also provides data about the button and its interaction state.
///
/// To make a custom style, create a new structure that conforms to `ButtonStyle`. This new style can be easily reused across your application. The style adapts to the user's current interaction state (i.e. on press, on release).
///
/// Your structure only needs to implement one method: `ButtonStyle/makeBody(configuration:)`.
///
/// To change the style of your `Button`, use the `View/buttonStyle(_:)` method. This method accepts a `ButtonStyle`.
///
///  ![ButtonStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ButtonStyle-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Button("Banana🍌🍌", action: { tap() })
///             .buttonStyle(BananaButtonStyle(color: .yellow))
///     }
///
///     func tap() { }
/// }
///
/// struct BananaButtonStyle: ButtonStyle {
///     var color: Color
///     func makeBody(configuration: Self.Configuration) -> some View {
///         BananaButton(configuration: configuration, color: color)
///     }
///
///     struct BananaButton: View {
///         let configuration: BananaButtonStyle.Configuration
///         let color: Color
///
///         var body: some View {
///             configuration.label
///                 .padding()
///                 .background(RoundedRectangle(cornerRadius: 10).fill(color))
///                 .scaleEffect(configuration.isPressed ? 0.8: 1)
///                 .animation(.spring())
///         }
///     }
/// }
/// ```
///
/// Button style applies to all buttons within a view hierarchy. For example, you could apply `ButtonStyle` to a `VStack`.
///
///  ![ButtonStyle Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ButtonStyle-example-2.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         VStack {
///             Button("🍌🍌", action: { tap() })
///             Button("🍎🍎", action: { tap() })
///             Button("🍑🍑", action: { tap() })
///         }
///         .buttonStyle(BananaButtonStyle(color: .yellow))
///     }
///
///     func tap() {}
/// }
///
/// struct BananaButtonStyle: ButtonStyle {
///     var color: Color
///     func makeBody(configuration: Self.Configuration) -> some View {
///         BananaButton(configuration: configuration, color: color)
///     }
///
///     struct BananaButton: View {
///         let configuration: BananaButtonStyle.Configuration
///         let color: Color
///
///         var body: some View {
///             return configuration.label
///                 .padding()
///                 .background(RoundedRectangle(cornerRadius: 10).fill(color))
///                 .scaleEffect(configuration.isPressed ? 0.8: 1)
///                 .animation(.spring())
///         }
///     }
/// }
/// ```
///
/// For more on how to customize your button style body, check out `ButtonStyle/makeBody(configuration:)`. To provide greater control over when and how a button triggers it's action use `PrimitiveButtonStyle`. While this property requires more work to setup, it provides more customization.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol ButtonStyle{ }
extension ButtonStyle {

    /// A view that represents the body of a button.
    associatedtype Body : View

    /// Creates a view that represents the body of a button.
    ///
    /// This is the only required property of `ButtonStyle`. See ``ButtonStyle`` for more.
    ///
    /// The system calls this method for each `Button` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    ///  ![ButtonStyle Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ButtonStyle-example-2.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Button("🍌🍌", action: { tap() })
    ///             Button("🍎🍎", action: { tap() })
    ///             Button("🍑🍑", action: { tap() })
    ///         }
    ///         .buttonStyle(BananaButtonStyle(color: .yellow))
    ///     }
    ///
    ///     func tap() {}
    /// }
    ///
    /// struct BananaButtonStyle: ButtonStyle {
    ///     var color: Color
    ///     func makeBody(configuration: Self.Configuration) -> some View {
    ///         BananaButton(configuration: configuration, color: color)
    ///     }
    ///
    ///     struct BananaButton: View {
    ///         let configuration: BananaButtonStyle.Configuration
    ///         let color: Color
    ///
    ///         var body: some View {
    ///             return configuration.label
    ///                 .padding()
    ///                 .background(RoundedRectangle(cornerRadius: 10).fill(color))
    ///                 .scaleEffect(configuration.isPressed ? 0.8: 1)
    ///                 .animation(.spring())
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter configuration : The properties of the button.
    func makeBody(configuration: Self.Configuration) -> Self.Body { }

    /// The properties of a button.
    typealias Configuration = ButtonStyleConfiguration
}

/// The properties of a button.
///
/// This property represents the view state of the `Button` that `ButtonStyle` modifies.
//`ButtonStyleConfiguration` consits of a label representing the button view, and `isPressed`, which indicates whether or not the button is currently being pressed.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ButtonStyleConfiguration {

    /// A type-erased label of a button.
    public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A view that describes the effect of pressing the button.
    public let label: ButtonStyleConfiguration.Label

    /// A Boolean that indicates whether the user is currently pressing the
    /// button.
    public let isPressed: Bool
}

/// A pill-style shape.
///
/// A Capsule is a rectangular `Shape` that by default, aligns itself inside of
/// the view containing it. It differs from `RoundedRectangle` in that its
/// corner radius is half the length of the retangle's smallest edge. In effect,
/// it creates a "pill" shape.
///
/// To define a Capsule with a specific color and frame, use the `Shape/fill()`
/// and `View/frame(width:height:)` modifiers:
///
/// ![Capsule fill and frame example](capsule-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Capsule()
///             .fill(Color.orange)
///             .frame(width: 250, height: 100)
///     }
/// }
/// ```
///
/// To add a border, use the `Shape/stroke(:lineWidth:)` modifier, and use
/// the `Capsule/inset(by:)` modifier to inset the Capsule by half of the
/// border width to keep the Capsule at its original size:
///
/// ![Capsule inset and stroke example](capsule-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Capsule()
///             .inset(by: 10)
///             .stroke(Color.orange, lineWidth: 20)
///             .frame(width: 250, height: 100)
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Capsule : Shape {

	/// The Capsule's rounded corner style, based on the value passed in its
    /// initializer.
	///
    /// Look at ``RoundedCornerStyle`` for more information.
    ///
	/// - SeeAlso: RoundedCornerStyle
    public var style: RoundedCornerStyle

    /// Creates an Ellipse that aligns itself inside of the view containing it
    /// by default.
    ///
    /// A style may be optionally passed into the initializer, with the options
    /// `circular` and `continuous`. These styles have subtle but noticeable
    /// differences:
    ///
    /// ![Ellipse init example](ellipse-example-3.png)
    ///
    /// ```
    /// `struct ExampleView: View {
    ///     var body: some View {
    ///         VStack(spacing: 20) {
    ///             Capsule(style: .circular)
    ///                 .frame(width: 250, height: 100)
    ///
    ///             Capsule(style: .continuous)
    ///                 .frame(width: 250, height: 100)
    ///         }
    ///     }
    /// }
    /// ```
    @inlinable public init(style: RoundedCornerStyle = .circular) { }

    /// Used to describe a Capsule as a path in a `CGRect`.
    ///
    /// A Capsule can be described as a path within a specific `CGRect` using
    /// the `Capsule/path(in:)` modifier:
    ///
    /// ![Capsule path example](capsule-example-3.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Capsule()
    ///             .path(in: CGRect(x: 0, y: 0, width: 75, height: 200))
    ///     }
    /// }
    /// ```
    public func path(in r: CGRect) -> Path { }

    /// > The type defining the data to animate.
    public typealias AnimatableData = EmptyAnimatableData

    /// > The type of view representing the body of this view.
    ///
    /// > When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Capsule : InsettableShape {

    /// Returns a Capsule insetted by the amount specified.
    ///
    /// For example, insetting by 10 points returns a Capsule that fills its
    /// container, with 10 points inset on all four side.
    ///
    /// ![Capsule inset example](capsule-example-5.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Capsule()
    ///             .inset(by: 10)
    ///     }
    /// }
    /// ```
    @inlinable public func inset(by amount: CGFloat) -> some InsettableShape { }


    /// > The type of the inset shape.
    public typealias InsetShape = some InsettableShape
}

/// A circle shape.
///
/// A Circle is centered on the frame of the view containing it. The circle's
/// radius equals half the length of the frame rectangle's smallest edge.
///
/// By default, a Circle is black, and takes up the space of its container:
///
/// ![Circle init example](Circle-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Circle()
///     }
/// }
/// ```
///
/// Define a Circle with a specific color and frame with the `Shape/fill()`
/// and `View/frame(width:height:)` modifiers. For example:
///
/// ![Circle fill and frame example](Circle-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Circle()
///             .fill(Color.blue)
///             .frame(width: 200, height: 200)
///     }
/// }
/// ```
///
/// To add a border, use the `Shape/stroke(:lineWidth:)` modifier, and use
/// the `Circle/inset(by:)` modifier to inset the circle by half of the border
/// width to keep the circle at its original size:
///
/// ![Circle inset and stroke example](Circle-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Circle()
///             .inset(by: 10)
///             .stroke(Color.blue, lineWidth: 20)
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Circle : Shape {

    /// Used to describe a Circle as a path in a `CGRect`.
    ///
    /// A Circle can be described as a path within a specific `CGRect` using the
    /// `Circle/path(in:)` modifier:
    ///
    /// ![Circle path example](Circle-example-4.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .path(in: CGRect(x: 0, y: 0, width: 100, height: 100))
    ///     }
    /// }
    /// ```
    public func path(in rect: CGRect) -> Path { }

    /// Creates a Circle that aligns itself inside of the view containing it
    /// by default.
    ///
    /// ![Circle init example](Circle-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Circle()
    ///     }
    /// }
    /// ```
    @inlinable public init() { }

    /// > The type defining the data to animate.
    public typealias AnimatableData = EmptyAnimatableData

    /// > The type of view representing the body of this view.
    ///
    /// > When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Circle : InsettableShape {

    /// Returns a Circle insetted by the amount specified.
    ///
    /// Returns a Circle insetted by the amount specified. For example,
    /// insetting by 10 points returns a Circle that fills its container, with
    /// 10 points inset on all four side.
    ///
    /// For example, insetting by 10 points returns a Circle that fills its
    /// container, with 10 points inset on all four side.
    ///
    /// ![Circle inset example](Circle-example-5.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .inset(by: 10)
    ///     }
    /// }
    /// ```
    @inlinable public func inset(by amount: CGFloat) -> some InsettableShape { }


    /// > The type of the inset shape.
    public typealias InsetShape = some InsettableShape
}

/// A progress view that visually indicates its progress using a circular gauge.
///
/// When initializing a ProgressView with ``ProgressView/init(_:_:)``, the
/// ``DefaultProgressViewStyle`` will typically display a circular progress view on
/// watchOS.
///
/// For example, to create a new ``ProgressView`` with this style:
///
/// ![Circular progress view example 1](circularprogressviewstyle-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        ProgressView()
///            .progressViewStyle(CircularProgressViewStyle())
///            .padding(20)
///    }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct CircularProgressViewStyle : ProgressViewStyle {

    /// Creates a circular progress view style.
    ///
    /// For example, to create a new ``ProgressView`` with this style:
    ///
    /// ![Circular progress view example 1](circularprogressviewstyle-example-1.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        ProgressView()
    ///            .progressViewStyle(CircularProgressViewStyle())
    ///            .padding(20)
    ///    }
    /// }
    /// ```
    public init() { }

    /// Creates a circular progress view style with a tint color.

    /// For example, to create a new ``ProgressView`` with this style:
    ///
    /// ![Circular progress view example 2](circularprogressviewstyle-example-2.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        ProgressView()
    ///            .progressViewStyle(CircularProgressViewStyle(tint: Color.red))
    ///            .padding(20)
    ///    }
    /// }
    /// ```
    public init(tint: Color) { }

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    public func makeBody(configuration: CircularProgressViewStyle.Configuration) -> some View { }


    /// A view representing the body of a progress view.
    public typealias Body = some View
}

/// An environment-dependent color.
///
/// `Color` represents an environment-dependent color that conforms to `View`. Colors conformance to `View` means that a color can be used as a view itself.
///
/// For example:
///
/// ![Color Example One](color-example-one.png)
///
///     struct ExampleView: View {
///         var body: some View {
///             Color.yellow
///         }
///     }
///
/// Color also conforms to `ShapeStyle` which allows it to serve as a fill or stroke on a shape.
///
/// For example:
///
/// ![Color Example Two](color-example-two.png)
///
///     struct ExampleView: View {
///         var body: some View {
///             Circle()
///                 .fill(Color.yellow)
///         }
///     }
///
/// And as a stroke:
///
/// ![Color Example Three](color-example-three.png)
///
///     struct ExampleView: View {
///         var body: some View {
///             Circle()
///                 .stroke(Color.yellow)
///         }
///     }
///
/// **Note**: A `Color` is a late-binding token: SwiftUI only resolves it to a concrete
/// value just before using it in a given environment.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Color : Hashable, CustomStringConvertible {

    /// Returns a `CGColor` that represents this color if one can be constructed
    /// that accurately represents this color.
    @available(iOS 14.0, macOS 11, tvOS 14.0, watchOS 7.0, *)
    public var cgColor: CGColor? { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Color, rhs: Color) -> Bool { }

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    ///
    /// To call this property directly, try:
    ///
    /// ![Description](color-description.png)
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Text(Color.yellow.description)
    ///        }
    ///    }
    public var description: String { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Color {

    /// Creates a color from an instance of `CGColor`.
    ///
    /// ![CGColor Init](color-cgcolor-init.png)
    ///
    ///     struct ExampleView: View {
    ///         let cgColor = CGColor(red: 1.00, green: 0.60, blue: 0.60, alpha: 1.0)
    ///
    ///         var body: some View {
    ///             Color(cgColor)
    ///         }
    ///     }
    ///
    public init(_ cgColor: CGColor) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color {

    /// The common ways of organizing RGB colors for a screen.
    public enum RGBColorSpace {

    	/// Standard RGB, which is what is normally used for apps and web browsers.
        case sRGB

        /// Linear standard RGB colors don't have the gamma curve of sRGB
        /// applied to them, hence "linear."
        case sRGBLinear

        /// Display P3 is a colorspace created by Apple for their devices.
        case displayP3

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Color.RGBColorSpace, b: Color.RGBColorSpace) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }

    /// Create a `Color` from RGB and opacity values along with an optional colorspace.
    ///
    /// ![Color RGB](color-rgb-init.png)
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             Color(red: 1.0, green: 0.6, blue: 0.6, opacity: 0.5)
    ///         }
    ///     }
    ///
    /// **Note**: The colorspace value defaults to sRGB, which is standard for apps. Note
    /// also that red, green, blue, and opacity are all specified in values from
    /// 0.0 to 1.0, so if your numbers are given from 0-255, you will need to
    /// divide them by 255 in order to use this initializer.
    ///
    /// - Parameters:
    ///   - colorSpace: The `RGBColorSpace` of the specified color.
    ///   - red: The red value of the color.
    ///   - green: The green value of the color.
    ///   - blue: The blue value of the color.
    ///   - opacity: The opacity of the color. Defaults to 1.0.
    public init(_ colorSpace: Color.RGBColorSpace = .sRGB, red: Double, green: Double, blue: Double, opacity: Double = 1) { }

    /// Create a `Color` from grayscale and opacity.
    ///
    /// ![Color White/Opacity](color-white-opacity.png)
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             Color(white: 0.2, opacity: 0.5)
    ///         }
    ///     }
    ///
    /// **Note**: Both the white and the opacity must be specified from 0.0 to 1.0. If
    /// either of these values are given to you as integers, they will need to
    /// be divided by their maximum value.
    ///
    /// - Parameters:
    ///   - colorSpace: The `RGBColorSpace` of the specified color.
    ///   - white: The grayscale value of the color, from 0.0 to 1.0.
    ///   - opacity: The opacity of the color. Defaults to 1.0.
    public init(_ colorSpace: Color.RGBColorSpace = .sRGB, white: Double, opacity: Double = 1) { }

    /// Creates a `Color` from hue, saturation, brightness, and opacity values.
    ///
    /// ![Hue Color Init](color-hue-init.png)
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             Color(hue: 0.5, saturation: 0.60, brightness: 0.90)
    ///         }
    ///     }
    ///
    /// **Note**: Apple's HSB scale is not the traditional 360, 100, 100. Instead all HSB values are from 0 to 1.
    ///
    /// - Parameters:
    ///   - hue: The hue of the color.
    ///   - saturation: The saturation of the color.
    ///   - brightness: The brightness of the color.
    ///   - opacity: The opacity of the color.
    public init(hue: Double, saturation: Double, brightness: Double, opacity: Double = 1) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color {

    /// A color that represents the system or application accent color.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Link("Banana🍌 Docs", destination: URL(string: "bananadocs.org")!)
    ///                .accentColor(Color.accentColor)
    ///        }
    ///    }
    ///
    /// The accent color reflects the broad theme color that can be applied to
    /// views and controls. If an explicit value hasn't been set, the default
    /// application or system accent color will be used.
    ///
    /// On macOS, customization of the accent color is only used if the
    /// "Multicolor" accent color is selected in System Preferences.
    public static var accentColor: Color { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color {

    /// A clear color `View`, equivalent to an empty view.
    public static let clear: Color

    /// A true black color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.black
    ///        }
    ///    }
    ///
    public static let black: Color

    /// A true white color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.white
    ///        }
    ///    }
    ///
    public static let white: Color

    /// A gray color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.gray
    ///        }
    ///    }
    ///
    public static let gray: Color

    /// A stylized red color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.red
    ///        }
    ///    }
    ///
    public static let red: Color

    /// A stylized green color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.green
    ///        }
    ///    }
    ///
    public static let green: Color

    /// A stylized blue color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.blue
    ///        }
    ///    }
    ///
    public static let blue: Color

    /// An orange color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.orange
    ///        }
    ///    }
    ///
    public static let orange: Color

    /// A stylized yellow color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.yellow
    ///        }
    ///    }
    ///
    public static let yellow: Color

    /// A pink color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.pink
    ///        }
    ///    }
    ///
    public static let pink: Color

    /// A purple color `View`.
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Color.purple
    ///        }
    ///    }
    ///
    public static let purple: Color

    /// The default color of text, based on the environment.
    ///
    /// Light Mode:
    /// ![Light Primary](color-primary-light.png)
    ///
    /// Dark Mode:
    /// ![Dark Primary](color-primary-dark.png)
    ///
    /// Code:
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Text("Bananas 🍌🍌")
    ///                .accentColor(.primary)
    ///        }
    ///    }
    ///
    /// If you are in light mode, this will be black. If, on the other hand, you
    /// are in dark mode, this will be white. It is automatically updated for
    /// you.
    public static let primary: Color

    /// The default color of text, with a little bit of transparency.
    ///
    /// If you are in light mode, this will be black with some transparency.
    /// If the device switches to dark mode, on the other hand, the text will
    /// dynamically shift to white with a little bit of transparency.
    public static let secondary: Color
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color : ShapeStyle {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color {

    /// Creates a named color.
    ///
    /// To declare a color with a `name` create your color in the `Assets.xcassets` folder.
    ///
    /// ![Create Color Name](color-name-showcase.png)
    ///
    /// Create a light theme and dark theme color to adjust your view depending on the user's environment.
    ///
    /// Next, run your app in both light theme and dark theme. Your color will automatically change.
    ///
    /// Light theme:
    /// ![Color Light Theme](color-name-light.png)
    ///
    /// Dark theme:
    /// ![Color Dark Theme](color-name-dark.png)
    ///
    /// Code:
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             Color("Pink")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - name: the name of the color resource to lookup.
    ///   - bundle: the bundle to search for the color resource in.
    public init(_ name: String, bundle: Bundle? = nil) { }
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension Color {

    /// Creates a color from an instance of `UIColor`.
    ///
    /// ![UIColor Init](color-uicolor-init.png)
    ///
    ///     struct ExampleView: View {
    ///         let uiColor = UIColor.yellow
    ///
    ///         var body: some View {
    ///             Color(uiColor)
    ///         }
    ///     }
    ///
    public init(_ color: UIColor) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color {

	/// Updates the transparency channel of a `Color`, returning a `Color` back.
	///
  ///
  /// ![Color Opacity](color-opacity.png)
  ///
  ///     struct ExampleView: View {
  ///            var body: some View {
  ///                ZStack {
  ///                    Text("Banana 🍌🍌")
  ///                    Color.pink.opacity(0.80)
  ///                }
  ///            }
  ///        }
  ///
	/// This is different from the `View/opacity(_:)` modifier because it
	/// returns a `Color` object rather than `some View`.
    public func opacity(_ opacity: Double) -> Color { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color.RGBColorSpace : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Color.RGBColorSpace : Hashable {
}

/// A view that lets the user choose a color.
///
/// The color picker provides a color well that shows the currently selected
/// color, and displays the larger system color picker that allows users to
/// select a new color.
///
/// By default color picker supports colors with opacity; to disable opacity
/// support, set the `supportsOpacity` parameter to `false`.
/// In this mode the color picker won't show controls for adjusting the opacity
/// of the selected color, and strips out opacity from any color set
/// programmatically or selected from the user's system favorites.
///
/// In general, there are 3 types of color picker titles, and 2 binding types, for 6 initializers total.
///
/// Title types:
/// 1. String
/// 2. Localized string key
/// 3. View
///
/// Binding types:
/// 1. ``CGColor``
/// 2. ``Color``
///
/// You use `ColorPicker` by embedding it inside a view hierarchy and
/// initializing it with a title string and a `Binding` to a `Color`:
///
///     struct ColorView: View {
///         @State private var color = Color.red
///
///         var body: some View {
///             ColorPicker("Choose a color! 🎨", selection: $color)
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ColorPicker<Label> : View where Label : View {

    /// Creates a color picker with a view title and Color binding.
    ///
    /// ```
    /// struct ColorView: View {
    ///     @State private var color = Color.orange
    ///
    ///     var body: some View {
    ///         ColorPicker(selection: $color, supportOpacity: false) {
    ///             Image(systemName: "eyedropper")
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - selection: A `Binding` to the variable that displays the
    ///       selected `Color`.
    ///     - supportsOpacity: A Boolean value that indicates whether the color
    ///       picker allows adjusting the selected color's opacity; the default
    ///       is `true`.
    ///     - label: A view that describes the use of the selected color.
    ///        The system color picker UI sets it's title using the text from
    ///        this view.
    ///
    public init(selection: Binding<Color>, supportsOpacity: Bool = true, @ViewBuilder label: () -> Label) { }

    /// Creates a color picker with a view title and CGColor binding.
    ///
    /// ```
    /// struct ColorView: View {
    ///     @State private var color = CGColor(gray: 1.0, alpha: 0.5)
    ///
    ///     var body: some View {
    ///         ColorPicker(selection: $color, supportOpacity: false) {
    ///             Image(systemName: "eyedropper")
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - selection: A `Binding` to the variable that displays the
    ///       selected `CGColor`.
    ///     - supportsOpacity: A Boolean value that indicates whether the color
    ///       picker allows adjusting the selected color's opacity; the default
    ///       is `true`.
    ///     - label: A view that describes the use of the selected color.
    ///        The system color picker UI sets it's title using the text from
    ///        this view.
    ///
    public init(selection: Binding<CGColor>, supportsOpacity: Bool = true, @ViewBuilder label: () -> Label) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ColorPicker where Label == Text {

    /// Creates a color picker with a localized string key title and Color binding.
    ///
    /// Use `ColorPicker` to create a color well that your app uses to allow
    /// the selection of a `Color`. The example below creates a color well
    /// using a `Binding` to a property stored in a settings object and title
    /// you provide:
    ///
    /// ```
    /// struct ColorView: View {
    ///     @State private var color = Color.orange
    ///
    ///     var body: some View {
    ///         ColorPicker(LocalizedStringKey("Choose a color"),
    ///                     selection: $color,
    ///                     supportOpacity: false)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the picker.
    ///   - selection: A `Binding` to the variable that displays the
    ///     selected `Color`.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    public init(_ titleKey: LocalizedStringKey, selection: Binding<Color>, supportsOpacity: Bool = true) { }

    /// Creates a color picker with a string title and Color binding.
    ///
    /// Use `ColorPicker` to create a color well that your app uses to allow
    /// the selection of a `Color`. The example below creates a color well
    /// using a `Binding` and title you provide:
    ///
    /// ```
    /// struct ColorView: View {
    ///     @State private var color = Color.orange
    ///
    ///     var body: some View {
    ///         ColorPicker("Choose a color 🎨",
    ///                     selection: $color,
    ///                     supportOpacity: false)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - title: The title displayed by the color picker.
    ///   - selection: A `Binding` to the variable containing a `Color`.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    public init<S>(_ title: S, selection: Binding<Color>, supportsOpacity: Bool = true) where S : StringProtocol { }

    /// Creates a color picker with a localized string key title and a CGColor binding.
    ///
    /// ```
    /// struct ColorView: View {
    ///     @State private var color = CGColor(gray: 1.0, alpha: 0.5)
    ///
    ///     var body: some View {
    ///         ColorPicker(LocalizedStringKey("Choose a color"),
    ///                     selection: $color,
    ///                     supportOpacity: false)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the picker.
    ///   - selection: A `Binding` to the variable that displays the
    ///     selected `CGColor`.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    public init(_ titleKey: LocalizedStringKey, selection: Binding<CGColor>, supportsOpacity: Bool = true) { }

    /// Creates a color picker with a string title and a CGColor binding.
    ///
    /// ```
    /// struct ColorView: View {
    ///     @State private var color = CGColor(gray: 1.0, alpha: 0.5)
    ///
    ///     var body: some View {
    ///         ColorPicker("Choose a color 🎨",
    ///                     selection: $color,
    ///                     supportOpacity: false)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - title: The title displayed by the color picker.
    ///   - selection: A `Binding` to the variable containing a `CGColor`.
    ///   - supportsOpacity: A Boolean value that indicates whether the color
    ///     picker allows adjustments to the selected color's opacity; the
    ///     default is `true`.
    public init<S>(_ title: S, selection: Binding<CGColor>, supportsOpacity: Bool = true) where S : StringProtocol { }
}

/// The working color space for color-compositing operations.
///
/// Each color space guarantees to preserve a particular range of color values.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum ColorRenderingMode {

    /// The non-linear sRGB working color space, with color component values
    /// outside the range `[0, 1]` producing undefined results.
    ///
    /// This color space is gamma corrected.
    case nonLinear

    /// The linear sRGB working color space, with color component values outside
    /// the range `[0, 1]` producing undefined results.
    ///
    /// This color space isn't gamma corrected.
    case linear

    /// The linear sRGB working color space, with color component values outside
    /// the range `[0, 1]` preserved.
    ///
    /// This color space isn't gamma corrected.
    case extendedLinear

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ColorRenderingMode, b: ColorRenderingMode) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ColorRenderingMode : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ColorRenderingMode : Hashable {
}

/// The possible types of color schemes, like Dark Mode.
///
/// The color scheme enumerates the user setting options for Light or Dark Mode.
/// It also provides the light or dark options for any particular view when the
/// app wants to override the user setting.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum ColorScheme : CaseIterable {

	/// The color scheme referring to light mode in a device.
    case light

    /// The color scheme referring to dark mode in a device.
    case dark

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ColorScheme, b: ColorScheme) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [ColorScheme]

    /// A collection of all values of this type.
    public static var allCases: [ColorScheme] { get }
}

extension ColorScheme {

    /// Create a color scheme from its UIUserInterfaceStyle equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiUserInterfaceStyle: UIUserInterfaceStyle) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ColorScheme : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ColorScheme : Hashable {
}

/// Options indicating whether the system uses standard or increased contrast
/// between the app's foreground and background colors.
///
/// The user sets the Increase Contrast option using the Settings app. Your app
/// cannot override the user's choice.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum ColorSchemeContrast : CaseIterable {

    /// An option indicating that the system is using standard contrast between
    /// the app's foreground and background colors.
    case standard

    /// An option indicating that the system is using increased contrast between
    /// the app's foreground and background colors.
    case increased

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ColorSchemeContrast, b: ColorSchemeContrast) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [ColorSchemeContrast]

    /// A collection of all values of this type.
    public static var allCases: [ColorSchemeContrast] { get }
}

extension ColorSchemeContrast {

    /// Create a contrast from its UIAccessibilityContrast equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiAccessibilityContrast: UIAccessibilityContrast) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ColorSchemeContrast : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ColorSchemeContrast : Hashable {
}

/// Command groups describe additional groupings of controls to add to existing
/// command menus.
///
/// On macOS, command groups are realized as collections of menu items in a menu
/// bar menu. On iOS, iPadOS, and tvOS, SwiftUI creates key commands for each of
/// a group's commands that has a keyboard shortcut.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CommandGroup<Content> : Commands where Content : View {

    /// The composition of commands that comprise the command group.
    public var body: some Commands { get }

    /// A value describing the addition of the given views to the beginning of
    /// the indicated group.
    public init(before group: CommandGroupPlacement, @ViewBuilder addition: () -> Content) { }

    /// A value describing the addition of the given views to the end of the
    /// indicated group.
    public init(after group: CommandGroupPlacement, @ViewBuilder addition: () -> Content) { }

    /// A value describing the complete replacement of the contents of the
    /// indicated group with the given views.
    public init(replacing group: CommandGroupPlacement, @ViewBuilder addition: () -> Content) { }

    /// The type of command group representing the body of this command group.
    public typealias Body = some Commands
}

/// Identifier types for standard locations that new command groups can be
/// placed relative to.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CommandGroupPlacement {

    /// Standard placement for commands that provide information about the app,
    /// the terms of the user's license agreement, etc.
    ///
    /// Includes the following by default on macOS:
    /// * About App
    public static let appInfo: CommandGroupPlacement

    /// Standard placement for commands that expose app settings and
    /// preferences.
    ///
    /// Includes the following by default on macOS:
    /// * Preferences
    public static let appSettings: CommandGroupPlacement

    /// Standard placement for commands that expose services provided by other
    /// apps.
    ///
    /// Includes the following by default on macOS:
    /// * Services submenu (managed automatically)
    public static let systemServices: CommandGroupPlacement

    /// Standard placement for commands that control the visibility of running
    /// apps.
    ///
    /// Includes the following by default on macOS:
    /// * Hide App
    /// * Hide Others
    /// * Show All
    public static let appVisibility: CommandGroupPlacement

    /// Standard placement for commands that result in app termination.
    ///
    /// Includes the following by default on macOS:
    /// * Quit App
    public static let appTermination: CommandGroupPlacement

    /// Standard placement for commands that create and open different kinds of
    /// documents.
    ///
    /// Includes the following by default on macOS:
    /// * New
    /// * Open
    /// * Open Recent submenu (managed automatically)
    public static let newItem: CommandGroupPlacement

    /// Standard placement for commands that save open documents and close
    /// windows.
    ///
    /// Includes the following by default on macOS:
    /// * Close
    /// * Save
    /// * Save As/Duplicate
    /// * Revert to Saved
    public static let saveItem: CommandGroupPlacement

    /// Standard placement for commands that relate to importing and exporting
    /// data using formats that the app doesn't natively support.
    ///
    /// Empty by default on macOS.
    public static let importExport: CommandGroupPlacement

    /// Standard placement for commands related to printing app content.
    ///
    /// Includes the following by default on macOS:
    /// * Page Setup
    /// * Print
    public static let printItem: CommandGroupPlacement

    /// Standard placement for commands that control the Undo Manager.
    ///
    /// Includes the following by default on macOS:
    /// * Undo
    /// * Redo
    public static let undoRedo: CommandGroupPlacement

    /// Standard placement for commands that interact with the pasteboard and
    /// manipulate content that is currently selected in the app's view
    /// hierarchy.
    ///
    /// Includes the following by default on macOS:
    /// * Cut
    /// * Copy
    /// * Paste
    /// * Paste and Match Style
    /// * Delete
    /// * Select All
    public static let pasteboard: CommandGroupPlacement

    /// Standard placement for commands that manipulate and transform text
    /// selections.
    ///
    /// Includes the following by default on macOS:
    /// * Find submenu
    /// * Spelling and Grammar submenu
    /// * Substitutions submenu
    /// * Transformations submenu
    /// * Speech submenu
    public static let textEditing: CommandGroupPlacement

    /// Standard placement for commands that manipulate and transform the styles
    /// applied to text selections.
    ///
    /// Includes the following by default on macOS:
    /// * Font submenu
    /// * Text submenu
    public static let textFormatting: CommandGroupPlacement

    /// Standard placement for commands that manipulate the toolbar.
    ///
    /// Includes the following by default on macOS:
    /// * Show/Hide Toolbar
    /// * Customize Toolbar
    public static let toolbar: CommandGroupPlacement

    /// Standard placement for commands that control the app's sidebar and full
    /// screen modes.
    ///
    /// Includes the following by default on macOS:
    /// * Show/Hide Sidebar
    /// * Enter/Exit Full Screen
    public static let sidebar: CommandGroupPlacement

    /// Standard placement for commands that control the size of the window.
    ///
    /// Includes the following by default on macOS:
    /// * Minimize
    /// * Zoom
    public static let windowSize: CommandGroupPlacement

    /// Standard placement for commands that arrange all of an app's windows.
    ///
    /// Includes the following by default on macOS:
    /// * Bring All to Front
    public static let windowArrangement: CommandGroupPlacement

    /// Standard placement for commands that present documentation and helpful
    /// information to the user.
    ///
    /// Includes the following by default on macOS:
    /// * App Help
    public static let help: CommandGroupPlacement
}

/// Command menus are stand-alone, top-level containers for controls that
/// perform related, app-specific commands.
///
/// Command menus are realized as menu bar menus on macOS, inserted between the
/// built-in View and Window menus in order of declaration. On iOS, iPadOS, and
/// tvOS, SwiftUI creates key commands for each of a menu's commands that has a
/// keyboard shortcut.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CommandMenu<Content> : Commands where Content : View {

    /// The composition of commands that comprise the command group.
    public var body: some Commands { get }

    /// Creates a new menu with a localized name for a collection of app-
    /// specific commands, inserted in the standard location for app menus
    /// (after the View menu, in order with other menus declared without an
    /// explicit location).
    public init(_ nameKey: LocalizedStringKey, @ViewBuilder content: () -> Content) { }

    /// Creates a new menu for a collection of app-specific commands, inserted
    /// in the standard location for app menus (after the View menu, in order
    /// with other menus declared without an explicit location).
    public init(_ name: Text, @ViewBuilder content: () -> Content) { }

    /// Creates a new menu for a collection of app-specific commands, inserted
    /// in the standard location for app menus (after the View menu, in order
    /// with other menus declared without an explicit location).
    public init<S>(_ name: S, @ViewBuilder content: () -> Content) where S : StringProtocol { }

    /// The type of command group representing the body of this command group.
    public typealias Body = some Commands
}

/// Conforming types represent a group of related commands that can be exposed
/// to the user via the main menu on macOS and key commands on iOS.
///
/// The available Command types are:
/// - ``CommandGroup``
/// - ``CommandMenu``
/// - ``EmptyCommands``
/// - ``SidebarCommands``
/// - ``TextEditingCommands``
/// - ``TextFormattingCommands``
/// - ``ToolbarCommands``
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol Commands{ }
extension Commands {

    /// The type of command group representing the body of this command group.
    associatedtype Body : Commands

    /// The composition of commands that comprise the command group.
    @CommandsBuilder var body: Self.Body { get }
}

/// Constructs command sets from multi-expression closures. Like `ViewBuilder`,
/// it supports up to ten expressions in the closure body.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_functionBuilder public struct CommandsBuilder {

    /// Builds an empty command set from an block containing no statements.
    public static func buildBlock() -> EmptyCommands { }

    /// Passes a single command group written as a child group through
    /// modified.
    public static func buildBlock<Content>(_ content: Content) -> Content where Content : Commands { }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes two command groups written as a child through modified.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some Commands where C0 : Commands, C1 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes three command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes four command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes five command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes six command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes seven command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes eight command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands, C7 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes nine command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands, C7 : Commands, C8 : Commands { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension CommandsBuilder {

	/// Passes ten command groups written as a child through modified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some Commands where C0 : Commands, C1 : Commands, C2 : Commands, C3 : Commands, C4 : Commands, C5 : Commands, C6 : Commands, C7 : Commands, C8 : Commands, C9 : Commands { }

}

/// Display a date picker in a compact, textual format.
///
/// > "This style is useful when space is constrained and users expect to make specific date and time selections. Some variants may include rich editing controls in a popup."
///
/// ![CompactDatePickerStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/date-pickerstyle-compact-example-1.gif)
///
///
///      struct ExampleView: View {
///          @State var date: Date = Date()
///
///          var body: some View {
///              DatePicker("Date", selection: $date)
///                  .datePickerStyle(CompactDatePickerStyle())
///                  .padding()
///          }
///      }
///
///
@available(iOS 14.0, macCatalyst 13.4, macOS 10.15.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct CompactDatePickerStyle : DatePickerStyle {

	/// Creates a compact date picker style.
    public init() { }
}

/// A shape that is replaced by an inset version of the current
/// container shape. If no container shape was defined, is replaced by
/// a rectangle.
///
/// Use this shape primarily with widgets, to generate container-relative
/// rounded rectangles.
///
/// ```
/// struct TimeEntryView: View {
///     var entry: Provider.Entry
///
///     var body: some View {
///         VStack {
///             ContainerRelativeShape()
///                 .fill(Color.pink)
///                 .overlay(Text("time"))
///             ContainerRelativeShape()
///                 .fill(Color.blue)
///                 .overlay(Text(entry.date, style: .time)))
///         }
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public struct ContainerRelativeShape : Shape {

    /// Describes this shape as a path within a rectangular frame of reference.
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    public func path(in rect: CGRect) -> Path { }

    /// Creates a relative container shape.
    ///
    /// Use this shape primarily with widgets, to generate container-relative
    /// rounded rectangles.
    ///
    /// ```
    /// struct TimeEntryView: View {
    ///     var entry: Provider.Entry
    ///
    ///     var body: some View {
    ///         VStack {
    ///             ContainerRelativeShape()
    ///                 .fill(Color.pink)
    ///                 .overlay(Text("time"))
    ///             ContainerRelativeShape()
    ///                 .fill(Color.blue)
    ///                 .overlay(Text(entry.date, style: .time)))
    ///         }
    ///     }
    /// }
    /// ```
    @inlinable public init() { }

    /// The type defining the data to animate.
    public typealias AnimatableData = EmptyAnimatableData

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ContainerRelativeShape : InsettableShape {

    /// Returns `self` inset by `amount`.
    @inlinable public func inset(by amount: CGFloat) -> some InsettableShape { }


    /// The type of the inset shape.
    public typealias InsetShape = some InsettableShape
}

/// Constants that define how a view's content fills the available space.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public enum ContentMode : Hashable, CaseIterable {

	/// Fill mode that scales down view so that it can be fully seen in the
	/// available space, even it it leaves whitespace.
    case fit

    /// Fill mode that scales the view so that it fills the available space
    /// entirely, even if not all of the view can be seen.
    case fill

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ContentMode, b: ContentMode) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [ContentMode]

    /// A collection of all values of this type.
    public static var allCases: [ContentMode] { get }
}

/// Some options for specifying the preferred size of your content.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum ContentSizeCategory : Hashable, CaseIterable {

	/// Extra small content size.
    case extraSmall

    /// Small content size.
    case small

    /// Medium content size.
    case medium

    /// Large content size.
    case large

    /// Extra large content size.
    case extraLarge

    /// Double extra large content size.
    case extraExtraLarge

    /// The largest content size option.
    case extraExtraExtraLarge

    /// A medium content size reflecting the accessibility settings.
    case accessibilityMedium

    /// A large content size reflecting the accessibility settings.
    case accessibilityLarge

    /// An extra large content size reflecting the accessibility settings.
    case accessibilityExtraLarge

    /// An extra, extra large content size reflecting the accessibility settings.
    case accessibilityExtraExtraLarge

    /// A really enormous content size reflecting the accessibility settings.
    case accessibilityExtraExtraExtraLarge

    /// A `Bool` value indicating whether the content size category is one that
    /// is associated with accessibility.
    @available(iOS 13.4, macOS 10.15.4, tvOS 13.4, watchOS 6.2, *)
    public var isAccessibilityCategory: Bool { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ContentSizeCategory, b: ContentSizeCategory) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [ContentSizeCategory]

    /// A collection of all values of this type.
    public static var allCases: [ContentSizeCategory] { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ContentSizeCategory {

    /// Returns a Boolean value indicating whether the value of the first argument is less than that of the second argument.
    public static func < (lhs: ContentSizeCategory, rhs: ContentSizeCategory) -> Bool { }

    /// Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.
    public static func <= (lhs: ContentSizeCategory, rhs: ContentSizeCategory) -> Bool { }

    /// Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.
    public static func > (lhs: ContentSizeCategory, rhs: ContentSizeCategory) -> Bool { }

    /// Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.
    public static func >= (lhs: ContentSizeCategory, rhs: ContentSizeCategory) -> Bool { }
}

extension ContentSizeCategory {

    /// Create a size category from its UIContentSizeCateogry equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiSizeCategory: UIContentSizeCategory) { }
}

/// A container for views that you present as menu items in a contextual menu
/// after completion of the standard system gesture.
///
/// Relate the controls that a `ContextMenu` contains to the context from
/// which you show them.
@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(tvOS, unavailable)
@available(watchOS, introduced: 6.0, deprecated: 7.0)
public struct ContextMenu<MenuItems> where MenuItems : View {

	/// Creates a context menu from a builder of menu items.
	///
	/// - Parameter menuItems: The builder of menu items to build your context menu.
	///
	/// - SeeAlso: contextMenu(menuItems:)
    public init(@ViewBuilder menuItems: () -> MenuItems) { }
}

/// Represents the context (or space) of a set of coordinates relative to the screen.
///
/// ``CoordinateSpace`` allows a set of X, Y coordinates to have context on if they
/// are relative to the frame's parent, or absolute to the device screen. It is also possible
/// to define a custom coordinate space on a view with `View/coordinateSpace(name:)`. This custom
/// coordinate space can be checked with the `.named(AnyHashable)` case.
///
/// For example:
///
/// ![Coordinate space example 1](coordinate-space-example.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        HStack {
///            Rectangle()
///                .fill(Color.red)
///
///            GeometryReader { geometryProxy in
///                Button(action: {
///                    let globalFrame = geometryProxy.frame(in: CoordinateSpace.global)
///                    let localFrame = geometryProxy.frame(in: CoordinateSpace.local)
///                    print("Global center: \(globalFrame.midX) x \(globalFrame.midY)") // Prints: "Global center: 160.0 x 294.0"
///                    print("Local center: \(localFrame.midX) x \(localFrame.midY)") // Prints: "50.67 x 274.0"
///                }, label: {
///                    Text("Button with coordinate spaces")
///                })
///                .background(Color.orange)
///            }
///
///            Rectangle()
///                .fill(Color.red)
///        }
///    }
/// }
/// ```
///
/// In this example, the center of the Button coordinates is retrieved. The global center
/// means that the middle of the button is 160 pixels from the left of the screen, and 294 pixels
/// from the top of the screen. The local center means that the middle of the button is
/// ~50 pixels from the left edge of it's container (which is the ``GeometryReader``)
/// and the middle of the button is 274 pixels from the top of it's container.
///
/// There are two additional important things to note about this example:
///   - For illustrative purposes, the enum values were expanded in this example.
///   It would also be valid to use the shorthand, just specifying the values: `.global` or `.local`.
///   - The exact output of coordinates will differ depending on screen size, but
///   the local midX coordinate will always be smaller than the global midX since it's relative.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum CoordinateSpace {

    /// The absolute coordinate space representing the entire screen.
    case global

    /// The relative coordinate space representing the current view.
    case local

    /// A coordinate space chosen by the `Hashable` parameter.
    case named(AnyHashable)
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension CoordinateSpace {

	/// Whether or not the coordinate space is `CoordinateSpace.global`
    public var isGlobal: Bool { get }

    /// Whether or not the coordinate space is `CoordinateSpace.local`
    public var isLocal: Bool { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension CoordinateSpace : Equatable, Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: CoordinateSpace, rhs: CoordinateSpace) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

/// Conforming types represent items that can be placed in various locations
/// in a customizable toolbar.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol CustomizableToolbarContent : ToolbarContent where Self.Body : CustomizableToolbarContent{ }
extension CustomizableToolbarContent : ToolbarContent where Self.Body : CustomizableToolbarContent {
}

/// A picker control for selecting dates.
///
/// You create a picker by providing 3 things:
/// 1. a selection binding
/// 2. a label
/// 3. the editable parts of the date
///
/// There are four types of pickers, and three types of labels, making 12 total initializers.
///
/// Picker types:
/// 1. Unlimited range
/// 2. Closed range (maximum and minimum)
/// 3. From range (minimum only)
/// 4. Through range (maximum only)
///
/// Label types:
/// 1. String
/// 2. Localized string key
/// 3. View
///
/// A simple example looks like this:
///
/// ```
/// struct DatePickerView: View {
///     @State private var date = Date()
///
///     var body: some View {
///         DatePicker("Date", selection: $date)
///     }
/// }
/// ```
///
/// ### Styling Date Pickers
///
/// You can customize the appearance and interaction of date pickers using one of the
/// ``DatePickerStyle``s provided by SwiftUI. The full list of styles is:
/// - ``DefaultDatePickerStyle`` (iOS and macOS)
/// - ``WheelDatePickerStyle`` (iOS)
/// - ``FieldDatePickerStyle`` (macOS)
/// - ``GraphicalDatePickerStyle`` (macOS)
/// - ``StepperFieldDatePickerStyle`` (macOS)
///
/// Currently, you cannot create your own custom ``DatePickerStyle``.
///
/// To set a specific style for all picker instances within a view, use the
/// ``View/datePickerStyle(_:)`` modifier.
///
/// ```
/// struct StyledDatePickerView: View {
///     @State private var date = Date()
///
///     var body: some View {
///         DatePicker(selection: $date, label: { Text("Date") })
///             .datePickerStyle(WheelDatePickerStyle())
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DatePicker<Label> : View where Label : View {

	/// A type alias for the `DatePickerComponents` option set used in `DatePicker`.
    public typealias Components = DatePickerComponents

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DatePicker {

    /// Creates a date picker with unlimited range and a View label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(selection: $date,
    ///                    displayedComponents: [.hourAndMinute, .date],
    ///                    label: { HStack { Image(systemName: "calendar"); Image(systemName: "clock") } })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - selection: The binding Date value of the date picker.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    ///   - label: A closure that returns a label view.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label) { }

    /// Creates a date picker with closed range and a View label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(selection: $date,
    ///                    in: Date()...Date().advanced(by: 3600 * 90),
    ///                    displayedComponents: [.hourAndMinute, .date],
    ///                    label: { HStack { Image(systemName: "calendar"); Image(systemName: "clock") } })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The maximum and minimum dates.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    ///   - label: A closure that returns a label view.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(selection: Binding<Date>, in range: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label) { }

    /// Creates a date picker with "from" range and a View label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(selection: $date,
    ///                    in: Date()...,
    ///                    displayedComponents: [.hourAndMinute, .date],
    ///                    label: { HStack { Image(systemName: "calendar"); Image(systemName: "clock") } })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The range of selectable dates, with only a minimum specified.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    ///   - label: A closure that returns a label view.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(selection: Binding<Date>, in range: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label) { }

    /// Creates a date picker with "through" range and a View label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(selection: $date,
    ///                    in: ...Date(),
    ///                    displayedComponents: [.hourAndMinute, .date],
    ///                    label: { HStack { Image(systemName: "calendar"); Image(systemName: "clock") } })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The range of selectable dates, with only a maximum specified.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    ///   - label: A closure that returns a label view.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(selection: Binding<Date>, in range: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date], @ViewBuilder label: () -> Label) { }
}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DatePicker where Label == Text {

    /// Creates a date picker with unlimited range and a localized string key label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(LocalizedStringKey("Date"),
    ///                    selection: $date,
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: The date picker label as a localized string key.
    ///   - selection: The binding Date value of the date picker.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) { }

    /// Creates a date picker with closed range and a localized string key label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(LocalizedStringKey("Date and time"),
    ///                    selection: $date,
    ///                    in: Date()...Date().advance(by: 3600 * 90),
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: The date picker label as a localized string key.
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The maximum and minimum dates.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, in range: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) { }

    /// Creates a date picker with "from" range and a localized string key label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(LocalizedStringKey("Date and time"),
    ///                    selection: $date,
    ///                    in: Date()...,
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: The date picker label as a localized string key.
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The range of selectable dates, with only a minimum specified.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, in range: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) { }

    /// Creates a date picker with "through" range and a localized string key label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker(LocalizedStringKey("Date and time"),
    ///                    selection: $date,
    ///                    in: ...Date(),
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: The date picker label as a localized string key.
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The range of selectable dates, with only a maximum specified.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ titleKey: LocalizedStringKey, selection: Binding<Date>, in range: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) { }

    /// Creates a date picker with unlimited range and a string label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker("Date 📆 and time ⏰",
    ///                    selection: $date,
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - title: The date picker label as a string.
    ///   - selection: The binding Date value of the date picker.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<S>(_ title: S, selection: Binding<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol { }

    /// Creates a date picker with closed range and a string label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker("Date 📆 and time ⏰",
    ///                    selection: $date,
    ///                    in: Date()...Date().advance(by: 3600 * 90),
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - title: The date picker label as a string.
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The maximum and minimum dates.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<S>(_ title: S, selection: Binding<Date>, in range: ClosedRange<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol { }

    /// Creates a date picker with "from" range and a string label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker("Date 📆 and time ⏰",
    ///                    selection: $date,
    ///                    in: Date()...,
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - title: The date picker label as a string.
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The range of selectable dates, with only a minimum specified.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<S>(_ title: S, selection: Binding<Date>, in range: PartialRangeFrom<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol { }

    /// Creates a date picker with "through" range and a string label.
    ///
    /// ```
    /// struct DateView: View {
    ///     @State private var date = Date()
    ///
    ///     var body: some View {
    ///         Text("\(date)")
    ///         DatePicker("Date 📆 and time ⏰",
    ///                    selection: $date,
    ///                    in: ...Date(),
    ///                    displayedComponents: [.hourAndMinute, .date])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - title: The date picker label as a string.
    ///   - selection: The binding Date value of the date picker.
    ///   - range: The range of selectable dates, with only a maximum specified.
    ///   - displayedComponents: The components of the date that user is able to
    ///     view and edit. Defaults to `[.hourAndMinute, .date]`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<S>(_ title: S, selection: Binding<Date>, in range: PartialRangeThrough<Date>, displayedComponents: DatePicker<Label>.Components = [.hourAndMinute, .date]) where S : StringProtocol { }
}

/// An efficient option set for the components of a date picker.
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DatePickerComponents : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: UInt

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: UInt) { }

    /// Displays hour and minute components based on the locale
    public static let hourAndMinute: DatePickerComponents

    /// Displays day, month, and year based on the locale
    public static let date: DatePickerComponents

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = DatePickerComponents

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = UInt

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = DatePickerComponents
}

/// A specification for the appearance and interaction of a `DatePicker`.
///
/// There is no public interface for `DatePickerStyle`.
///
/// There are currently 5 date picker styles:
/// - ``DefaultDatePickerStyle`` on iOS and macOS
/// - ``WheelDatePickerStyle`` on iOS
/// - ``FieldDatePickerStyle`` on macOS
/// - ``GraphicalDatePickerStyle`` on macOS
/// - ``StepperFieldDatePickerStyle`` on macOS
///
/// ```
/// struct StyledDatePickerView: View {
///     @State private var date = Date()
///
///     var body: some View {
///         DatePicker(selection: $date, label: { Text("Date") })
///             .datePickerStyle(WheelDatePickerStyle())
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol DatePickerStyle{ }
extension DatePickerStyle {
}

/// The default button style, based on the button's context.
///
/// > "If you create a button directly on a blank canvas, the style varies by platform. iOS uses the borderless button style by default, whereas macOS, tvOS, and watchOS use the bordered button style."
///
/// ![DefaultButtonStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/buttonstyle-plain-border-default-example-1.png)
///
///
///     struct ExampleView: View {
///         var body: some View {
///              VStack {
///                  Button("PlainBanana🍌🍌") { tap() }
///                     .buttonStyle(PlainButtonStyle())
///
///                  Button("BorderlessBanana🍌🍌") { tap() }
///                     .buttonStyle(BorderlessButtonStyle())
///
///                  Button("DefaultBanana🍌🍌") { tap() }
///                     .buttonStyle(DefaultButtonStyle())
///              }
///              .font(.title2)
///          }
///
///          func tap() {}
///      }
///
///
/// If you create a button inside a container, like a `List`, the style
/// resolves to the recommended style for buttons inside that container for that
/// specific platform.
///
/// You can override a button's style. To apply the default style to a button,
/// or to a view that contains buttons, use the `View/buttonStyle(_:)-66fbx`
/// modifier.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultButtonStyle : PrimitiveButtonStyle {

    /// Creates a default button style.
    public init() { }

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each `Button` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    public func makeBody(configuration: DefaultButtonStyle.Configuration) -> some View { }


    /// A view that represents the body of a button.
    public typealias Body = some View
}

/// The default `DatePicker` style.
///
/// ![DefaultDatePickerStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/date-pickerstyle-compact-example-1.gif)
///
///
///      struct ExampleView: View {
///          @State var date: Date = Date()
///
///          var body: some View {
///              DatePicker("Date", selection: $date)
///                  .datePickerStyle(DefaultDatePickerStyle())
///                  .padding()
///          }
///      }
///
///
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DefaultDatePickerStyle : DatePickerStyle {

	/// Creates a default date picker style.
	///
	/// - SeeAlso: DatePicker
    public init() { }
}

/// The default `GroupBoxStyle`.
///
/// ![DefaultGroupBoxStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/default-groupboxstyle-example-1.png)
///
///
///     struct ExampleView: View {
///         var body: some View {
///             GroupBox() {
///                 Label("Bananas 🍌🍌", systemImage: "heart.fill")
///                     .foregroundColor(.yellow)
///                     .groupBoxStyle(DefaultGroupBoxStyle())
///              }, {
///                 Text("Go Bananas")
///              }
///             .padding()
///         }
///      }
///
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DefaultGroupBoxStyle : GroupBoxStyle {

	/// Creates a default group box style.
	///
    /// ![DefaultGroupBoxStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/default-groupboxstyle-example-1.png)
    ///
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             GroupBox() {
    ///                 Label("Bananas 🍌🍌", systemImage: "heart.fill")
    ///                     .foregroundColor(.yellow)
    ///                     .groupBoxStyle(DefaultGroupBoxStyle())
    ///              }, {
    ///                 Text("Go Bananas")
    ///              }
    ///             .padding()
    ///         }
    ///      }
    ///
	/// - SeeAlso: GroupBoxStyle
    public init() { }

    /// Creates a `View` representing the body of a `GroupBox`.
    ///
    /// - Parameter configuration: The properties of the group box instance being
    ///   created.
    ///
    /// This method will be called for each instance of `GroupBox` created within
    /// a view hierarchy where this style is the current `GroupBoxStyle`.
    public func makeBody(configuration: DefaultGroupBoxStyle.Configuration) -> some View { }


    /// A `View` representing the body of a `GroupBox`.
    public typealias Body = some View
}

/// The default label style in the current context.
///
/// ![DefaultLabelStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/labelstyle-default-example-1.png)
///
///
///    struct ExampleView: View {
///        var body: some View {
///             Label("Banana🍌", systemImage: "heart.fill")
///                 .labelStyle(DefaultLabelStyle())
///        }
///    }
///
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct DefaultLabelStyle : LabelStyle {

    /// Creates a default label style.
    public init() { }

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each `Label` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    public func makeBody(configuration: DefaultLabelStyle.Configuration) -> some View { }


    /// A view that represents the body of a label.
    public typealias Body = some View
}

/// The instance that describes a platform's default behavior and appearance for
/// a list.
///
/// ![DefaultListStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/liststyle-default-example-1.png)
///
///
///      struct ExampleView: View {
///          var body: some View {
///             List {
///                Text("Bananas 🍌🍌")
///                Text("Apples 🍎🍎")
///                Text("Peaches 🍑🍑")
///             }
///             .listStyle(DefaultListStyle())
///          }
///      }
///
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultListStyle : ListStyle {

    /// Creates a default list style.
    public init() { }
}

/// The default menu style, based on the menu's context.
///
/// The default menu style can vary by platform. By default, macOS uses the
/// bordered button style.
///
/// If you create a menu inside a container, the style resolves to the
/// recommended style for menus inside that container for that specific platform.
/// For example, a menu nested within another menu will resolve to a submenu:
///
///     Menu("Edit") {
///         Menu("Arrange") {
///             Button("Bring to Front", action: moveSelectionToFront)
///             Button("Send to Back", action: moveSelectionToBack)
///         }
///         Button("Delete", action: deleteSelection)
///     }
///
/// You can override a menu's style. To apply the default style to a menu, or to
/// a view that contains a menu, use the `View/menuStyle(_:)` modifier.
///
/// For example,
///
/// ![DefaultMenu Example 1](default-menu-example.gif)
///
/// ```
/// struct DefaultMenuView: View {
///     var body: some View {
///         Menu("PDF") {
///             Button("Open in Preview", action: { })
///             Button("Save as PDF", action: { })
///         }
///         .menuStyle(DefaultMenuStyle())
///     }
/// }
/// ```
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DefaultMenuStyle : MenuStyle {

    /// Creates a default menu style.
    ///
    /// ![DefaultMenu Example 1](default-menu-example.gif)
    ///
    /// ```
    /// struct DefaultMenuView: View {
    ///     var body: some View {
    ///         Menu("PDF") {
    ///             Button("Open in Preview", action: { })
    ///             Button("Save as PDF", action: { })
    ///         }
    ///         .menuStyle(DefaultMenuStyle())
    ///     }
    /// }
    /// ```
    ///
    public init() { }

    /// Creates a view that represents the body of a menu.
    ///
    /// - Parameter configuration: The properties of the menu.
    ///
    /// The system calls this method for each `Menu` instance in a view
    /// hierarchy where this style is the current menu style.
    public func makeBody(configuration: DefaultMenuStyle.Configuration) -> some View { }


    /// A view that represents the body of a menu.
    public typealias Body = some View
}

/// The default navigation view style.
///
/// ![DefaultNavigationView Example](default-navigation-view-example.gif)
///
/// ```
///  struct ExampleView: View {
///      struct SecondScreen: View {
///          var body: some View {
///              Text("Bananas🍌🍌")
///                  .navigationTitle("Second Screen")
///                  .navigationBarHidden(false)
///          }
///      }
///
///      var body: some View {
///          NavigationView {
///              VStack {
///                  Text("Hello Bananas🍌🍌")
///                  NavigationLink(destination: SecondScreen()) {
///                     Text("Take me to the second screen!")
///                 }
///              }
///              .navigationBarHidden(true)
///          }
///     .navigationViewStyle(DefaultNavigationViewStyle())
///      }
///  }
///
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
public struct DefaultNavigationViewStyle : NavigationViewStyle {

	/// Creates a default navigation view style.
	///
    /// ![DefaultNavigationView Example](default-navigation-view-example.gif)
    ///
    /// ```
    ///  struct ExampleView: View {
    ///      struct SecondScreen: View {
    ///          var body: some View {
    ///              Text("Bananas🍌🍌")
    ///                  .navigationTitle("Second Screen")
    ///                  .navigationBarHidden(false)
    ///          }
    ///      }
    ///
    ///      var body: some View {
    ///          NavigationView {
    ///              VStack {
    ///                  Text("Hello Bananas🍌🍌")
    ///                  NavigationLink(destination: SecondScreen()) {
    ///                     Text("Take me to the second screen!")
    ///                 }
    ///              }
    ///              .navigationBarHidden(true)
    ///          }
    ///     .navigationViewStyle(DefaultNavigationViewStyle())
    ///      }
    ///  }
    ///
    /// ```
	/// - SeeAlso: NavigationView
    public init() { }
}

/// The default picker style, based on the picker's context.
///
/// How a picker using the default picker style appears largely depends on the
/// platform and the view type in which it appears. For example, in a standard
/// view, the default picker styles by platform are:
///
/// * On iOS and watchOS the default is a wheel.
/// * On macOS, the default is a pop-up button.
/// * On tvOS, the default is a segmented control.
///
/// The default picker style may also take into account other factors — like
/// whether the picker appears in a container view — when setting the appearance
/// of a picker.
///
/// ![DefaultPickerStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/pickerstyle-wheel-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var fruits = ["Banana🍌🍌","Apple🍎🍎", "Peach🍑🍑" ]
///     @State private var selectedFruit = 0
///
///     var body: some View {
///          VStack {
///              Picker(selection: $selectedFruit, label: Text("Select Favorite Fruit")) {
///                  ForEach(0..<fruits.count) {
///                      Text(self.fruits[$0])
///                  }
///              }

///              Text("Your Favorite Fruit: \(self.fruits[selectedFruit])")
///          }
///          .pickerStyle(DefaultPickerStyle())
///     }
/// }
/// ```
/// [pickerstyle-default ->]
/// Your app can also use explicit tags to identify picker content.
///
/// ![DefaultPickerStyle Example 1](/picker-style-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var favoriteFruit: MyFruit = MyFruit.banana
///
///     var fruitName: String {
///         switch favoriteFruit{
///         case .apple:
///             return "Apple 🍎🍎"
///         case .banana:
///             return "Banana 🍌🍌"
///         case .peach:
///             return "Peach 🍑🍑"
///         }
///     }
///
///     var body: some View {
///         Text("My Favorite Fruit: \(fruitName)")
///
///         Picker("My Picker", selection: $favoriteFruit) {
///             Text("Banana 🍌🍌")
///                 .tag(MyFruit.banana)
///             Text("Apple 🍎🍎")
///                 .tag(MyFruit.apple)
///             Text("Peach 🍑🍑")
///                 .tag(MyFruit.peach)
///         }.pickerStyle(DefaultPickerStyle())
///     }
/// }
/// ```
///
/// [<-]
/// You can override a picker’s style. To apply the default style to a picker,
/// or to a view that contains pickers, use the `View/pickerStyle(_:)` modifier.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultPickerStyle : PickerStyle {

    /// Creates a default picker style.
    public init() { }
}

/// The default progress view style in the current context of the view being
/// styled.
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        ProgressView()
///            .progressViewStyle(LinearProgressViewStyle())
///            .padding(20)
///    }
/// }
/// ```
///
/// The default style represents the recommended style based on the original
/// initialization parameters of the progress view, and the progress view's
/// context within the view hierarchy.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct DefaultProgressViewStyle : ProgressViewStyle {

    /// Creates a default progress view style.
    public init() { }

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    public func makeBody(configuration: DefaultProgressViewStyle.Configuration) -> some View { }


    /// A view representing the body of a progress view.
    public typealias Body = some View
}

/// The default `TabView` style.
///
/// On iOS the default TabView looks as follows:
/// If you don't specify, a ``view/tabviewstyle(_:)``, this is what it defaults to.
///
/// ![TabView Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         TabView {
///             Text("Bananas 🍌🍌")
///                 .tabItem {
///                     Image(systemName: "1.circle.fill")
///                     Text("🍌🍌")
///                 }
///             Text("Apples 🍏🍏")
///                 .tabItem {
///                     Image(systemName: "2.square.fill")
///                     Text("🍏🍏")
///                 }
///             Text("Peaches 🍑🍑")
///                 .tabItem {
///                     Image(systemName: "3.square.fill")
///                     Text("🍑🍑")
///                 }
///         }
///         .font(.headline)
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
public struct DefaultTabViewStyle : TabViewStyle {

	/// Creates a default tab view style.
	///
	/// - SeeAlso: TabView
    ///
    /// ![TabView Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         TabView {
///             Text("Bananas 🍌🍌")
///                 .tabItem {
///                     Image(systemName: "1.circle.fill")
///                     Text("🍌🍌")
///                 }
///             Text("Apples 🍏🍏")
///                 .tabItem {
///                     Image(systemName: "2.square.fill")
///                     Text("🍏🍏")
///                 }
///             Text("Peaches 🍑🍑")
///                 .tabItem {
///                     Image(systemName: "3.square.fill")
///                     Text("🍑🍑")
///                 }
///         }
///         .tabViewStyle(DefaultTabViewStyle())
///         .font(.headline)
///     }
/// }
/// ```
///
    public init() { }
}

/// The default text field style.
///
///
/// `TextField` can be styled with the `View/textFieldStyle(_:)` modifier.
///
/// The Default TextField Style is Plain on iOS.
///
/// ![TextField Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TextField-example-1.gif)
///
///     struct ExampleView: View {
///         @State var myFruit: String = ""
///
///         var body: some View {
///             Text(myFruit)
///             TextField("Fruit", text: $myFruit)
///                 .textFieldStyle(DefaultTextFieldStyle())
///                 .padding()
///         }
///     }
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultTextFieldStyle : TextFieldStyle {

	/// Creates a default text field style.
    ///
    /// ![TextField Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TextField-example-1.gif)
    ///
    ///     struct ExampleView: View {
    ///         @State var myFruit: String = ""
    ///
    ///         var body: some View {
    ///             Text(myFruit)
    ///             TextField("Fruit", text: $myFruit)
    ///                 .textFieldStyle(DefaultTextFieldStyle())
    ///                 .padding()
    ///         }
    ///     }
    public init() { }
}

/// The default toggle style.
///
/// > If you create a toggle directly on a blank canvas, the style varies:
/// > - For the phone, pad, and watch idioms, the default toggle style is a switch.
/// > - For the Mac idiom, the default toggle style is a checkbox.
/// > - For the TV idom, the default toggle style is a button.
///
/// ![DefaultToggleStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/togglestyle-switch-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State private var status = true
///     var body: some View {
///          Toggle(isOn: $status) {
///              Text("Banana🍌🍌")
///           }
///           .toggleStyle(DefaultToggleStyle())
///           .padding()
///      }
///  }
/// ```
///
/// If you create a toggle inside a container, such as a `List`, the toggle
/// automatically uses a style appropriate to the context. To apply a different
/// style to a toggle, or to a view that contains toggles, use the
/// `View/toggleStyle(_:)` modifier. To revert a custom-styled toggle to the
///  default, use `toggleStyle(DefaultToggleStyle())`.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct DefaultToggleStyle : ToggleStyle {

    /// Creates a default toggle style.
    public init() { }

    /// Creates a view that represents the body of a toggle.
    ///
    /// The system calls this method for each `Toggle` instance in a view
    /// hierarchy where this style is the current toggle style.
    ///
    /// - Parameter configuration: The properties of the toggle.
    public func makeBody(configuration: DefaultToggleStyle.Configuration) -> some View { }


    /// A view that represents the appearance and interaction of a toggle.
    public typealias Body = some View
}

/// A view that shows or hides another content view, based on the state of a
/// disclosure control.
///
/// A disclosure group view consists of a label to identify the contents, and a
/// control to show and hide the contents. Showing the contents puts the
/// disclosure group into the "expanded" state, and hiding them makes the
/// disclosure group "collapsed".
///
/// In the following example, a disclosure group contains two toggles and
/// an embedded disclosure group. The top level disclosure group exposes its
/// expanded state with the bound property, `topLevelExpanded`. By expanding
/// the disclosure group, the user can use the toggles to update the state of
/// the `toggleStates` structure.
///
///     struct ToggleStates {
///         var oneIsOn: Bool = false
///         var twoIsOn: Bool = true
///     }
///     @State private var toggleStates = ToggleStates()
///     @State private var topExpanded: Bool = true
///
///     var body: some View {
///         DisclosureGroup("Items", isExpanded: $topExpanded) {
///             Toggle("Toggle 1", isOn: $toggleStates.oneIsOn)
///             Toggle("Toggle 2", isOn: $toggleStates.twoIsOn)
///             DisclosureGroup("Sub-items") {
///                 Text("Sub-item 1")
///             }
///         }
///     }
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DisclosureGroup<Label, Content> : View where Label : View, Content : View {

    /// Creates a disclosure group with the given label and content views.
    ///
    /// - Parameters:
    ///   - content: The content shown when the disclosure group expands.
    ///   - label: A view that describes the content of the disclosure group.
    public init(@ViewBuilder content: @escaping () -> Content, @ViewBuilder label: () -> Label) { }

    /// Creates a disclosure group with the given label and content views, and
    /// a binding to the expansion state (expanded or collapsed).
    ///
    /// - Parameters:
    ///   - isExpanded: A binding to a Boolean value that determines the group's
    ///    expansion state (expanded or collapsed).
    ///   - content: The content shown when the disclosure group expands.
    ///   - label: A view that describes the content of the disclosure group.
    public init(isExpanded: Binding<Bool>, @ViewBuilder content: @escaping () -> Content, @ViewBuilder label: () -> Label) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DisclosureGroup where Label == Text {

    /// Creates a disclosure group, using a provided localized string key to
    /// create a text view for the label.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized label of `self` that describes
    ///     the content of the disclosure group.
    ///   - content: The content shown when the disclosure group expands.
    public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: @escaping () -> Content) { }

    /// Creates a disclosure group, using a provided localized string key to
    /// create a text view for the label, and a binding to the expansion state
    /// (expanded or collapsed).
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized label of `self` that describes
    ///     the content of the disclosure group.
    ///   - isExpanded: A binding to a Boolean value that determines the group's
    ///    expansion state (expanded or collapsed).
    ///   - content: The content shown when the disclosure group expands.
    public init(_ titleKey: LocalizedStringKey, isExpanded: Binding<Bool>, @ViewBuilder content: @escaping () -> Content) { }

    /// Creates a disclosure group, using a provided string to create a
    /// text view for the label.
    ///
    /// - Parameters:
    ///   - label: A description of the content of the disclosure group.
    ///   - content: The content shown when the disclosure group expands.
    public init<S>(_ label: S, @ViewBuilder content: @escaping () -> Content) where S : StringProtocol { }

    /// Creates a disclosure group, using a provided string to create a
    /// text view for the label, and a binding to the expansion state (expanded
    /// or collapsed).
    ///
    /// - Parameters:
    ///   - label: A description of the content of the disclosure group.
    ///   - isExpanded: A binding to a Boolean value that determines the group's
    ///    expansion state (expanded or collapsed).
    ///   - content: The content shown when the disclosure group expands.
    public init<S>(_ label: S, isExpanded: Binding<Bool>, @ViewBuilder content: @escaping () -> Content) where S : StringProtocol { }
}

/// A divider that visually separates views in a stack.
///
/// The `Divider` in iOS is either a horizontal or a vertical `1pt` thick line. The color and height of a `Divider` is determined by the system, and cannot be overriden. The system is responsible for adapting the appearance of `Divider` as best appropriate for the host platform.
///
/// When contained in a stack, the divider stretches across the axis perpendicular to the axis of the stack. When not in a stack, the divider stretches across the horizontal axis.
///
/// For example, use a `Divider` in a `VStack` to create a horizontal line between vertically laid out elements:
///
/// ![Divider Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Divider-example-1.png)
///
/// ```
/// struct ExampleView: View {
///   var body: some View {
///     VStack {
///       Text("My Awesome Book")
///
///       Divider()
///
///       Text("My Name")
///     }
///   }
/// }
/// ```
///
/// Or use a `Divider` in a `HStack` to create a vertical line between horizontally laid out elements:
///
/// ![Divider Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Divider-example-2.png)
///
/// ```
/// struct ExampleView: View {
///   var body: some View {
///     HStack {
///       Text("This is a line of text")
///
///       Divider()
///
///       Text("This is an unrelated line of text")
///     }
///   }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Divider : View {

	/// Creates a new `Divider`.
    public init() { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A scene that enables support for opening, creating, and saving documents.
///
/// `DocumentGroup` provides a default scene for basic file management.
///
/// ![Document Group](document-group.gif)
///
/// ```
/// import UniformTypeIdentifiers
///
/// @main
/// struct ExampleApp: App {
///     var body: some Scene {
///         DocumentGroup(newDocument: TextFile()) { file in
///             ExampleView(document: file.$document)
///         }
///     }
/// }
///
/// struct ExampleView: View {
///     @Binding var document: TextFile
///
///     var body: some View {
///         TextEditor(text: $document.text)
///     }
/// }
///
/// struct TextFile: FileDocument {
///     //  Support only plain text
///     static var readableContentTypes = [UTType.plainText]
///
///     // Create an empty document
///     var text = ""
///
///     //  Create a document
///     init(initialText: String = "") {
///         text = initialText
///     }
///
///     // Loads data has been saved previously. See the ReadConfiguration documentation for more
///     init(configuration: ReadConfiguration) throws {
///         guard let data = configuration.file.regularFileContents,
///             let string = String(data: data, encoding: .utf8)
///         else {
///             throw CocoaError(.fileReadCorruptFile)
///         }
///         text = string
///     }
///
///     // The saving function
///     func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
///         let data = text.data(using: .utf8)!
///         return .init(regularFileWithContents: data)
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DocumentGroup<Document, Content> : Scene where Content : View {

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from primitive scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's `SwiftUI/Scene/Body-swift.associatedtype`
    /// associated type based on the contents of the `body` property.
    public var body: some Scene { get }

    /// The type of scene that represents the body of this scene.
    ///
    /// When you create a custom scene, Swift infers this type from your
    /// implementation of the required `SwiftUI/Scene/body-swift.property`
    /// property.
    public typealias Body = some Scene
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DocumentGroup where Document : FileDocument {

    /// Creates a document group that is able to create and edit file documents.
    ///
    /// - Parameters:
    ///   - newDocument: The initial document used when the user creates
    ///     a new document.
    ///   - editor: The editing UI for the provided document.
    public init(newDocument: @autoclosure @escaping () -> Document, @ViewBuilder editor: @escaping (FileDocumentConfiguration<Document>) -> Content) { }

    /// Creates a document group that is able to view file documents.
    ///
    /// - Parameters:
    ///   - documentType: The type of document being viewed.
    ///   - viewer: The viewing UI for the provided document.
    ///
    /// - See Also: `CFBundleTypeRole` with a value of "Viewer"
    public init(viewing documentType: Document.Type, @ViewBuilder viewer: @escaping (FileDocumentConfiguration<Document>) -> Content) { }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DocumentGroup where Document : ReferenceFileDocument {

    /// Creates a document group that is able to create and edit reference file
    /// documents.
    ///
    /// - Parameters:
    ///   - newDocument: The initial document used when the user creates
    ///     a new document. The argument should create a new instance, such that
    ///     a new document is created on each invocation of the closure.
    ///   - editor: The editing UI for the provided document.
    ///
    /// The current document for a given editor instance is also provided as an
    /// environment object for its subhierarchy.
    ///
    /// Undo support is not automatically provided for this construction of
    /// a `DocumentGroup`, and any updates to the document by the editor view
    /// hierarchy are expected to register undo operations when appropriate.
    public init(newDocument: @escaping () -> Document, @ViewBuilder editor: @escaping (ReferenceFileDocumentConfiguration<Document>) -> Content) { }

    /// Creates a document group that is able to view reference file documents.
    ///
    /// - Parameters:
    ///   - documentType: The type of document being viewed.
    ///   - viewer: The viewing UI for the provided document.
    ///
    /// The current document for a given editor instance is also provided as an
    /// environment object for its subhierarchy.
    ///
    /// - See Also: `CFBundleTypeRole` with a value of "Viewer"
    public init(viewing documentType: Document.Type, @ViewBuilder viewer: @escaping (ReferenceFileDocumentConfiguration<Document>) -> Content) { }
}

/// A navigation view style represented by a primary view stack that
/// navigates to a detail view.
///
/// ![NavigationView Example 9](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-9.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///         }
///         .navigationViewStyle(DoubleColumnNavigationViewStyle())
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
@available(watchOS, unavailable)
public struct DoubleColumnNavigationViewStyle : NavigationViewStyle {

	/// Creates a double column navigation view style.
  ///
  /// ![NavigationView Example 9](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-9.png)
  ///
  /// ```
  /// struct ExampleView: View {
  ///     var body: some View {
  ///         NavigationView {
  ///             Text("Hello Bananas🍌🍌")
  ///         }
  ///         .navigationViewStyle(DoubleColumnNavigationViewStyle())
  ///     }
  /// }
  /// ```
    public init() { }
}

/// A dragging motion that invokes an action as the drag-event sequence changes.
///
/// To recognize a drag gesture on a view, create and configure the gesture, and
/// then add it to the view using the `View/gesture(_:including:)` modifier.
///
/// Add a drag gesture to a `Circle` and change its color while the user
/// performs the drag gesture:
///
/// ![DragGesture Example 1](drag-gesture-example.gif)
///
/// ```
/// struct DragGestureView: View {
///     @State private var location: CGPoint = CGPoint(x: 50, y: 50);
///     @State var isDragging = false
///
///     var simpleDrag: some Gesture {
///         DragGesture()
///             .onChanged { value in
///                 self.location = value.location
///                self.isDragging = true
///
///             }
///             .onEnded{_ in self.isDragging = false}
///     }
///
///     var body: some View {
///         Circle()
///             .fill(self.isDragging ? Color.red : Color.yellow)
///             .frame(width: 100, height: 100)
///             .position(location)
///             .gesture(simpleDrag)
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
public struct DragGesture : Gesture {

    /// The attributes of a drag gesture.
    public struct Value : Equatable {

        /// The time associated with the drag gesture's current event.
        public var time: Date

        /// The location of the drag gesture's current event.
        public var location: CGPoint

        /// The location of the drag gesture's first event.
        public var startLocation: CGPoint

        /// The total translation from the start of the drag gesture to the
        /// current event of the drag gesture.
        ///
        /// This is equivalent to `location.{x,y} - startLocation.{x,y}`.
        public var translation: CGSize { get }

        /// A prediction, based on the current drag velocity, of where the final
        /// location will be if dragging stopped now.
        public var predictedEndLocation: CGPoint { get }

        /// A prediction, based on the current drag velocity, of what the final
        /// translation will be if dragging stopped now.
        public var predictedEndTranslation: CGSize { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: DragGesture.Value, b: DragGesture.Value) -> Bool { }
    }

    /// The minimum dragging distance before the gesture succeeds.
    public var minimumDistance: CGFloat

    /// The coordinate space in which to receive location values.
    public var coordinateSpace: CoordinateSpace

    /// Creates a dragging gesture with the minimum dragging distance before the
    /// gesture succeeds and the coordinate space of the gesture's location.
    ///
    /// - Parameters:
    ///   - minimumDistance: The minimum dragging distance for the gesture to
    ///     succeed.
    ///   - coordinateSpace: The coordinate space of the dragging gesture's
    ///     location.
    public init(minimumDistance: CGFloat = 10, coordinateSpace: CoordinateSpace = .local) { }

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

/// An interface to easily perform drag & drop operations.
///
/// The `DropDelegate` protocol offers functionality to customize drag and drop behaviors. It is preffered over ``View/onDrop(of:isTargeted:perform)`` view modifier when your drop behavior requires non-standard implementations.
///
/// ``DropDelegate`` heavily utalizes `NSItemProvider`, which provides information about the dragged data.
///
/// ### Setup
/// `DropDelegate` has one required implementation and four optional implementations.
///
/// Required:
/// - `DropDelegate/performDrop(info:)` specifies the behavior for your drop.
///
/// Optional:
/// - `DropDelegate/validateDrop(info:)-954f7` validates if a drop can be made.
/// - `DropDelegate/dropEntered(info:)-525fa` provides custom behavior when an object is dragged over the `onDrop` view.
/// - `DropDelegate/dropExited(info:)-3d540` provides custom behavior when an object is dragged off of the `onDrop` view.
/// - `DropDelegate/dropUpdated(info:)-72cd3` provides custom behavior when the drop is updated.
///
/// ### Creating a simple Drag & Drop
/// #### Create a draggable ``View``
/// Make a view draggable with the ``View/.onDrag(_:)`` modifier.
///
/// Use `NSItemProvider` to define the specific data dragged from that view.
///
/// ```
/// //  Text to drag
/// Text(text)
///     .font(.title)
///     .onDrag{ return NSItemProvider(object: "🍌🍌" as NSString) }
/// ```
///
/// #### Creating a drop `View`
/// Use `onDrop` to create a view that accepts "drops" from dragged data. There are three versions of the `onDrop` modifier:
///
/// - `View/onDrop(of:isTargeted:perform)-bae65` is the simplest implementation. Specify a closure to execute when content is dropped.
/// - `View/onDrop(of:isTargeted:perform)-55379` is similar to the former, but the closure also provides information about the drop location.
/// - `View/onDrop(of:delegate)-a3cfb` requires a `DropDelegate` and is the most versatile.
///
/// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var text: String = "🍌🍌"
///
///     var body: some View {
///         HStack {
///             //  Text to drag
///             Text(text)
///                 .font(.title)
///                 .onDrag{ return NSItemProvider(object: self.text as NSItemProviderWriting) }
///
///             //  Area to drop
///             RoundedRectangle(cornerRadius: 10)
///                 .frame(width: 150, height: 150)
///                 .onDrop(of: ["text"], isTargeted: nil, perform: { _ in
///                     self.text = "Dropped My Bananas 🍌🍌!"
///                     return true
///                 })
///         }
///     }
/// }
/// ```
///
/// #### Conforming to DropDelegate
/// Implement `DropDelegate/performDrop(info:)` to create a structure that conforms to `DropDelegate`.
///
/// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var text: String = "🍌🍌"
///
///     var body: some View {
///         HStack {
///             //  Text to drag
///             Text(text)
///                 .font(.title)
///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
///
///             //  Area to drop
///             RoundedRectangle(cornerRadius: 10)
///                 .frame(width: 150, height: 150)
///                 .onDrop(of: ["text"], delegate: MyDropDelegate(text: $text))
///         }
///     }
/// }
///
/// struct MyDropDelegate: DropDelegate {
///     @Binding var text: String
///
///     func performDrop(info: DropInfo) -> Bool {
///         self.text = "Dropped My Bananas 🍌🍌!"
///         return true
///     }
/// }
/// ```
///
/// ### Using `DropInfo` for custom logic
/// `DropInfo` provides information about the drop and is used to create custom drop behaviors.
///
/// For example, say your user drags & drops `NSString` data. Use the `DropInfo/itemproviders(for:)-7f580` to get an array of `NSItemProvider` data (recall all dragged data arrives in this format).
///
/// Next, use `NSItemProvider`'s property `loadItem` to extract an `NSSecureCoding` from your dragged data.
///
/// Finally, cast your `NSSecureCoding` data to the more Swift-friendly `Data` object. From here your program can decode that data into a string and run any custom behaviors from that string.
///
/// The view in the example below is conditionally colored depending on the dragged string.
///
/// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-2.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var backgroundColor: Color = .black
///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
///
///     var body: some View {
///         VStack {
///             HStack {
///                 ForEach(self.fruits, id: \.self, content: { fruit in
///                     Text(fruit)
///                         .font(.title)
///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
///                 })
///             }
///
///             HStack {
///                 RoundedRectangle(cornerRadius: 10)
///                     .fill(backgroundColor)
///                     .frame(width: 150, height: 150)
///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
///             }
///         }
///
///     }
/// }
///
/// struct MyDropDelegate: DropDelegate {
///     @Binding var color: Color
///
///     //  This function is executed when the user "drops" their object
///     func performDrop(info: DropInfo) -> Bool {
///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
///         if let item = info.itemProviders(for: ["public.text"]).first {
///             //  Load the item
///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
///                 //  Cast NSSecureCoding to Ddata
///                 if let data = text as? Data {
///                     //  Extract string from data
///                     let inputStr = String(decoding: data, as: UTF8.self)
///
///                     //  Conditionally change color given text string
///                     if inputStr == "🍌🍌" {
///                         self.color = .yellow
///                     } else if inputStr == "🍏🍏" {
///                         self.color = .green
///                     } else if inputStr == "🍑🍑" {
///                         self.color = .pink
///                     } else {
///                         self.color = .gray
///                     }
///                 }
///             }
///         } else {
///             //  If no text was received in our drop, return false
///             return false
///         }
///
///         return true
///     }
/// }
/// ```
///
/// ### Fully Featured `DropDelegate`
/// Utalize `DropDelegate`s optional functions to provide additional behavior.
///
/// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-3.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var backgroundColor: Color = .black
///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
///
///     var body: some View {
///         VStack {
///             HStack {
///                 ForEach(self.fruits, id: \.self, content: { fruit in
///                     Text(fruit)
///                         .font(.title)
///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
///                 })
///             }
///
///             HStack {
///                 RoundedRectangle(cornerRadius: 10)
///                     .fill(backgroundColor)
///                     .frame(width: 150, height: 150)
///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
///             }
///         }
///
///     }
/// }
///
/// struct MyDropDelegate: DropDelegate {
///     @Binding var color: Color
///
///     //  Drop entered called
///     func dropEntered(info: DropInfo) {
///         ///  Change color if color was previously black
///         self.color = (self.color == .black) ? .gray : self.color
///     }
///
///     //  Drop entered called
///     func dropExited(info: DropInfo) {
///         self.color = .init(white: 0.40)
///     }
///
///     //  Drop has been updated
///     func dropUpdated(info: DropInfo) -> DropProposal? {
///         ///  Don't allow more items to be dropped if a Banana was dropped
///         if self.color == .yellow {
///             return DropProposal(operation: .forbidden)
///         } else {
///             return nil
///         }
///     }
///
///     //  This function is executed when the user "drops" their object
///     func performDrop(info: DropInfo) -> Bool {
///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
///         if let item = info.itemProviders(for: ["public.text"]).first {
///             //  Load the item
///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
///                 //  Cast NSSecureCoding to Ddata
///                 if let data = text as? Data {
///                     //  Extract string from data
///                     let inputStr = String(decoding: data, as: UTF8.self)
///
///                     //  Conditionally change color given text string
///                     if inputStr == "🍌🍌" {
///                         self.color = .yellow
///                     } else if inputStr == "🍏🍏" {
///                         self.color = .green
///                     } else if inputStr == "🍑🍑" {
///                         self.color = .pink
///                     } else {
///                         self.color = .gray
///                     }
///                 }
///             }
///         } else {
///             //  If no text was received in our drop, return false
///             return false
///         }
///
///         return true
///     }
/// }
/// ```
///
/// This example uses `DropDelegate/dropUpdated(info:)-72cd3` to prevent fruits from being dropped if the background is yellow.
///
/// The example uses `DropDelegate/dropEntered(info:)-525fa` to change the color the first time a user drags over the drop zone.
///
/// Finally, when a user drags out of the view, `DropDelegate/dropExited(info:)-3d540` changes the background color to a dark gray.
///
/// Note: if the user deselects their dragged object while over the drop zone, `DropDelegate/dropExited(info:)-3d540` will **not** be called. `DropDelegate/dropExited(info:)-3d540` is only called when the user explicitly drags their dragged object **out** of the drop zone.
///
/// *Bug*: On iOS `DropInfo` provides its location in global coordinates. It should provide location in local coordinates.
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol DropDelegate{ }
extension DropDelegate {

    /// Validates a drop.
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var backgroundColor: Color = .black
    ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
    ///
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 ForEach(self.fruits, id: \.self, content: { fruit in
    ///                     Text(fruit)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
    ///                 })
    ///             }
    ///
    ///             HStack {
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .fill(backgroundColor)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
    ///             }
    ///         }
    ///
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var color: Color
    ///
    ///     //  Validates the drop
    ///     func validateDrop(info: DropInfo) -> Bool {
    ///         //  This function will fail, because the URI is "public.text" not "public.file-url"
    ///         if info.hasItemsConforming(to: ["public.image"]) {
    ///             return true
    ///         } else {
    ///             self.color = .red
    ///             return false
    ///         }
    ///     }
    ///
    ///     //  This function is executed when the user "drops" their object
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
    ///         if let item = info.itemProviders(for: ["public.text"]).first {
    ///             //  Load the item
    ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                 //  Cast NSSecureCoding to Ddata
    ///                 if let data = text as? Data {
    ///                     //  Extract string from data
    ///                     let inputStr = String(decoding: data, as: UTF8.self)
    ///
    ///                     //  Conditionally change color given text string
    ///                     if inputStr == "🍌🍌" {
    ///                         self.color = .yellow
    ///                     } else if inputStr == "🍏🍏" {
    ///                         self.color = .green
    ///                     } else if inputStr == "🍑🍑" {
    ///                         self.color = .pink
    ///                     } else {
    ///                         self.color = .gray
    ///                     }
    ///                 }
    ///             }
    ///         } else {
    ///             //  If no text was received in our drop, return false
    ///             return false
    ///         }
    ///
    ///         return true
    ///     }
    /// }
    /// ```
    func validateDrop(info: DropInfo) -> Bool { }

    /// Specifies the behavior of a drop.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-2.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var backgroundColor: Color = .black
    ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
    ///
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 ForEach(self.fruits, id: \.self, content: { fruit in
    ///                     Text(fruit)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
    ///                 })
    ///             }
    ///
    ///             HStack {
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .fill(backgroundColor)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
    ///             }
    ///         }
    ///
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var color: Color
    ///
    ///     //  This function is executed when the user "drops" their object
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
    ///         if let item = info.itemProviders(for: ["public.text"]).first {
    ///             //  Load the item
    ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                 //  Cast NSSecureCoding to Ddata
    ///                 if let data = text as? Data {
    ///                     //  Extract string from data
    ///                     let inputStr = String(decoding: data, as: UTF8.self)
    ///
    ///                     //  Conditionally change color given text string
    ///                     if inputStr == "🍌🍌" {
    ///                         self.color = .yellow
    ///                     } else if inputStr == "🍏🍏" {
    ///                         self.color = .green
    ///                     } else if inputStr == "🍑🍑" {
    ///                         self.color = .pink
    ///                     } else {
    ///                         self.color = .gray
    ///                     }
    ///                 }
    ///             }
    ///         } else {
    ///             //  If no text was received in our drop, return false
    ///             return false
    ///         }
    ///
    ///         return true
    ///     }
    /// }
    /// ```
    func performDrop(info: DropInfo) -> Bool { }

    /// Provide custom behavior when an object is dragged over the `onDrop` view.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-4.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var backgroundColor: Color = .black
    ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
    ///
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 ForEach(self.fruits, id: \.self, content: { fruit in
    ///                     Text(fruit)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
    ///                 })
    ///             }
    ///
    ///             HStack {
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .fill(backgroundColor)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
    ///             }
    ///         }
    ///
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var color: Color
    ///
    ///     //  Drop entered called
    ///     func dropEntered(info: DropInfo) {
    ///         //  Change color if color was previously black
    ///         self.color = (self.color == .black) ? .gray : self.color
    ///     }
    ///
    ///     //  This function is executed when the user "drops" their object
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
    ///         if let item = info.itemProviders(for: ["public.text"]).first {
    ///             //  Load the item
    ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                 //  Cast NSSecureCoding to Ddata
    ///                 if let data = text as? Data {
    ///                     //  Extract string from data
    ///                     let inputStr = String(decoding: data, as: UTF8.self)
    ///
    ///                     //  Conditionally change color given text string
    ///                     if inputStr == "🍌🍌" {
    ///                         self.color = .yellow
    ///                     } else if inputStr == "🍏🍏" {
    ///                         self.color = .green
    ///                     } else if inputStr == "🍑🍑" {
    ///                         self.color = .pink
    ///                     } else {
    ///                         self.color = .gray
    ///                     }
    ///                 }
    ///             }
    ///         } else {
    ///             //  If no text was received in our drop, return false
    ///             return false
    ///         }
    ///
    ///         return true
    ///     }
    /// }
    /// ```
    func dropEntered(info: DropInfo) { }

    /// Provide custom behavior when the drop is updated.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-5.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var backgroundColor: Color = .black
    ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
    ///
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 ForEach(self.fruits, id: \.self, content: { fruit in
    ///                     Text(fruit)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
    ///                 })
    ///             }
    ///
    ///             HStack {
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .fill(backgroundColor)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
    ///             }
    ///         }
    ///
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var color: Color
    ///
    ///     //  Drop has been updated
    ///     func dropUpdated(info: DropInfo) -> DropProposal? {
    ///         //  Don't allow more items to be dropped if a Banana was dropped
    ///         if self.color == .yellow {
    ///             return DropProposal(operation: .forbidden)
    ///         } else {
    ///             return nil
    ///         }
    ///     }
    ///
    ///     //  This function is executed when the user "drops" their object
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
    ///         if let item = info.itemProviders(for: ["public.text"]).first {
    ///             //  Load the item
    ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                 //  Cast NSSecureCoding to Ddata
    ///                 if let data = text as? Data {
    ///                     //  Extract string from data
    ///                     let inputStr = String(decoding: data, as: UTF8.self)
    ///
    ///                     //  Conditionally change color given text string
    ///                     if inputStr == "🍌🍌" {
    ///                         self.color = .yellow
    ///                     } else if inputStr == "🍏🍏" {
    ///                         self.color = .green
    ///                     } else if inputStr == "🍑🍑" {
    ///                         self.color = .pink
    ///                     } else {
    ///                         self.color = .gray
    ///                     }
    ///                 }
    ///             }
    ///         } else {
    ///             //  If no text was received in our drop, return false
    ///             return false
    ///         }
    ///
    ///         return true
    ///     }
    /// }
    /// ```
    func dropUpdated(info: DropInfo) -> DropProposal? { }

    /// Provide custom behavior when an object is dragged off of the `onDrop` view.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-6.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var backgroundColor: Color = .black
    ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
    ///
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 ForEach(self.fruits, id: \.self, content: { fruit in
    ///                     Text(fruit)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
    ///                 })
    ///             }
    ///
    ///             HStack {
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .fill(backgroundColor)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
    ///             }
    ///         }
    ///
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var color: Color
    ///
    ///     // Drop entered called
    ///     func dropExited(info: DropInfo) {
    ///         self.color = .init(white: 0.40)
    ///     }
    ///
    ///     // This function is executed when the user "drops" their object
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         // Check if there's an array of items with the URI "public.text" in the DropInfo
    ///         if let item = info.itemProviders(for: ["public.text"]).first {
    ///             // Load the item
    ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                 // Cast NSSecureCoding to Ddata
    ///                 if let data = text as? Data {
    ///                     // Extract string from data
    ///                     let inputStr = String(decoding: data, as: UTF8.self)
    ///
    ///                     //  Conditionally change color given text string
    ///                     if inputStr == "🍌🍌" {
    ///                         self.color = .yellow
    ///                     } else if inputStr == "🍏🍏" {
    ///                         self.color = .green
    ///                     } else if inputStr == "🍑🍑" {
    ///                         self.color = .pink
    ///                     } else {
    ///                         self.color = .gray
    ///                     }
    ///                 }
    ///             }
    ///         } else {
    ///             // If no text was received in our drop, return false
    ///             return false
    ///         }
    ///
    ///         return true
    ///     }
    /// }
    /// ```
    func dropExited(info: DropInfo) { }
}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DropDelegate {

      /// Validates a drop.
      ///
      /// ```
      /// struct ContentView: View {
      ///     @State var backgroundColor: Color = .black
      ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
      ///
      ///     var body: some View {
      ///         VStack {
      ///             HStack {
      ///                 ForEach(self.fruits, id: \.self, content: { fruit in
      ///                     Text(fruit)
      ///                         .font(.title)
      ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
      ///                 })
      ///             }
      ///
      ///             HStack {
      ///                 RoundedRectangle(cornerRadius: 10)
      ///                     .fill(backgroundColor)
      ///                     .frame(width: 150, height: 150)
      ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
      ///             }
      ///         }
      ///
      ///     }
      /// }
      ///
      /// struct MyDropDelegate: DropDelegate {
      ///     @Binding var color: Color
      ///
      ///     // Validates the drop
      ///     func validateDrop(info: DropInfo) -> Bool {
      ///         // This function will fail, because the URI is "public.text" not "public.file-url"
      ///         if info.hasItemsConforming(to: ["public.image"]) {
      ///             return true
      ///         } else {
      ///             self.color = .red
      ///             return false
      ///         }
      ///     }
      ///
      ///     // This function is executed when the user "drops" their object
      ///     func performDrop(info: DropInfo) -> Bool {
      ///         // Check if there's an array of items with the URI "public.text" in the DropInfo
      ///         if let item = info.itemProviders(for: ["public.text"]).first {
      ///             // Load the item
      ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
      ///                 // Cast NSSecureCoding to Ddata
      ///                 if let data = text as? Data {
      ///                     // Extract string from data
      ///                     let inputStr = String(decoding: data, as: UTF8.self)
      ///
      ///                     // Conditionally change color given text string
      ///                     if inputStr == "🍌🍌" {
      ///                         self.color = .yellow
      ///                     } else if inputStr == "🍏🍏" {
      ///                         self.color = .green
      ///                     } else if inputStr == "🍑🍑" {
      ///                         self.color = .pink
      ///                     } else {
      ///                         self.color = .gray
      ///                     }
      ///                 }
      ///             }
      ///         } else {
      ///             // If no text was received in our drop, return false
      ///             return false
      ///         }
      ///
      ///         return true
      ///     }
      /// }
      /// ```
      public func validateDrop(info: DropInfo) -> Bool { }

      /// Specifies the behavior of a drop.
      ///
      /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-2.gif)
      ///
      /// ```
      /// struct ExampleView: View {
      ///     @State var backgroundColor: Color = .black
      ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
      ///
      ///     var body: some View {
      ///         VStack {
      ///             HStack {
      ///                 ForEach(self.fruits, id: \.self, content: { fruit in
      ///                     Text(fruit)
      ///                         .font(.title)
      ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
      ///                 })
      ///             }
      ///
      ///             HStack {
      ///                 RoundedRectangle(cornerRadius: 10)
      ///                     .fill(backgroundColor)
      ///                     .frame(width: 150, height: 150)
      ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
      ///             }
      ///         }
      ///
      ///     }
      /// }
      ///
      /// struct MyDropDelegate: DropDelegate {
      ///     @Binding var color: Color
      ///
      ///     // This function is executed when the user "drops" their object
      ///     func performDrop(info: DropInfo) -> Bool {
      ///         // Check if there's an array of items with the URI "public.text" in the DropInfo
      ///         if let item = info.itemProviders(for: ["public.text"]).first {
      ///             // Load the item
      ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
      ///                 // Cast NSSecureCoding to Ddata
      ///                 if let data = text as? Data {
      ///                     // Extract string from data
      ///                     let inputStr = String(decoding: data, as: UTF8.self)
      ///
      ///                     // Conditionally change color given text string
      ///                     if inputStr == "🍌🍌" {
      ///                         self.color = .yellow
      ///                     } else if inputStr == "🍏🍏" {
      ///                         self.color = .green
      ///                     } else if inputStr == "🍑🍑" {
      ///                         self.color = .pink
      ///                     } else {
      ///                         self.color = .gray
      ///                     }
      ///                 }
      ///             }
      ///         } else {
      ///             // If no text was received in our drop, return false
      ///             return false
      ///         }
      ///
      ///         return true
      ///     }
      /// }
      /// ```
      public func performDrop(info: DropInfo) -> Bool { }

      /// Provide custom behavior when an object is dragged over the `onDrop` view.
      ///
      /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-4.gif)
      ///
      /// ```
      /// struct ContentView: View {
      ///     @State var backgroundColor: Color = .black
      ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
      ///
      ///     var body: some View {
      ///         VStack {
      ///             HStack {
      ///                 ForEach(self.fruits, id: \.self, content: { fruit in
      ///                     Text(fruit)
      ///                         .font(.title)
      ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
      ///                 })
      ///             }
      ///
      ///             HStack {
      ///                 RoundedRectangle(cornerRadius: 10)
      ///                     .fill(backgroundColor)
      ///                     .frame(width: 150, height: 150)
      ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
      ///             }
      ///         }
      ///
      ///     }
      /// }
      ///
      /// struct MyDropDelegate: DropDelegate {
      ///     @Binding var color: Color
      ///
      ///     // Drop entered called
      ///     func dropEntered(info: DropInfo) {
      ///         // Change color if color was previously black
      ///         self.color = (self.color == .black) ? .gray : self.color
      ///     }
      ///
      ///     // This function is executed when the user "drops" their object
      ///     func performDrop(info: DropInfo) -> Bool {
      ///         // Check if there's an array of items with the URI "public.text" in the DropInfo
      ///         if let item = info.itemProviders(for: ["public.text"]).first {
      ///             // Load the item
      ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
      ///                 // Cast NSSecureCoding to Ddata
      ///                 if let data = text as? Data {
      ///                     //  Extract string from data
      ///                     let inputStr = String(decoding: data, as: UTF8.self)
      ///
      ///                     // Conditionally change color given text string
      ///                     if inputStr == "🍌🍌" {
      ///                         self.color = .yellow
      ///                     } else if inputStr == "🍏🍏" {
      ///                         self.color = .green
      ///                     } else if inputStr == "🍑🍑" {
      ///                         self.color = .pink
      ///                     } else {
      ///                         self.color = .gray
      ///                     }
      ///                 }
      ///             }
      ///         } else {
      ///             // If no text was received in our drop, return false
      ///             return false
      ///         }
      ///
      ///         return true
      ///     }
      /// }
      /// ```
      public func dropEntered(info: DropInfo) { }

      /// Provide custom behavior when the drop is updated.
      ///
      /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-5.gif)
      ///
      /// ```
      /// struct ContentView: View {
      ///     @State var backgroundColor: Color = .black
      ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
      ///
      ///     var body: some View {
      ///         VStack {
      ///             HStack {
      ///                 ForEach(self.fruits, id: \.self, content: { fruit in
      ///                     Text(fruit)
      ///                         .font(.title)
      ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
      ///                 })
      ///             }
      ///
      ///             HStack {
      ///                 RoundedRectangle(cornerRadius: 10)
      ///                     .fill(backgroundColor)
      ///                     .frame(width: 150, height: 150)
      ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
      ///             }
      ///         }
      ///
      ///     }
      /// }
      ///
      /// struct MyDropDelegate: DropDelegate {
      ///     @Binding var color: Color
      ///
      ///     //  Drop has been updated
      ///     func dropUpdated(info: DropInfo) -> DropProposal? {
      ///         // Don't allow more items to be dropped if a Banana was dropped
      ///         if self.color == .yellow {
      ///             return DropProposal(operation: .forbidden)
      ///         } else {
      ///             return nil
      ///         }
      ///     }
      ///
      ///     // This function is executed when the user "drops" their object
      ///     func performDrop(info: DropInfo) -> Bool {
      ///         // Check if there's an array of items with the URI "public.text" in the DropInfo
      ///         if let item = info.itemProviders(for: ["public.text"]).first {
      ///             //  Load the item
      ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
      ///                 //  Cast NSSecureCoding to Ddata
      ///                 if let data = text as? Data {
      ///                     //  Extract string from data
      ///                     let inputStr = String(decoding: data, as: UTF8.self)
      ///
      ///                     // Conditionally change color given text string
      ///                     if inputStr == "🍌🍌" {
      ///                         self.color = .yellow
      ///                     } else if inputStr == "🍏🍏" {
      ///                         self.color = .green
      ///                     } else if inputStr == "🍑🍑" {
      ///                         self.color = .pink
      ///                     } else {
      ///                         self.color = .gray
      ///                     }
      ///                 }
      ///             }
      ///         } else {
      ///             //  If no text was received in our drop, return false
      ///             return false
      ///         }
      ///
      ///         return true
      ///     }
      /// }
      /// ```
      public func dropUpdated(info: DropInfo) -> DropProposal? { }

      /// Provide custom behavior when an object is dragged off of the `onDrop` view.
      ///
      /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-6.gif)
      ///
      /// ```
      /// struct ContentView: View {
      ///     @State var backgroundColor: Color = .black
      ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
      ///
      ///     var body: some View {
      ///         VStack {
      ///             HStack {
      ///                 ForEach(self.fruits, id: \.self, content: { fruit in
      ///                     Text(fruit)
      ///                         .font(.title)
      ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
      ///                 })
      ///             }
      ///
      ///             HStack {
      ///                 RoundedRectangle(cornerRadius: 10)
      ///                     .fill(backgroundColor)
      ///                     .frame(width: 150, height: 150)
      ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
      ///             }
      ///         }
      ///
      ///     }
      /// }
      ///
      /// struct MyDropDelegate: DropDelegate {
      ///     @Binding var color: Color
      ///
      ///     //  Drop entered called
      ///     func dropExited(info: DropInfo) {
      ///         self.color = .init(white: 0.40)
      ///     }
      ///
      ///     //  This function is executed when the user "drops" their object
      ///     func performDrop(info: DropInfo) -> Bool {
      ///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
      ///         if let item = info.itemProviders(for: ["public.text"]).first {
      ///             //  Load the item
      ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
      ///                 //  Cast NSSecureCoding to Ddata
      ///                 if let data = text as? Data {
      ///                     //  Extract string from data
      ///                     let inputStr = String(decoding: data, as: UTF8.self)
      ///
      ///                     //  Conditionally change color given text string
      ///                     if inputStr == "🍌🍌" {
      ///                         self.color = .yellow
      ///                     } else if inputStr == "🍏🍏" {
      ///                         self.color = .green
      ///                     } else if inputStr == "🍑🍑" {
      ///                         self.color = .pink
      ///                     } else {
      ///                         self.color = .gray
      ///                     }
      ///                 }
      ///             }
      ///         } else {
      ///             //  If no text was received in our drop, return false
      ///             return false
      ///         }
      ///
      ///         return true
      ///     }
      /// }
      /// ```
      public func dropExited(info: DropInfo) { }
}

/// The current state of a drop.
///
/// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var text: String = "🍌🍌"
///
///     var body: some View {
///         HStack {
///             // Text to drag
///             Text(text)
///                 .font(.title)
///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
///
///             // Area to drop
///             RoundedRectangle(cornerRadius: 10)
///                 .frame(width: 150, height: 150)
///                 .onDrop(of: ["text"], delegate: MyDropDelegate(text: $text))
///         }
///     }
/// }
///
/// struct MyDropDelegate: DropDelegate {
///     @Binding var text: String
///
///     func performDrop(info: DropInfo) -> Bool {
///         self.text = "Dropped My Bananas 🍌🍌!"
///         return true
///     }
/// }
/// ```
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DropInfo {

    /// The location of the drag in the coordinate space of the drop view.
    public var location: CGPoint { get }

    /// Indicates whether at least one item conforms to at least one of the
    /// specified uniform type identifiers.
    ///
    /// - Parameter contentTypes: The uniform type identifiers to query for.
    /// - Returns: Whether at least one item conforms to one of `contentTypes`.
    @available(iOS 14.0, macOS 11.0, *)
    public func hasItemsConforming(to contentTypes: [UTType]) -> Bool { }

    /// Finds item providers that conform to at least one of the specified
    /// uniform type identifiers.
    ///
    /// This function is only valid during the `performDrop()` action.
    ///
    /// - Parameter contentTypes: The uniform type identifiers to query for.
    /// - Returns: The item providers that conforms to `contentTypes`.
    @available(iOS 14.0, macOS 11.0, *)
    public func itemProviders(for contentTypes: [UTType]) -> [NSItemProvider] { }
}

@available(iOS, introduced: 13.4, deprecated: 100000.0, message: "Provide `UTType`s as the `types` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Provide `UTType`s as the `types` instead.")
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DropInfo {

    /// Returns whether at least one item conforms to at least one of the
    /// specified uniform type identifiers.
    public func hasItemsConforming(to types: [String]) -> Bool { }

    /// Returns an Array of items that each conform to at least one of the
    /// specified uniform type identifiers.
    ///
    /// This function is only valid during the performDrop() action.
    public func itemProviders(for types: [String]) -> [NSItemProvider] { }
}

/// Operation types that determine how a drag and drop session resolves when the
/// user drops a drag item.
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public enum DropOperation {

    /// Cancel the drag operation and transfer no data.
    case cancel

    /// The drop activity is not allowed at this time or location.
    case forbidden

    /// Copy the data to the modified view.
    case copy

    /// Move the data represented by the drag items instead of copying it.
    case move

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: DropOperation, b: DropOperation) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DropOperation : Equatable {
}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension DropOperation : Hashable {
}

/// The behavior of a drop.
@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DropProposal {

    /// The drop operation that the drop proposes to perform.
    public let operation: DropOperation

    /// Creates a drop proposal based on the provided operation.
    ///
    /// - Parameter operation: The drop operation to associate with the proposal.
    ///
    /// - SeeAlso: DropOperation
    public init(operation: DropOperation) { }
}

/// An interface for a stored variable that updates an external property of a
/// view.
///
/// This protocol is the one that all the data property wrappers implement:
/// - ``State``
/// - ``Binding``
/// - ``ObservedObject``
/// - ``EnvironmentObject``
/// - ``Environment``
/// - ``FetchRequest``
/// - ``GestureState``
///
/// The view gives values to these properties prior to recomputing the view's
/// `View/body-swift.property`.
///
/// You will rarely implement this protocol yourself. However, if you do,
/// It would look something like this:
///
///     var globalLoadCount = 0
///
///     struct CustomProperty: DynamicProperty {
///         var localLoadCount = 0
///         mutating func update() {
///             globalLoadCount += 1
///             localLoadCount = globalLoadCount
///         }
///     }
///
///     struct ContentView: View {
///         @State private var reloadSwitch = false
///         var customProperty = CustomProperty()
///
///         var body: some View {
///             Text("Load count: \(customProperty.localLoadCount)")
///                 .font(reloadSwitch ? .title : .body)
///             Button("RELOAD ❗️") { reloadSwitch.toggle() }
///         }
///     }
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol DynamicProperty{ }
extension DynamicProperty {

    /// Updates the underlying value of the stored value.
    ///
    /// SwiftUI calls this function before rending a view's
    /// `View/body-swift.property` to ensure the view has the most recent
    /// value.
    ///
    /// You will rarely implement this protocol yourself. However, if you do,
    /// It would look something like this:
    ///
    ///     var globalLoadCount = 0
    ///
    ///     struct CustomProperty: DynamicProperty {
    ///         var localLoadCount = 0
    ///         mutating func update() {
    ///             globalLoadCount += 1
    ///             localLoadCount = globalLoadCount
    ///         }
    ///     }
    ///
    ///     struct ContentView: View {
    ///         @State private var reloadSwitch = false
    ///         var customProperty = CustomProperty()
    ///
    ///         var body: some View {
    ///             Text("Load count: \(customProperty.localLoadCount)")
    ///                 .font(reloadSwitch ? .title : .body)
    ///             Button("RELOAD ❗️") { reloadSwitch.toggle() }
    ///         }
    ///     }
    mutating func update() { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension DynamicProperty {

    /// Updates the underlying value of the stored value.
    ///
    /// SwiftUI calls this function before rending a view's
    /// `View/body-swift.property` to ensure the view has the most recent
    /// value.
    ///
    /// You will rarely implement this protocol yourself. However, if you do,
    /// It would look something like this:
    ///
    ///     var globalLoadCount = 0
    ///
    ///     struct CustomProperty: DynamicProperty {
    ///         var localLoadCount = 0
    ///         mutating func update() {
    ///             globalLoadCount += 1
    ///             localLoadCount = globalLoadCount
    ///         }
    ///     }
    ///
    ///     struct ContentView: View {
    ///         @State private var reloadSwitch = false
    ///         var customProperty = CustomProperty()
    ///
    ///         var body: some View {
    ///             Text("Load count: \(customProperty.localLoadCount)")
    ///                 .font(reloadSwitch ? .title : .body)
    ///             Button("RELOAD ❗️") { reloadSwitch.toggle() }
    ///         }
    ///     }
    public mutating func update() { }
}

/// A type of view that generates views from an underlying collection of data.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol DynamicViewContent : View{ }
extension DynamicViewContent : View {

    /// The type of the underlying collection of data.
    associatedtype Data : Collection

    /// The collection of underlying data.
    var data: Self.Data { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension DynamicViewContent {

    /// Sets the deletion action for the dynamic view.
    ///
    /// [[list-deletable]]
    ///
    /// - Parameter action: The action that you want SwiftUI to perform when
    ///   elements in the view are deleted. SwiftUI passes a set of indices to the
    ///   closure that's relative to the dynamic view's underlying collection of
    ///   data.
    ///
    /// - Returns: A view that calls `action` when elements are deleted from the
    ///   original view.
    @inlinable public func onDelete(perform action: ((IndexSet) -> Void)?) -> some DynamicViewContent { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension DynamicViewContent {

    /// Sets the move action for the dynamic view.
    ///
    /// - Parameters:
    ///   - action: A closure that SwiftUI invokes when elements in the dynamic
    ///     view are moved. The closure takes two arguments that represent the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     Pass `nil` to disable the ability to move items.
    ///
    /// - Returns: A view that calls `action` when elements are moved within the
    ///   original view.
    @inlinable public func onMove(perform action: ((IndexSet, Int) -> Void)?) -> some DynamicViewContent { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension DynamicViewContent {

    /// Sets the insert action for the dynamic view.
    ///
    /// - Parameters:
    ///   - supportedContentTypes: An array of UTI types that the dynamic
    ///     view supports.
    ///   - action: A closure that SwiftUI invokes when elements are added to
    ///     the view. The closure takes two arguments: The first argument is the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     The second argument is an array of
    ///     <doc://com.apple.documentation/documentation/Foundation/NSItemProvider> items that
    ///     represents the data that you want to insert.
    ///
    /// - Returns: A view that calls `action` when elements are inserted into
    ///   the original view.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public func onInsert(of supportedContentTypes: [UTType], perform action: @escaping (Int, [NSItemProvider]) -> Void) -> some DynamicViewContent { }


    /// Sets the insert action for the dynamic view.
    ///
    /// - Parameters:
    ///   - acceptedTypeIdentifiers: An array of UTI types that the dynamic
    ///     view supports.
    ///   - action: A closure that SwiftUI invokes when elements are added to
    ///     the view. The closure takes two arguments: The first argument is the
    ///     offset relative to the dynamic view's underlying collection of data.
    ///     The second argument is an array of `NSItemProvider` that represents
    ///     the data that you want to insert.
    ///
    /// - Returns: A view that calls `action` when elements are inserted into
    ///   the original view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
    public func onInsert(of acceptedTypeIdentifiers: [String], perform action: @escaping (Int, [NSItemProvider]) -> Void) -> some DynamicViewContent { }

}

/// An enumeration to indicate one edge of a rectangle.
///
/// ``Edge`` is most frequently used to specify padding with ``View/padding(_:)-9f6b7``,
/// but it can also be returned from instance methods. For example:
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        VStack {
///            Text("Example view where Edge is returned as a value")
///                .accessibilityScrollAction { edge in
///                    switch edge {
///                    case Edge.top:
///                        print("Swiped down from top edge")
///                    case Edge.leading:
///                        print("Swiped left from leading edge")
///                    case Edge.trailing:
///                        print("Swiped right from trailing edge")
///                    case Edge.bottom:
///                        print("Swiped up from bottom edge")
///                    }
///                }
///        }
///    }
/// }
/// ```
///
/// Note that for illustrative purposes, the enum values were expanded in this example.
/// It would also be valid to use the shorthand, just specifying the values:
/// `.top`, `.leading`, `.trailing`, and `.bottom`.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public enum Edge : Int8, CaseIterable {

	/// The rectangle's top edge.
    case top

    /// The rectangle's leading edge.
    case leading

    /// The rectangle's bottom edge.
    case bottom

    /// The rectangle's trailing edge.
    case trailing

    /// An efficient set of `Edge`s.
    ///
    /// Used when multiple edges need to be specified. For example, when setting padding
    /// on a view with ``View/padding(_:)-9f6b7``:
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        VStack {
    ///            Text("Text padded on the top and bottom edge.")
    ///                .padding([Edge.Set.top, Edge.Set.bottom])
    ///                .border(Color.gray)
    ///            Text("Unpadded text")
    ///                .border(Color.yellow)
    ///        }
    ///    }
    /// }
    /// ```
    ///
    /// Note that for illustrative purposes, the enum values were expanded in this example.
    /// It would also be valid to use the shorthand, just specifying the values:
    /// `.padding([.top, .bottom])`
    @frozen public struct Set : OptionSet {

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        public typealias Element = Edge.Set

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int8

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: Int8) { }

        /// The edge set's top edge.
        public static let top: Edge.Set

        /// The edge set's leading edge.
        public static let leading: Edge.Set

        /// The edge set's bottom edge.
        public static let bottom: Edge.Set

        /// The edge set's trailing edge.
        public static let trailing: Edge.Set

        /// An edge set containing all 4 edges.
        public static let all: Edge.Set

        /// An edge set containing the top and bottom edges.
        public static let horizontal: Edge.Set

        /// An edge set containing the leading and trailing edges.
        public static let vertical: Edge.Set

        /// Creates an instance containing just `e`
        public init(_ e: Edge) { }

        /// The type of the elements of an array literal.
        public typealias ArrayLiteralElement = Edge.Set.Element

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = Int8
    }

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int8

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: Int8) { }

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: Int8 { get }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [Edge]

    /// A collection of all values of this type.
    public static var allCases: [Edge] { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Edge : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Edge : Hashable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Edge : RawRepresentable {
}

/// The inset distances for the sides of a rectangle.
///
/// Use this structure for 3 different modifiers:
/// 1. ``View/listRowInsets(_:)``
/// 2. ``View/padding(_:)``
/// 3. ``Image/resizable(capInsets:resizingMode:)``
///
/// This structure represents a point value in all 4 rectangular directions,
/// top, leading, bottom, trailing.
///
/// In the following example, padding is added to a rectangle using
/// edge insets:
///
/// ```
/// struct PaddedRectangleView: View {
///     let insets = EdgeInsets(top: 20, leading 5, bottom 30, trailing 10)
///
///     var body: some View {
///         Rectangle()
///             .padding(insets)
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct EdgeInsets : Equatable {

	/// How far inset the rectangle is from the top edge.
    ///
    /// This value is normally specified in the initializer, but it can
    /// also be changed directly:
    ///
    /// ```
    /// struct PaddedRectangleView: View {
    ///     var body: some View {
    ///         let insets = EdgeInsets()
    ///         insets.top = 20
    ///
    ///         return Rectangle()
    ///             .padding(insets)
    ///     }
    /// }
    /// ```
    public var top: CGFloat

    /// How far inset the rectangle is from the leading edge.
    ///
    /// ```
    /// struct PaddedRectangleView: View {
    ///     var body: some View {
    ///         let insets = EdgeInsets()
    ///         insets.leading = 20
    ///
    ///         return Rectangle()
    ///             .padding(insets)
    ///     }
    /// }
    /// ```
    public var leading: CGFloat

    /// How far inset the rectangle is from the bottom edge.
    ///
    /// ```
    /// struct PaddedRectangleView: View {
    ///     var body: some View {
    ///         let insets = EdgeInsets()
    ///         insets.bottom = 20
    ///
    ///         return Rectangle()
    ///             .padding(insets)
    ///     }
    /// }
    /// ```
    public var bottom: CGFloat

    /// How far inset the rectangle is from the trailing edge.
    ///
    /// ```
    /// struct PaddedRectangleView: View {
    ///     var body: some View {
    ///         let insets = EdgeInsets()
    ///         insets.trailing = 20
    ///
    ///         return Rectangle()
    ///             .padding(insets)
    ///     }
    /// }
    /// ```
    public var trailing: CGFloat

    /// Creates a new `EdgeInsets` from inset parameters.
    ///
    /// ```
    /// struct PaddedRectangleView: View {
    ///     let insets = EdgeInsets(top: 20, leading 5, bottom 30, trailing 10)
    ///
    ///     var body: some View {
    ///         Rectangle()
    ///             .padding(insets)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - top: Inset distance from the top edge.
    ///   - leading: Inset distance from the leading edge.
    ///   - bottom: Inset distance from the bottom edge.
    ///   - trailing: Inset distance from the trailing edge.
    @inlinable public init(top: CGFloat, leading: CGFloat, bottom: CGFloat, trailing: CGFloat) { }

    /// Creates a new `EdgeInsets` with zero insets on all edges.
    ///
    /// ```
    /// struct PaddedRectangleView: View {
    ///     var body: some View {
    ///         let insets = EdgeInsets()
    ///         insets.trailing = 20
    ///
    ///         return Rectangle()
    ///             .padding(insets)
    ///     }
    /// }
    /// ```
    @inlinable public init() { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: EdgeInsets, b: EdgeInsets) -> Bool { }
}

extension EdgeInsets {

    /// Create edge insets from the equivalent NSDirectionalEdgeInsets.
    ///
    /// To learn more about the parameter, check out the documentation
    /// page on
    /// [NSDirectionalEdgeInsets](https://developer.apple.com/documentation/uikit/nsdirectionaledgeinsets).
    ///
    /// ```
    /// struct PaddedRectangleView: View {
    ///     let insets = NSEdgeInsets(top: 20, leading: 20, bottom: 20, trailing: 20)
    ///
    ///     var body: some View {
    ///         Rectangle()
    ///             .padding(insets)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter nsEdgeInsets: The NSEdgeInsets to use for creating an
    /// edge inset.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
    @available(watchOS, unavailable)
    public init(_ nsEdgeInsets: NSDirectionalEdgeInsets) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EdgeInsets : Animatable {

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<CGFloat, AnimatablePair<CGFloat, AnimatablePair<CGFloat, CGFloat>>>

    /// The data to animate.
    public var animatableData: EdgeInsets.AnimatableData
}

/// A button that toggles the edit mode for the current edit scope.
///
/// An `EditButton` toggles the `EditMode` (passed via `EnvironmentValues/editMode`) for content within a container that supports `EditMode.active`.
/// For example, an `EditButton` placed inside the toolbar of a `NavigationView` enables the editing of a `List`:
///
/// ![EditButton Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/EditButton-example-1.gif)
///
///```
/// struct ExampleView: View {
///     @State var fruits = ["🍌", "🍏", "🍑"]
///
///     var body: some View {
///         NavigationView {
///             List {
///                 ForEach(fruits, id: \.self) { fruit in
///                     Text(fruit)
///                 }
///                 .onDelete { offsets in
///                     fruits.remove(atOffsets: offsets)
///                 }
///             }
///             .toolbar {
///                 EditButton()
///             }
///         }
///     }
/// }
/// ```
///
/// [[list-edit-button]]
///
/// The title and appearance of an `EditButton` is determined by the system and cannot be overriden.
@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct EditButton : View {

	/// Creates an edit button.
    public init() { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

/// The mode of a view indicating whether the user can edit its content.
///
/// ![Binding Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Binding-example-3.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits = ["🍌", "🍏", "🍑"]
///
///     var body: some View {
///         List {
///             ForEach(fruits, id: \.self) { fruit in
///                 Text(fruit)
///             }
///             .onDelete { offets in
///                 fruits.remove(atOffsets: offets)
///             }
///         }
///         .environment(\.editMode, .constant(.active))
///     }
/// }
/// ```
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public enum EditMode {

    /// The view content cannot be edited.
    case inactive

    /// The view is in a temporary edit mode.
    ///
    /// The definition of temporary might vary by platform or specific control.
    /// As an example, temporary edit mode may be engaged over the duration of a
    /// swipe gesture.
    case transient

    /// The view content can be edited.
    ///
    /// ![Binding Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Binding-example-3.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var fruits = ["🍌", "🍏", "🍑"]
    ///
    ///     var body: some View {
    ///         List {
    ///             ForEach(fruits, id: \.self) { fruit in
    ///                 Text(fruit)
    ///             }
    ///             .onDelete { offets in
    ///                 fruits.remove(atOffsets: offets)
    ///             }
    ///         }
    ///         .environment(\.editMode, .constant(.active))
    ///     }
    /// }
    /// ```
    case active

    /// Indicates whether a view is being edited.
    public var isEditing: Bool { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: EditMode, b: EditMode) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension EditMode : Equatable {
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension EditMode : Hashable {
}

/// An ellipse shape, similar to a circle but with potentially different width
/// and height.
///
/// An Ellipse is a circular `Shape` that by default, aligns itself inside of
/// the view containing it. It differs from `Circle` in that its width and
/// height are not necessarily equal.
///
/// To define an Ellipse with a specific color and frame, use the `Shape/fill()`
/// and `View/frame(width:height:)` modifiers:
///
/// ![Ellipse fill and frame example](ellipse-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Ellipse()
///             .fill(Color.purple)
///             .frame(width: 250, height: 150)
///     }
/// }
/// ```
///
/// To add a border, use the `Shape/stroke(:lineWidth:)` modifier, and use
/// the `Ellipse/inset(by:)` modifier to inset the Ellipse by half of the
/// border width to keep the Ellipse at its original size:
///
/// ![Ellipse inset and stroke example](ellipse-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Ellipse()
///             .inset(by: 10)
///             .stroke(Color.purple, lineWidth: 20)
///             .frame(width: 250, height: 150)
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Ellipse : Shape {

    /// Used to describe an Ellipse as a path in a `CGRect`.
    ///
    /// An Ellipse can be described as a path within a specific `CGRect` using
    /// the `Ellipse/path(in:)` modifier:
    ///
    /// ![Ellipse path example](ellipse-example-3.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Ellipse()
    ///             .path(in: CGRect(x: 0, y: 0, width: 100, height: 150))
    ///     }
    /// }
    /// ```
    public func path(in rect: CGRect) -> Path { }

    /// Creates an Ellipse that aligns itself inside of the view containing it
    /// by default.
    ///
    /// ![Ellipse init example](ellipse-example-4.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Ellipse()
    ///     }
    /// }
    /// ```
    @inlinable public init() { }

    /// > The type defining the data to animate.
    public typealias AnimatableData = EmptyAnimatableData

    /// > The type of view representing the body of this view.
    ///
    /// > When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Ellipse : InsettableShape {

    /// Returns a Ellipse insetted by the amount specified.
    ///
    /// For example, insetting by 10 points returns a Ellipse that fills its
    /// container, with 10 points inset on all four side.
    ///
    /// ![Ellipse inset example](ellipse-example-5.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Ellipse()
    ///             .inset(by: 10)
    ///     }
    /// }
    /// ```
    @inlinable public func inset(by amount: CGFloat) -> some InsettableShape { }


    /// > The type of the inset shape.
    public typealias InsetShape = some InsettableShape
}

/// An empty type for animatable data.
///
/// This type is suitable for use as the `animatableData` property of
/// types that do not have any animatable properties.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct EmptyAnimatableData : VectorArithmetic {

	/// Creates an empty animatable data structure.
    @inlinable public init() { }

    /// The zero value.
    ///
    /// Zero is the identity element for addition. For any value,
    /// `x + .zero == x` and `.zero + x == x`.
    @inlinable public static var zero: EmptyAnimatableData { get }

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    @inlinable public static func += (lhs: inout EmptyAnimatableData, rhs: EmptyAnimatableData) { }

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    @inlinable public static func -= (lhs: inout EmptyAnimatableData, rhs: EmptyAnimatableData) { }

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    @inlinable public static func + (lhs: EmptyAnimatableData, rhs: EmptyAnimatableData) -> EmptyAnimatableData { }

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    @inlinable public static func - (lhs: EmptyAnimatableData, rhs: EmptyAnimatableData) -> EmptyAnimatableData { }

    /// Multiplies each component of this value by the given value.
    @inlinable public mutating func scale(by rhs: Double) { }

    /// The dot-product of this animatable data instance with itself.
    @inlinable public var magnitudeSquared: Double { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: EmptyAnimatableData, b: EmptyAnimatableData) -> Bool { }
}

/// An empty group of commands.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct EmptyCommands : Commands {

    /// Creates an empty group of commands.
    public init() { }

    /// The type of command group representing the body of this command group.
    public typealias Body = Never
}

/// An empty, or identity, modifier, used during development to switch
/// modifiers at compile time.
///
/// Use the empty modifier to switch modifiers at compile time during
/// development. In the example below, in a debug build the `Text`
/// view inside `ContentView` has a yellow background and a red border.
/// A non-debug build reflects the default system, or container supplied
/// appearance.
///
///     struct EmphasizedLayout: ViewModifier {
///         func body(content: Content) -> some View {{}
///             content
///                 .background(Color.yellow)
///                 .border(Color.red)
///         }
///     }
///
///     struct ContentView: View {
///         var body: some View {
///             Text("Hello, World!")
///                 .modifier(modifier)
///         }
///
///         var modifier: some ViewModifier {
///             #if DEBUG
///                 return EmphasizedLayout()
///             #else
///                 return EmptyModifier()
///             #endif
///         }
///     }
///
/// In order to stack multiple modifiers, including the EmptyModifier, see
/// ``ViewModifier/concat(_:)``
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct EmptyModifier : ViewModifier {

	  /// A view modifier that leave the view unchanged.
    public static let identity: EmptyModifier

    /// The type of view representing the body.
    public typealias Body = Never

    /// Creates a new modifier that leaves the view unchanged.
    @inlinable public init() { }

    /// Gets the current body of the caller.
    ///
    /// `content` is a proxy for the view that will have the modifier
    /// represented by `Self` applied to it. In simpler terms, content is the
    /// view that is being transformed and this function will return the view
    /// absent of any modifier transformations.
    public func body(content: EmptyModifier.Content) -> EmptyModifier.Body { }
}

/// A `View` that displays nothing.
///
/// `EmptyView` is a special view that displays nothing and occupies no space.
/// Modifying an `EmptyView` does nothing.
///
/// For example, the following stack ignores the `EmptyView` between the two `Text` elements, even when it is modified to have a frame of 1000x1000 and a red background color. It simply behaves as if the middle view does not exist.
///
/// ![EmptyView Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/emptyview-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         VStack {
///             Text("Hello")
///
///             EmptyView()
///                 .frame(width: 1000, height: 1000)
///                 .background(Color.red)
///
///             Text("World")
///         }
///     }
/// }
/// ```
///
/// `EmptyView` has many uses. For example, it can be used to instruct SwiftUI that your UI control does not want a label:
///
/// ```
/// Toggle(isOn: $myBooleanValue, label: { EmptyView() })
/// ```
///
/// `EmptyView` can also be used in conjunction with `GeometryReader`:
///
///  ![EmptyView Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/emptyview-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     @State var width: CGFloat? = nil
///
///     var body: some View {
///         Text("Hello, world!").background(
///             GeometryReader { geometry -> EmptyView in
///                 DispatchQueue.main.async {
///                     width = geometry.size.width
///                 }
///
///                 return EmptyView()
///             }
///         )
///     }
/// }
/// ```
/// Account for `EmptyView` when building your own custom UI controls.
/// For example, the following code specifies that `label` should be hidden from system accessibility features when the `label` is an instance of `EmptyView`:
/// ```
/// struct MyCustomControl<Label: View, Content: View>: View {
///     let label: Label
///     let content: Content
///
///     var body: some View {
///         HStack {
///             label.accessibility(hidden: label is EmptyView)
///
///             content
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct EmptyView : View {

	/// Creates a new `EmptyView`.
    @inlinable public init() { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// An empty widget configuration.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@frozen public struct EmptyWidgetConfiguration : WidgetConfiguration {

	/// Creates an empty widget configuration.
    @inlinable public init() { }

    /// The type of widget configuration representing the body of
    /// this configuration.
    ///
    /// When you create a custom widget, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A property wrapper that reads a value from a view's environment.
///
/// Use the `Environment` property wrapper to read a value
/// stored in a view's environment. Indicate the value to read using an
/// `EnvironmentValues` key path in the property declaration. For example, you
/// can create a property that reads the color scheme of the current
/// view using the key path of the `EnvironmentValues/colorScheme`
/// property:
///
///     @Environment(\.colorScheme) var colorScheme: ColorScheme
///
/// You can condition a view's content on the associated value, which
/// you read from the declared property's `wrappedValue`. As with any property
/// wrapper, you access the wrapped value by directly referring to the property:
///
///     if colorScheme == .dark { // Checks the wrapped value.
///         DarkContent()
///     } else {
///         LightContent()
///     }
///
/// If the value changes, SwiftUI updates any parts of your view that depend on
/// the value. For example, that might happen in the above example if the user
/// changes the Appearance settings.
///
/// You can use this property wrapper to read --- but not set --- an environment
/// value. SwiftUI updates some environment values automatically based on system
/// settings and provides reasonable defaults for others. You can override some
/// of these, as well as set custom environment values that you define,
/// using the `View/environment(_:_:)` view modifier.
///
/// For the complete list of environment values provided by SwiftUI, see the
/// properties of the `EnvironmentValues` structure. For information about
/// creating custom environment values, see the `EnvironmentKey` protocol.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen @propertyWrapper public struct Environment<Value> : DynamicProperty {

    /// Creates an environment property to read the specified key path.
    ///
    /// Don’t call this initializer directly. Instead, declare a property
    /// with the `Environment` property wrapper, and provide the key path of
    /// the environment value that the property should reflect:
    ///
    ///     struct MyView: View {
    ///         @Environment(\.colorScheme) var colorScheme: ColorScheme
    ///
    ///         // ...
    ///     }
    ///
    /// SwiftUI automatically updates any parts of `MyView` that depend on
    /// the property when the associated environment value changes.
    /// You can't modify the environment value using a property like this.
    /// Instead, use the `View/environment(_:_:)` view modifier on a view to
    /// set a value for a view hierarchy.
    ///
    /// - Parameter keyPath: A key path to a specific resulting value.
    @inlinable public init(_ keyPath: KeyPath<EnvironmentValues, Value>) { }

    /// The current value of the environment property.
    ///
    /// The wrapped value property provides primary access to the value's data.
    /// However, you don't access `wrappedValue` directly. Instead, you read the
    /// property variable created with the `Environment` property wrapper:
    ///
    ///     @Environment(\.colorScheme) var colorScheme: ColorScheme
    ///
    ///     var body: some View {
    ///         if colorScheme == .dark {
    ///             DarkContent()
    ///         } else {
    ///             LightContent()
    ///         }
    ///     }
    ///
    @inlinable public var wrappedValue: Value { get }
}

/// A key for accessing values in the environment.
///
/// You can create custom environment values by extending the
/// `EnvironmentValues` structure with new properties.
/// First declare a new environment key type and specify a value for the
/// required `defaultValue` property:
///
///     private struct MyEnvironmentKey: EnvironmentKey {
///         static let defaultValue: String = "Default value"
///     }
///
/// The Swift compiler automatically infers the associated `Value` type as the
/// type you specify for the default value. Then use the key to define a new
/// environment value property:
///
///     extension EnvironmentValues {
///         var myCustomValue: String {
///             get { self[MyEnvironmentKey.self] }
///             set { self[MyEnvironmentKey.self] = newValue }
///         }
///     }
///
/// Clients of your environment value never use the key directly.
/// Instead, they use the key path of your custom environment value property.
/// To set the environment value for a view and all its subviews, add the
/// `View/environment(_:_:)` view modifier to that view:
///
///     MyView()
///         .environment(\.myCustomValue, "Another string")
///
/// As a convenience, you can also define a dedicated view modifier to
/// apply this environment value:
///
///     extension View {
///         func myCustomValue(_ myCustomValue: String) -> some View {{}
///             environment(\.myCustomValue, myCustomValue)
///         }
///     }
///
/// This improves clarity at the call site:
///
///     MyView()
///         .myCustomValue("Another string")
///
/// To read the value from inside `MyView` or one of its descendants, use the
/// `Environment` property wrapper:
///
///     struct MyView: View {
///         @Environment(\.myCustomValue) var customValue: String
///
///         var body: some View {
///             Text(customValue) // Displays "Another value".
///         }
///     }
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol EnvironmentKey{ }
extension EnvironmentKey {

    /// The associated type representing the type of the environment key's
    /// value.
    associatedtype Value

    /// The default value for the environment key.
    static var defaultValue: Self.Value { get }
}

/// A property wrapper type for an observable object passed down the view hierarchy by a parent view.
///
/// `@EnvironmentObject` is similar to `@ObservedObject` in that they both invalidate the view using them whenever the observed object changes.
///
/// `@EnvironmentObject` differs from `@ObservedObject` in that it receives the object to observe at runtime, from the view's environment, whereas `@ObservedObject` receives it directly either by the immediate parent view or by an initial value while declaring it.
/// [environment-objects ->]
/// ### Using environment objects
///
/// Consider the following example:
///
/// ```
/// class AppModel: ObservableObject {
///     let text: String = "some text"
/// }
///
/// struct ContentView: View {
///     @StateObject var appModel = AppModel()
///
///     var body: some View {
///         ChildView()
///             .environmentObject(appModel)
///     }
/// }
///
/// struct ChildView: View {
///     @EnvironmentObject var appModel: AppModel
///
///     var body: some View {
///         Text(appModel.text)
///     }
/// }
/// ```
///
/// - An app model, `AppModel` is initialized in a `@StateObject` in the `ContentView`.
/// - `ContentView` initializes `ChildView`, and then passes the app model initialized via `View/environmentObject(_:)`.
/// - `ChildView` uses `AppModel` to display a piece of text declared by the app model.
/// [<-]
/// Now consider a slightly different version of this example:
///
/// ```
/// class AppModel: ObservableObject {
///     let text: String = "some text"
/// }
///
/// struct ContentView: View {
///     @StateObject var appModel = AppModel()
///
///     var body: some View {
///         IntermediateView()
///             .environmentObject(appModel)
///     }
/// }
///
/// struct IntermediateView: View {
///     var body: some View {
///         ChildView()
///             .padding()
///     }
/// }
///
/// struct ChildView: View {
///     @EnvironmentObject var appModel: AppModel
///
///     var body: some View {
///         Text(appModel.text)
///     }
/// }
///
/// ```
///
/// In this example, `ChildView` is initialized by an `IntermediateView`, which in turn is initialized by `ContentView`. This example is different only in that there is an additional level of nesting, via `IntermediateView` (a view that adds padding to `ChildView`).
///
/// Note that `ChildView` did not need to be changed at all. `@EnvironmentObject` is neither used nor declared in `IntermediateView`, yet it is still available in the same way at one level deeper.
///
/// This is also the primary way in which `@EnvironmentObject` and `@ObservedObject` differ. Had `ChildView` been using `@ObservedObject`, the app model would need to be passed explicitly through `IntermediateView`, which would also need to declare `var appModel: AppModel` and then pass it to `ChildView`'s initializer.
///
/// ### Creating bindings
///
/// Here is another example:
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var flag: Bool = false
/// }
///
/// struct ContentView: View {
///     @StateObject var appModel = AppModel()
///
///     var body: some View {
///         ChildView()
///             .environmentObject(appModel)
///     }
/// }
///
/// struct ChildView: View {
///     @EnvironmentObject var appModel: AppModel
///
///     var body: some View {
///         Toggle("Flag", isOn: $appModel.flag)
///     }
/// }
/// ```
///
///  In this example, `AppModel` contains a boolean, `flag`, which is represented by a `Toggle` in `ChildView`. `Toggle` requires a `Binding<Bool>` to read and write whether it is on.
///
/// Just like `@State`, `@ObservedObject` and `@StateObject`, `@EnvironmentObject` allows you to create a `Binding` from its wrapped value type using the `$` syntax.
///
/// `$appModel.flag` creates a binding to `flag`, which is then passed to the toggle. This is also a good example of how **mutable** data can be passed down from a parent view to a child view (at any level deep) at runtime.
///
/// ### Dependency injection
///
/// Because `@EnvironmentObject` receives the object from the environment, the object can be passed down any number of levels. This makes it especially useful for problems such as dependency injection.
///
/// There are many use cases of `@EnvironmentObject` that don't necessarily involve passing the app's main model down. For example:
///
/// - Providing a "theme" object, allowing child views to adapt as per the theme passed down.
/// - Providing a cache, that allows complex network-based views to be broken down into reusable components, while still using a cache provided by the parent.
/// - Passing a global navigation manager - a navigator object that contains the current navigation selection.
///
/// ### Caveats
///
/// There are some limitations to `@EnvironmentObject`, especially on older versions of iOS.
///
/// On iOS 13, environment objects do not automatically pass to sheets or navigation destinations. The following code would crash on iOS 13, for example:
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var flag: Bool = false
/// }
///
/// struct ContentView: View {
///     @StateObject var appModel = AppModel()
///
///     @State var isPresented: Bool = false
///
///     var body: some View {
///         Button("Present") {
///             isPresented = true
///         }
///         .sheet(isPresented: $isPresented ){
///             ChildView()
///         }
///         .environmentObject(appModel)
///     }
/// }
///
/// struct ChildView: View {
///     @EnvironmentObject var appModel: AppModel
///
///     var body: some View {
///         Toggle("Flag", isOn: $appModel.flag)
///     }
/// }
/// ```
///
/// To fix it, the `View/environmentObject(_:)` modifier would need to be added directly to the sheet's content, like this:
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var flag: Bool = false
/// }
///
/// struct ContentView: View {
///     @StateObject var appModel = AppModel()
///
///     @State var isPresented: Bool = false
///
///     var body: some View {
///         Button("Present") {
///             isPresented = true
///         }
///         .sheet(isPresented: $isPresented ){
///             ChildView()
///                 .environmentObject(appModel)
///         }
///         .environmentObject(appModel)
///     }
/// }
///
/// struct ChildView: View {
///     @EnvironmentObject var appModel: AppModel
///
///     var body: some View {
///         Toggle("Flag", isOn: $appModel.flag)
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen @propertyWrapper public struct EnvironmentObject<ObjectType> : DynamicProperty where ObjectType : ObservableObject {

    /// A wrapper of the underlying environment object that can create bindings
    /// to its properties using dynamic member lookup.
    @dynamicMemberLookup @frozen public struct Wrapper {

        /// Returns a binding to the resulting value of a given key path.
        ///
        /// - Parameter keyPath: A key path to a specific resulting value.
        ///
        /// - Returns: A new binding.
        public subscript<Subject>(dynamicMember keyPath: ReferenceWritableKeyPath<ObjectType, Subject>) -> Binding<Subject> { get }
    }

    /// The underlying value referenced by the environment object.
    ///
    /// This property provides primary access to the value's data. However, you
    /// don't access `wrappedValue` directly. Instead, you use the property
    /// variable created with the `EnvironmentObject` attribute.
    ///
    /// When a mutable value changes, the new value is immediately available.
    /// However, a view displaying the value is updated asynchronously and may
    /// not show the new value immediately.
    @inlinable public var wrappedValue: ObjectType { get }

    /// A projection of the environment object that creates bindings to its
    /// properties using dynamic member lookup.
    ///
    /// Use the projected value to pass an environment object down a view
    /// hierarchy.
    public var projectedValue: EnvironmentObject<ObjectType>.Wrapper { get }

    /// Creates an environment object.
    public init() { }
}

/// A collection of environment values propagated through a view hierarchy.
///
/// SwiftUI exposes a collection of values to your app's views in an
/// `EnvironmentValues` structure. To read a value from the structure,
/// declare a property using the `Environment` property wrapper and
/// specify the value's key path. For example, you can read the current locale:
///
///     @Environment(\.locale) var locale: Locale
///
/// Use the property you declare to dynamically control a view's layout.
/// SwiftUI automatically sets or updates many environment values, like
/// `EnvironmentValues/pixelLength`, `EnvironmentValues/scenePhase`, or
/// `EnvironmentValues/locale`, based on device characteristics, system state,
/// or user settings. For others, like `EnvironmentValues/lineLimit`, SwiftUI
/// provides a reasonable default value.
///
/// You can set or override some values using the `View/environment(_:_:)`
/// view modifier:
///
///     MyView()
///         .environment(\.lineLimit, 2)
///
/// The value that you set affects the environment for the view that you modify
/// --- including its descendants in the view hierarchy --- but only up to the
/// point where you apply a different environment modifier.
///
/// SwiftUI provides dedicated view modifiers for setting some values, which
/// typically makes your code easier to read. For example, rather than setting
/// the `EnvironmentValues/lineLimit` value directly, as in the previous
/// example, you should instead use the `View/lineLimit(_:)` modifier:
///
///     MyView()
///         .lineLimit(2)
///
/// In some cases, using a dedicated view modifier provides additional
/// functionality. For example, you must use the
/// `View/preferredColorScheme(_:)` modifier rather than setting
/// `EnvironmentValues/colorScheme` directly to ensure that the new
/// value propagates up to the presenting container when presenting a view
/// like a popover:
///
///     MyView()
///         .popover(isPresented: $isPopped) {
///             PopoverContent()
///                 .preferredColorScheme(.dark)
///         }
///
/// Create custom environment values by defining a type that
/// conforms to the `EnvironmentKey` protocol, and then extending the
/// environment values structure with a new property. Use your key to get and
/// set the value, and provide a dedicated modifier for clients to use when
/// setting the value:
///
///     private struct MyEnvironmentKey: EnvironmentKey {
///         static let defaultValue: String = "Default value"
///     }
///
///     extension EnvironmentValues {
///         var myCustomValue: String {
///             get { self[MyEnvironmentKey.self] }
///             set { self[MyEnvironmentKey.self] = newValue }
///         }
///     }
///
///     extension View {
///         func myCustomValue(_ myCustomValue: String) -> some View {{}
///             environment(\.myCustomValue, myCustomValue)
///         }
///     }
///
/// Clients of your value then access the value in the usual way, reading it
/// with the `Environment` property wrapper, and setting it with the
/// `myCustomValue` view modifier.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct EnvironmentValues : CustomStringConvertible {

    /// Creates an environment values instance.
    ///
    /// You don't typically create an instance of `EnvironmentValues`
    /// directly. Doing so would provide access only to default values that
    /// don't update based on system settings or device characteristics.
    /// Instead, you rely on an environment values' instance
    /// that SwiftUI manages for you when you use the `Environment`
    /// property wrapper and the `View/environment(_:_:)` view modifier.
    public init() { }

    /// Accesses the environment value associated with a custom key.
    ///
    /// Create custom environment values by defining a key
    /// that conforms to the `EnvironmentKey` protocol, and then using that
    /// key with the subscript operator of the `EnvironmentValues` structure
    /// to get and set a value for that key:
    ///
    ///     private struct MyEnvironmentKey: EnvironmentKey {
    ///         static let defaultValue: String = "Default value"
    ///     }
    ///
    ///     extension EnvironmentValues {
    ///         var myCustomValue: String {
    ///             get { self[MyEnvironmentKey.self] }
    ///             set { self[MyEnvironmentKey.self] = newValue }
    ///         }
    ///     }
    ///
    /// You use custom environment values the same way you use system-provided
    /// values, setting a value with the `View/environment(_:_:)` view
    /// modifier, and reading values with the `Environment` property wrapper.
    /// You can also provide a dedicated view modifier as a convenience for
    /// setting the value:
    ///
    ///     extension View {
    ///         func myCustomValue(_ myCustomValue: String) -> some View {{}
    ///             environment(\.myCustomValue, myCustomValue)
    ///         }
    ///     }
    ///
    public subscript<K>(key: K.Type) -> K.Value where K : EnvironmentKey

    /// A string that represents the contents of the environment values
    /// instance.
    public var description: String { get }
}

extension EnvironmentValues {

    /// A Boolean value that determines whether the view hierarchy has
    /// auto-correction enabled.
    ///
    /// When the value is `nil`, SwiftUI uses the system default. The default
    /// value is `nil`.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    @available(watchOS, unavailable)
    public var disableAutocorrection: Bool?
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// The preferred size of the content.
    ///
    /// The default value is `ContentSizeCategory/large`.
    public var sizeCategory: ContentSizeCategory
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

	/// The object space that you use to manipulate and track changes to
	/// the environment values.
    public var managedObjectContext: NSManagedObjectContext
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// The undo manager used to register a view's undo operations.
    ///
    /// This value is `nil` when the environment represents a context that
    /// doesn't support undo and redo operations. You can skip registration of
    /// an undo operation when this value is `nil`.
    public var undoManager: UndoManager? { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// The layout direction associated with the current environment.
    ///
    /// Use this value to determine whether the environment uses a left-to-right
    /// or right-to-left orientation.
    public var layoutDirection: LayoutDirection
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension EnvironmentValues {

    /// The current redaction reasons applied to the view hierarchy.
    public var redactionReasons: RedactionReasons
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension EnvironmentValues {

    /// The current phase of the scene.
    ///
    /// The system sets this value to provide an indication of the
    /// operational state of a scene or collection of scenes. The exact
    /// meaning depends on where you access the value. For more information,
    /// see `ScenePhase`.
    public var scenePhase: ScenePhase
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// The default minimum height of a row in a list.
    public var defaultMinListRowHeight: CGFloat

    /// The default minimum height of a header in a list.
    ///
    /// When this value is `nil`, the system chooses the appropriate height. The
    /// default is `nil`.
    public var defaultMinListHeaderHeight: CGFloat?
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// A Boolean value that indicates whether the view associated with this
    /// environment allows user interaction.
    ///
    /// The default value is `true`.
    public var isEnabled: Bool
}

extension EnvironmentValues {

    /// Returns whether the nearest focusable ancestor has focus.
    ///
    /// If there is no focusable ancestor, the value is `false`.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public var isFocused: Bool { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// The default font of this environment.
    public var font: Font?

    /// The display scale of this environment.
    public var displayScale: CGFloat

    /// The image scale for this environment.
    @available(macOS 11.0, *)
    public var imageScale: Image.Scale

    /// The size of a pixel on the screen.
    ///
    /// This value is equal to `1` divided by
    /// `EnvironmentValues/displayScale`.
    public var pixelLength: CGFloat { get }

    /// The font weight to apply to text.
    ///
    /// This value reflects the value of the Bold Text display setting found in
    /// the Accessibility settings.
    public var legibilityWeight: LegibilityWeight?

    /// The current locale that views should use.
    public var locale: Locale

    /// The current calendar that views should use when handling dates.
    public var calendar: Calendar

    /// The current time zone that views should use when handling dates.
    public var timeZone: TimeZone

    /// The color scheme of this environment.
    ///
    /// When writing custom drawing code that depends on the current color
    /// scheme, you should also consider the
    /// `EnvironmentValues/colorSchemeContrast` property. You can specify
    /// images and colors in asset catalogs according to either the
    /// `ColorScheme/light` or `ColorScheme/dark` color scheme, as well as
    /// standard or increased contrast. The correct image or color displays
    /// automatically for the current environment.
    ///
    /// You only need to check `colorScheme` and
    /// `EnvironmentValues/colorSchemeContrast` for custom drawing if the
    /// differences go beyond images and colors.
    ///
    /// Setting the `colorScheme` environment value directly is an advanced use
    /// case, as it changes the color scheme of the contained views but *not* of
    /// the container. Instead, consider using the
    /// `View/preferredColorScheme(_:)` modifier, which propagates to the
    /// presentation containing the view.
    public var colorScheme: ColorScheme

    /// The contrast associated with the color scheme of this environment.
    public var colorSchemeContrast: ColorSchemeContrast { get }
}

@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// The horizontal size class of this environment.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var horizontalSizeClass: UserInterfaceSizeClass?

    /// The vertical size class of this environment.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var verticalSizeClass: UserInterfaceSizeClass?
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// A Boolean value that indicates whether the user has enabled an assistive
    /// technology.
    public var accessibilityEnabled: Bool
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// Whether the system preference for Differentiate without Color is enabled.
    ///
    /// If this is true, UI should not convey information using color alone
    /// and instead should use shapes or glyphs to convey information.
    public var accessibilityDifferentiateWithoutColor: Bool { get }

    /// Whether the system preference for Reduce Transparency is enabled.
    ///
    /// If this property's value is true, UI (mainly window) backgrounds should
    /// not be semi-transparent; they should be opaque.
    public var accessibilityReduceTransparency: Bool { get }

    /// Whether the system preference for Reduce Motion is enabled.
    ///
    /// If this property's value is true, UI should avoid large animations,
    /// especially those that simulate the third dimension.
    public var accessibilityReduceMotion: Bool { get }

    /// Whether the system preference for Invert Colors is enabled.
    ///
    /// If this property's value is true then the display will be inverted.
    /// In these cases it may be needed for UI drawing to be adjusted to in
    /// order to display optimally when inverted.
    public var accessibilityInvertColors: Bool { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension EnvironmentValues {

    /// Whether the system preference for Show Button Shapes is enabled.
    ///
    /// If this property's value is true, interactive custom controls
    /// such as buttons should be drawn in such a way that their edges
    /// and borders are clearly visible.
    public var accessibilityShowButtonShapes: Bool { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension EnvironmentValues {

    /// Opens a URL using the appropriate system service.
    public var openURL: OpenURLAction { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// A value that indicates how text instance aligns its lines when the
    /// content wraps or contains newlines.
    ///
    /// Use alignment parameters on a parent view to align `Text` with respect
    /// to its parent. Because the horizontal bounds of `TextField` never
    /// exceed its graphical extent, this value has little to no effect on
    /// single-line text.
    public var multilineTextAlignment: TextAlignment

    /// A value that indicates how the layout truncates the last line of text to
    /// fit into the available space.
    ///
    /// The default value is `Text/TruncationMode/tail`.
    public var truncationMode: Text.TruncationMode

    /// The distance in points between the bottom of one line fragment and the
    /// top of the next.
    ///
    /// This value is always nonnegative.
    public var lineSpacing: CGFloat

    /// A Boolean value that indicates whether inter-character spacing should
    /// tighten to fit the text into the available space.
    ///
    /// The default value is `false`.
    public var allowsTightening: Bool

    /// The maximum number of lines that text can occupy in a view.
    ///
    /// The maximum number of lines is `1` if the value is less than `1`. If the
    /// value is `nil`, the text uses as many lines as required. The default is
    /// `nil`.
    public var lineLimit: Int?

    /// The minimum permissible proportion to shrink the font size to fit
    /// the text into the available space.
    ///
    /// In the example below, a label with a `minimumScaleFactor` of `0.5`
    /// draws its text in a font size as small as half of the actual font if
    /// needed to fit into the space next to the text input field:
    ///
    ///     HStack {
    ///         Text("This is a very long label:")
    ///             .lineLimit(1)
    ///             .minimumScaleFactor(0.5)
    ///         TextField("My Long Text Field", text: $myTextField)
    ///             .frame(width: 250, height: 50, alignment: .center)
    ///     }
    ///
    /// ![A screenshot showing the effects of setting the minimumScaleFactor on
    ///   the text in a view](SwiftUI-view-minimumScaleFactor.png)
    ///
    /// You can set the minimum scale factor to any value greater than `0` and
    /// less than or equal to `1`. The default value is `1`.
    ///
    /// SwiftUI uses this value to shrink text that doesn't fit in a view when
    /// it's okay to shrink the text. For example, a label with a
    /// `minimumScaleFactor` of `0.5` draws its text in a font size as small as
    /// half the actual font if needed.
    public var minimumScaleFactor: CGFloat

    /// A stylistic override to transform the case of `Text` when displayed,
    /// using the environment's locale.
    ///
    /// The default value is `nil`, displaying the `Text` without any case
    /// changes.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public var textCase: Text.Case?
}

@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension EnvironmentValues {

    /// The mode indicating whether the user can edit the contents of a view
    /// associated with this environment.
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public var editMode: Binding<EditMode>?
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension EnvironmentValues {

    /// A binding to the current presentation mode of the view associated with
    /// this environment.
    ///
    /// Use this environment value to programmatically interact with the
    /// view currently presented.
    ///
    /// This is useful for 4 types of views:
    /// 1. ``NavigationView``
    /// 2. ``View/sheet(isPresented:onDismiss:)``
    /// 3. ``View/popover(isPresented:onDismiss:)``
    /// 4. ``View/fullScreenCover(isPresented:onDismiss)``
    ///
    /// See ``Environment`` for more on environment values and how to use
    /// the property wrapper.
    ///
    /// While this is a ``Binding`` environment value, most often
    /// the wrapped value will be accessed. The wrapped value
    /// is of type ``PresentatinMode``. See that structure for more info
    /// on its properties.
    ///
    /// Below is a simple example of programmatically dismissing a
    /// sheet using this environment value.
    ///
    ///     struct ExampleView: View {
    ///         @State private var showSheet = false
    ///
    ///         var body: some View {
    ///             Button("Open sesame 📬") {
    ///                 showSheet = true
    ///             }
    ///             .sheet(isPresented: $showCover,
    ///                    onDismiss: { print("dismissed!") },
    ///                    content: { ExampleSheet() })
    ///         }
    ///     }
    ///
    ///     struct ExampleSheet: View {
    ///         @Environment(\.presentationMode) var presentationMode
    ///
    ///         var body: some View {
    ///             Button("CLOSE 📪") {
    ///                 presentationMode.wrappedValue.dismiss()
    ///             }
    ///         }
    ///     }
    ///
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    public var presentationMode: Binding<PresentationMode> { get }
}

/// A modifier that must resolve to a concrete modifier in an environment before
/// use.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol EnvironmentalModifier : ViewModifier where Self.Body == Never{ }
extension EnvironmentalModifier : ViewModifier where Self.Body == Never {

    /// The type of modifier to use after being resolved.
    associatedtype ResolvedModifier : ViewModifier

    /// Resolve to a concrete modifier in the given `environment`.
    func resolve(in environment: EnvironmentValues) -> Self.ResolvedModifier { }
}

/// A view type that compares itself against its previous value and prevents its
/// child updating if its new value is the same as its old value.
///
/// To achieve this same effect, use the ``View/equatable()`` modifier.
///
/// Two great articles on equatable views are here:
/// - [Swift with Majid](https://swiftwithmajid.com/2020/01/22/optimizing-views-in-swiftui-using-equatableview/)
/// - [The SwiftUI Lab](https://swiftui-lab.com/equatableview/)
///
/// ```
/// struct ContentView: View {
///     @State private var bodyDoesntDependOnMe = false
///     var body: some View {
///         EquatableView(content: ConformingToEquatableView())
///     }
/// }
///
/// struct ConformingToEquatableView: View, Equatable {
///     var body: some View {
///         Text("I can be optimized using equatable! ⚖️")
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct EquatableView<Content> : View where Content : Equatable, Content : View {

	/// The current content view that appears in the equatable view.
	///
	/// If you update this value but it's just the same thing as the old version, then the view
	/// won't update. That's the "equatable" part of equatable view.
    ///
    /// Two great articles on equatable views are here:
    /// - [Swift with Majid](https://swiftwithmajid.com/2020/01/22/optimizing-views-in-swiftui-using-equatableview/)
    /// - [The SwiftUI Lab](https://swiftui-lab.com/equatableview/)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State private var bodyDoesntDependOnMe = false
    ///     var body: some View {
    ///         // EquatableView holds onto a var called content
    ///         EquatableView(content: ConformingToEquatableView())
    ///     }
    /// }
    ///
    /// struct ConformingToEquatableView: View, Equatable {
    ///     var body: some View {
    ///         Text("I can be optimized using equatable! ⚖️")
    ///     }
    /// }
    /// ```
    public var content: Content

    /// Creates a new equatable view from a view.
    ///
    /// To achieve this same effect, use the ``View/equatable()`` modifier.
    ///
    /// Two great articles on equatable views are here:
    /// - [Swift with Majid](https://swiftwithmajid.com/2020/01/22/optimizing-views-in-swiftui-using-equatableview/)
    /// - [The SwiftUI Lab](https://swiftui-lab.com/equatableview/)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State private var bodyDoesntDependOnMe = false
    ///     var body: some View {
    ///         // EquatableView holds onto a var called content
    ///         EquatableView(content: ConformingToEquatableView())
    ///     }
    /// }
    ///
    /// struct ConformingToEquatableView: View, Equatable {
    ///     var body: some View {
    ///         Text("I can be optimized using equatable! ⚖️")
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter content: The view you want to use as the body of the equatable view.
    @inlinable public init(content: Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A set of key modifiers that you can add to a gesture.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct EventModifiers : OptionSet {

    /// The raw value.
    public let rawValue: Int

    /// Creates a new set from a raw value.
    ///
    /// - Parameter rawValue: The raw value with which to create the key
    ///   modifier.
    public init(rawValue: Int) { }

    /// The Caps Lock key.
    public static let capsLock: EventModifiers

    /// The Shift key.
    public static let shift: EventModifiers

    /// The Control key.
    public static let control: EventModifiers

    /// The Option key.
    public static let option: EventModifiers

    /// The Command key.
    public static let command: EventModifiers

    /// Any key on the numeric keypad.
    public static let numericPad: EventModifiers

    /// The Function key.
    public static let function: EventModifiers

    /// All possible modifier keys.
    public static let all: EventModifiers

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = EventModifiers

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = EventModifiers
}

/// A gesture that consists of two gestures where only one of them can succeed.
///
/// The `ExclusiveGesture` gives precedence to its first gesture.
///
/// See ``Gesture/exclusively(before:)`` for more of an explanation and an example.
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ExclusiveGesture<First, Second> : Gesture where First : Gesture, Second : Gesture {

    /// The value of an exclusive gesture that indicates which of two gestures
    /// succeeded.
    @frozen public enum Value {

        /// The first of two gestures succeeded.
        case first(First.Value)

        /// The second of two gestures succeeded.
        case second(Second.Value)
    }

    /// The first of two gestures.
    public var first: First

    /// The second of two gestures.
    public var second: Second

    /// Creates a gesture from two gestures where only one of them succeeds.
    ///
    /// - Parameters:
    ///   - first: The first of two gestures. This gesture has precedence over
    ///     the other gesture.
    ///   - second: The second of two gestures.
    @inlinable public init(_ first: First, _ second: Second) { }

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ExclusiveGesture.Value : Equatable where First.Value : Equatable, Second.Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ExclusiveGesture<First, Second>.Value, b: ExclusiveGesture<First, Second>.Value) -> Bool { }
}

/// A property wrapper type that makes fetch requests and retrieves the results
/// from a Core Data store.
///
/// The fetch request and its results use the managed object context provided by
/// the environment value `EnvironmentValues/managedObjectContext`.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@propertyWrapper public struct FetchRequest<Result> : DynamicProperty where Result : NSFetchRequestResult {

    /// The fetched results of the fetch request.
    ///
    /// This property returns an empty array when there are no fetched results.
    public var wrappedValue: FetchedResults<Result> { get }

    /// Creates an instance by defining a fetch request based on the parameters.
    /// - Parameters:
    ///   - entity: The kind of modeled object to fetch.
    ///   - sortDescriptors: An array of sort descriptors defines the sort
    ///     order of the fetched results.
    ///   - predicate: An NSPredicate defines a filter for the fetched results.
    ///   - animation: The animation used for any changes to the fetched
    ///     results.
    public init(entity: NSEntityDescription, sortDescriptors: [NSSortDescriptor], predicate: NSPredicate? = nil, animation: Animation? = nil) { }

    /// Creates an instance from a fetch request.
    /// - Parameters:
    ///   - fetchRequest: The request used to produce the fetched results.
    ///   - animation: The animation used for any changes to the fetched
    ///     results.
    public init(fetchRequest: NSFetchRequest<Result>, animation: Animation? = nil) { }

    /// Creates an instance from a fetch request.
    /// - Parameters:
    ///   - fetchRequest: The request used to produce the fetched results.
    ///   - transaction: The transaction used for any changes to the fetched
    ///     results.
    public init(fetchRequest: NSFetchRequest<Result>, transaction: Transaction) { }

    /// Updates the fetched results.
    ///
    /// SwiftUI calls this function before rendering a view's
    /// `View/body-swift.property` to ensure the view has the most recent
    /// fetched results.
    public mutating func update() { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension FetchRequest where Result : NSManagedObject {

    /// Creates an instance by defining a fetch request based on the parameters.
    /// The fetch request will automatically infer the entity using Result.entity().
    /// - Parameters:
    ///   - sortDescriptors: An array of sort descriptors defines the sort
    ///     order of the fetched results.
    ///   - predicate: An NSPredicate defines a filter for the fetched results.
    ///   - animation: The animation used for any changes to the fetched
    ///     results.
    public init(sortDescriptors: [NSSortDescriptor], predicate: NSPredicate? = nil, animation: Animation? = nil) { }
}

/// The FetchedResults collection type represents the results of performing a
/// fetch request. Internally, it may use strategies such as batching and
/// transparent futures to minimize memory use and I/O.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct FetchedResults<Result> : RandomAccessCollection where Result : NSFetchRequestResult {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> Result { get }

    /// A type representing the sequence's elements.
    public typealias Element = Result

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<FetchedResults<Result>>

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Slice<FetchedResults<Result>>

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>
}

/// The protocol used to serialize a document to and from a file.
///
/// Conform to this protocol to move a document between its file representation and its "swift-usable"
/// representation.
///
/// This protocol is very similar to ``ReferenceFileDocument``, with the difference being whether the data
/// is stored as a `class` (reference type) or a `struct` (value type). Use the two protocols like this:
/// - `struct` --> ``FileDocument``
/// - `class` --> `ReferenceFileDocument`
///
/// Don't worry about thread safety when using `ReferenceFileDocument`, since
/// deserialization and serialization are done on a background thread.
///
/// - Note: If your app will have documents, it very likely will be easiest to begin from Apple's own
/// Document app template. To do this, go to *File > New > Project*, and then use *Document App*.
///
/// ### Example
///
/// #### App structure
///
/// To begin, update the scene definition to use ``DocumentGroup``.
///
///     import SwiftUI
///
///     @main
///     struct ExampleApp: App {
///         var body: some Scene {
///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
///                 ContentView(document: file.$document)
///             }
///         }
///     }
///
/// #### FileDocument conformance
///
/// Next, conform to the `FileDocument` protocol by implementing these properties:
/// - A: ``FileDocument/readableContentTypes``
/// - B: ``FileDocument/init(configuration:)``
/// - C: ``FileDocument/fileWrapper(snapshot:configuration:)``
///
///     import SwiftUI
///     import UniformTypeIdentifiers
///
///     struct ExampleDocument: FileDocument {
///         var text: String
///
///         init(text: String = "This is a brand new document! 📃") {
///             self.text = text
///         }
///
///         // A
///         static var readableContentTypes: [UTType] { [.exampleText] }
///
///         // B
///         init(configuration: ReadConfiguration) throws {
///             guard let data = configuration.file.regularFileContents,
///                 let string = String(data: data, encoding: .utf8)
///             else {
///                 throw CocoaError(.fileReadCorruptFile)
///             }
///             text = string
///         }
///
///         // C
///         func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
///             let data = text.data(using: .utf8)!
///             return .init(regularFileWithContents: data)
///         }
///     }
///
/// Note that in this example, we create a custom ``FileDocument/readableContentTypes`` called `UTType.exampleText`.
///
/// #### View implementation
///
/// Finally, use the ``TextEditor`` view to edit the document file.
///
///     import SwiftUI
///
///     struct ExampleView: View {
///         @Binding var document: ExampleDocument
///
///         var body: some View {
///             TextEditor(text: $document.text)
///         }
///     }
///
/// #### UTType settings
///
/// In order for any of this to work, your Xcode project will have to define a document type. To do this,
/// follow these steps:
/// 1. Go to the Xcode project settings.
/// 2. Click on your target to the left.
/// 3. Expand the "Document Types" tab.
/// 4. Click *"Click here to add additional document type properties"*
/// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
/// 6. Ensure the **Type** is *String*.
/// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
/// 8. Change the **Types** (top right) to *com.example.plain-text*.
///
///
/// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
///
///     import SwiftUI
///     import UniformTypeIdentifiers
///
///     extension UTType {
///         static var exampleText: UTType {
///             UTType(importedAs: "com.example.plain-text")
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol FileDocument{ }
extension FileDocument {

    /// The file types the ``FileDocument`` document is able to open.
    ///
    /// The readable types of a document should be specified in its declaration. Often,
    /// the process of creating a document-based app requires a custom UTType object.
    static var readableContentTypes: [UTType] { get }

    /// The file types that a file document is able to save or export to.
    ///
    /// SwiftUI defaults the value of this to `readableContentTypes`, and it usually doesn't need
    /// to change. In the following example, `writableContentTypes` defaults to
    /// `UTType.exampleText`.
    ///
    /// ### Example
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ExampleView(document: file.$document)
    ///             }
    ///         }
    ///     }
    ///
    ///     struct ExampleDocument: FileDocument {
    ///         var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = text.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///     }
    ///
    ///     struct ExampleView: View {
    ///         @Binding var document: ExampleDocument
    ///
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    static var writableContentTypes: [UTType] { get }

    /// Initialize the file document from the contents of a file.
    ///
    /// See ``FileDocumentReadConfiguration`` to learn how to use the configuration parameter.
    ///
    /// In the following example, the initializer parses the configuration parameter
    /// to pull out the simple text `String` from the document.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.$document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### FileDocument conformance
    ///
    /// Next, conform to the `FileDocument` protocol by implementing these properties:
    /// - A: ``FileDocument/readableContentTypes``
    /// - B: ``FileDocument/init(configuration:)``
    /// - C: ``FileDocument/fileWrapper(snapshot:configuration:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     struct ExampleDocument: FileDocument {
    ///         var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = text.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @Binding var document: ExampleDocument
    ///
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    init(configuration: Self.ReadConfiguration) throws { }

    /// A type alias for referring to the configuration for reading document contents.
    ///
    /// See ``FileDocumentReadConfiguration`` to learn everything about what this
    /// type alias refers to within the ``FileDocument`` protocol.
    ///
    /// This type alias is primarily used in the protocol's required initializer,
    /// ``FileDocument/init(configuration:)``
    /// as the type of its configuration parameter.
    typealias ReadConfiguration = FileDocumentReadConfiguration

    /// Serialize the document with the specified configuration.
    ///
    /// This is essentially the "saving" function in a file document.
    ///
    /// In the following example, the `fileWrapper(snapshot:configuration:)` function
    /// simply uses the struct's `text` variable to create a new ``FileWrapper`` object.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.$document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### FileDocument conformance
    ///
    /// Next, conform to the `FileDocument` protocol by implementing these properties:
    /// - A: ``FileDocument/readableContentTypes``
    /// - B: ``FileDocument/init(configuration:)``
    /// - C: ``FileDocument/fileWrapper(snapshot:configuration:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     struct ExampleDocument: FileDocument {
    ///         var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = text.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @Binding var document: ExampleDocument
    ///
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    /// - Parameter configuration: The ``FileDocumentWriteConfiguration`` used
    /// to serialize the document.
    ///
    /// - Returns: The destination for the serialized the document. It can be a newly created
    /// ``FileWrapper` or an updated ``FileWrapper` from the one provided by `configuration`.
    func fileWrapper(configuration: Self.WriteConfiguration) throws -> FileWrapper { }

    /// A type alias used for the configuration when writing a file document.
    ///
    /// Since this is just a type alias, see ``FileDocumentWriteConfiguration`` for
    /// full information on what this type does.
    typealias WriteConfiguration = FileDocumentWriteConfiguration
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FileDocument {

    /// The types that a file document is able to save or export to.
    ///
    /// SwiftUI defaults the value of this to `readableContentTypes`, and it usually doesn't need
    /// to change. In the following example, `writableContentTypes` defaults to
    /// `UTType.exampleText`.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.$document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### FileDocument conformance
    ///
    /// Next, conform to the `FileDocument` protocol by implementing these properties:
    /// - A: ``FileDocument/readableContentTypes``
    /// - B: ``FileDocument/init(configuration:)``
    /// - C: ``FileDocument/fileWrapper(snapshot:configuration:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     struct ExampleDocument: FileDocument {
    ///         var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = text.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @Binding var document: ExampleDocument
    ///
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    public static var writableContentTypes: [UTType] { get }
}

/// The properties of an open file document.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct FileDocumentConfiguration<Document> where Document : FileDocument {

    /// The current document model.
    ///
    /// Setting a new value will mark the document as dirty for later saving
    /// as well as register an undo action to restore the model to its previous
    /// value.
    ///
    /// If `isEditable` is `false`, setting a new value will have no effect.
    public var document: Document { get nonmutating set }

    /// A read-write binding to the current document model.
    public var $document: Binding<Document> { get }

    /// The url of the open file document.
    public var fileURL: URL?

    /// Whether the document is able to be edited.
    ///
    /// This can return `false` if the document is in viewing mode or if the
    /// file is unable to be written to.
    public var isEditable: Bool
}

/// The configuration for reading file contents.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct FileDocumentReadConfiguration {

    /// The expected uniform type of the file contents.
    public let contentType: UTType

    /// The file wrapper containing the document content.
    public let file: FileWrapper
}

/// The configuration for serializing file contents.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct FileDocumentWriteConfiguration {

    /// The expected uniform type of the file contents.
    public let contentType: UTType

    /// The file wrapper containing the current document content.
    /// `nil` if the document is unsaved.
    public let existingFile: FileWrapper?
}

/// A struct style for rasterizing vector shapes.
///
/// FillStyle determines the even-odd fill mode and antialiased mode on the style.
/// When initializing a new FillStyle, eoFill is set to false by default and
/// antialiased is set to true by default.
///
/// The even-odd rule fills a path depending on what is overlapping in the path.
/// For example, a path with no overlaps will be fully filled but a path with
/// an overlap will not have the overlapping part filled. See ``FillStyle/isEOFilled`` for an example.
/// Anti-aliased smooths pixels on jagged edges by averaging the colors of the pixels
/// at the boundary.
///
/// For example, to create a view with a circle shape and fill style:
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        Circle()
///          .fill(Color.pink, style: FillStyle(eoFill: true))
///    }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct FillStyle : Equatable {

    /// A Boolean value that indicates whether to use the even-odd rule when
    /// rendering a shape.
    ///
    /// The even-odd rule fills a path depending on what is overlapping in the path.
    /// For example, a path with no overlaps will be fully filled but a path with
    /// an overlap will not have the overlapping part filled.
    ///
    /// ![FillStyle even-odd rule example 1](fillstyle-eof-example.png)
    ///
    /// ```
    /// struct EvenOddRuleView: View {
    ///    var body: some View {
    ///        VStack(spacing: 100) {
    ///            VStack {
    ///                OverlappingRectangles()
    ///                    .fill(Color.pink, style: FillStyle(eoFill: true))
    ///                    .frame(width: 150, height: 100)
    ///
    ///                Text("isEOFilled: true")
    ///            }
    ///
    ///            VStack {
    ///                OverlappingRectangles()
    ///                    .fill(Color.pink, style: FillStyle(eoFill: false))
    ///                    .frame(width: 150, height: 100)
    ///
    ///                Text("isEOFilled: false")
    ///            }
    ///        }
    ///    }
    /// }
    ///
    /// struct OverlappingRectangles: Shape {
    ///    func path(in rect: CGRect) -> Path {
    ///        let rectSize = CGSize(width: rect.height, height: rect.height)
    ///
    ///        var path = Path()
    ///
    ///        path.addRect(CGRect(origin: .zero, size: rectSize))
    ///        path.addRect(CGRect(origin: CGPoint(x: rect.width-rect.height, y: -50), size: rectSize))
    ///
    ///        return path
    ///    }
    /// }
    /// ```
    ///
    /// When `isOEFilled` is `false`, the style uses the non-zero winding number
    /// rule.
    public var isEOFilled: Bool

    /// A Boolean value that indicates whether to apply antialiasing the edges
    /// of a shape.
    public var isAntialiased: Bool

    /// Creates a new fill style with the specified settings.
    ///
    /// For example, to create a new fill style:
    ///
    /// ```
    /// struct ExampleView: View {
    ///
    ///    var body: some View {
    ///        Circle()
    ///          .fill(Color.pink, style: FillStyle(eoFill: true, antialiased: true))
    ///    }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - eoFill: A Boolean value that indicates whether to use the even-odd
    ///     rule for rendering a shape. Pass `false` to use the non-zero winding
    ///     number rule instead. If no value is specified, eoFill defaults to false.
    ///     For more information on the even-odd rule, see ``FillStyle/isOEFilled``.
    ///   - antialiased: A Boolean value that indicates whether to use
    ///     antialiasing when rendering the edges of a shape. If no value is specified
    ///     antialiased defaults to true.
    public init(eoFill: Bool = false, antialiased: Bool = true) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: FillStyle, b: FillStyle) -> Bool { }
}

/// A convenience property wrapper for observing and automatically unwrapping
/// state bindings from the focused view or one of its ancestors.
///
/// If multiple views publish bindings using the same key, the wrapped property
/// will reflect the value of the binding from the view closest to focus.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@propertyWrapper public struct FocusedBinding<Value> : DynamicProperty {

    /// A new property wrapper for the given key path.
    ///
    /// The value of the property wrapper is updated dynamically as focus
    /// changes and different published bindings go in and out of scope.
    ///
    /// - Parameter keyPath: The key path for the focus value to read.
    public init(_ keyPath: KeyPath<FocusedValues, Binding<Value>?>) { }

    /// The unwrapped value for the focus key given the current scope and state
    /// of the focused view hierarchy.
    @inlinable public var wrappedValue: Value? { get nonmutating set }

    /// A binding to the optional value.
    ///
    /// The unwrapped value is `nil` when no focused view hierarchy has
    /// published a corresponding binding.
    public var projectedValue: Binding<Value?> { get }
}

/// A property wrapper for observing values from the focused view or one of its
/// ancestors.
///
/// If multiple views publish values using the same key, the wrapped property
///  will reflect the value from the view closest to focus.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@propertyWrapper public struct FocusedValue<Value> : DynamicProperty {

    /// A new property wrapper for the given key path.
    ///
    /// The value of the property wrapper is updated dynamically as focus
    /// changes and different published values go in and out of scope.
    ///
    /// - Parameter keyPath: The key path for the focus value to read.
    public init(_ keyPath: KeyPath<FocusedValues, Value?>) { }

    /// The value for the focus key given the current scope and state of the
    /// focused view hierarchy.
    ///
    /// Returns `nil` when nothing in the focused view hierarchy exports a
    /// value.
    @inlinable public var wrappedValue: Value? { get }
}

/// A protocol for identifier types used when publishing and observing focused
/// values.
///
/// Unlike `EnvironmentKey`, `FocusedValuesHostKey` has no default value
/// requirement, because the default value for a key is always `nil`.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol FocusedValueKey{ }
extension FocusedValueKey {

	/// The type of the value that the key-value pair is using.
    associatedtype Value
}

/// A collection of state exported by the focused view and its ancestors.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct FocusedValues {

    /// Reads and writes values associated with a given environment key.
    ///
    /// Setting has no effect if the current focus scope already contains a
    /// value for the key.
    public subscript<Key>(key: Key.Type) -> Key.Value? where Key : FocusedValueKey
}

/// A font.
///
/// This structure defines a `Font` in SwiftUI. `Font` offers shorthands for varying styles of the system font via static properties, such as `Font.body` or `Font.title`.  `Font` also includes many modifiers, including ways to compare & modify fonts.
///
/// Fonts can be applied to your view with the `View/font(_:)` modifier.
///
/// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Font-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Text("Banana🍌🍌")
///            .font(.largeTitle)
///     }
/// }
/// ```
///
/// In addition to standard system font types like `largeTitle` and `body`, you can customize the size, weight and design of your `Font` with the `Font/system(size:weight:design:)` modifier.
///
/// ![Font Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Font-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Text("Banana🍌🍌")
///             .font(.system(size: 32.0, weight: .bold, design: .rounded))
///     }
/// }
/// ```
///
/// Non system-fonts can be applied using `Font/custom(_:size:)`
///
/// ![Font Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Font-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Text("Banana🍌🍌")
///            .font(Font.custom("American Typewriter", size: 32.0))
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Font : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Font, rhs: Font) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Font {

    /// A font with the large title text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    public static let largeTitle: Font

    /// A font with the title text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    public static let title: Font

    /// Create a font for second level hierarchical headings.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public static let title2: Font

    /// Create a font for third level hierarchical headings.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public static let title3: Font

    /// A font with the headline text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    public static let headline: Font

    /// A font with the subheadline text style.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Text("Banana🍌🍌")
    ///            .font(.title)
    ///     }
    /// }
    /// ```
    public static let subheadline: Font

    /// A font with the body text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    public static let body: Font

    /// A font with the callout text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    public static let callout: Font

    /// A font with the footnote text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    public static let footnote: Font

    /// A font with the caption text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    public static let caption: Font

    /// Create a font with the alternate caption text style.
    ///
    /// ![Font Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/font-types.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Group {
    ///             Text("LargeTitle 🍌🍌")
    ///                 .font(.largeTitle)
    ///             Text("Title 🍌🍌")
    ///                 .font(.title)
    ///             Text("Title2 🍌🍌")
    ///                 .font(.title2)
    ///             Text("Title3 🍌🍌")
    ///                 .font(.title3)
    ///             Text("Headline 🍌🍌")
    ///                 .font(.headline)
    ///             Text("Subheadline 🍌🍌")
    ///                 .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body 🍌🍌")
    ///                 .font(.body)
    ///             Text("Callout 🍌🍌")
    ///                 .font(.callout)
    ///             Text("Caption 🍌🍌")
    ///                 .font(.caption)
    ///             Text("Caption2 🍌🍌")
    ///                 .font(.caption2)
    ///             Text("Footnote 🍌🍌")
    ///                 .font(.footnote)
    ///
    ///         }
    ///     }
    /// }
    /// ```
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public static let caption2: Font

    /// Gets a system font with the given style and design.
    ///
    /// Font's `system(_:design:)` is an easy way to modify standard fonts.
    ///
    /// For example, basic usage would be:
    ///
    ///         struct ExampleView: View {
    ///             var body: some View {
    ///                 Text("Bananas 🍌🍌")
    ///                     .font(Font.system(.title))
    ///             }
    ///         }
    ///
    /// Your app can easily modify the system font by providing an alternate `desigin`. For example:
    ///
    ///         struct ExampleView: View {
    ///             var body: some View {
    ///                 Text("Bananas 🍌🍌")
    ///                     .font(Font.system(.title, design: .monospaced))
    ///             }
    ///         }
    ///
    public static func system(_ style: Font.TextStyle, design: Font.Design = .default) -> Font { }

    /// A dynamic text style to use for fonts.
    ///
    /// There are 11 font styles that SwiftUI provides
    ///
    /// - ``font/textstyle/largetitle``
    /// - ``font/textstyle/title``
    /// -  ``font/textstyle/title2``
    /// - ``font/textstyle/title3``
    /// - ``font/textstyle/headline``
    /// - ``font/textstyle/subheadline``
    /// - ``font/textstyle/body``
    /// - ``font/textstyle/callout``
    /// - ``font/textstyle/footnote`
    /// - ``font/textstyle/caption`
    /// - ``font/textstyle/caption2`
    ///
    /// ![TextStyle Example 1](text-style-example.png)
    ///
    /// ```
    /// struct TextStyleView: View {
    ///     var body: some View {
    ///         Group{
    ///             Text("Large Title")
    ///                 .font(.largeTitle)
    ///             Text("Title")
    ///                 .font(.title)
    ///             Text("Title 2")
    ///                 .font(.title2)
    ///             Text("Title 3")
    ///                 .font(.title3)
    ///             Text("Headline")
    ///                 .font(.headline)
    ///             Text("SubHeadline")
    ///                .font(.subheadline)
    ///         }
    ///         Group {
    ///             Text("Body")
    ///                 .font(.body)
    ///             Text("Callout")
    ///                 .font(.callout)
    ///            Text("Footnote")
    ///                 .font(.footnote)
    ///             Text("Caption")
    ///                 .font(.caption)
    ///              Text("Caption2")
    ///                .font(.caption2)
    ///      }
    ///       }
    ///  }
    /// ```

    public enum TextStyle : CaseIterable {

        /// The font style for large titles.
        ///
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        ///
        case largeTitle

        /// The font used for first level hierarchical headings.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        case title

        /// The font used for second level hierarchical headings.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
        case title2

        /// The font used for third level hierarchical headings.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
        case title3

        /// The font used for headings.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        case headline

        /// The font used for subheadings.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        case subheadline

        /// The font used for body text.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        case body

        /// The font used for callouts.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        case callout

        /// The font used in footnotes.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        case footnote

        /// The font used for standard captions.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        case caption

        /// The font used for alternate captions.
        ///
        /// ![TextStyle Example 1](text-style-example.png)
        ///
        /// ```
        /// struct TextStyleView: View {
        ///     var body: some View {
        ///         Group{
        ///             Text("Large Title")
        ///                 .font(.largeTitle)
        ///             Text("Title")
        ///                 .font(.title)
        ///             Text("Title 2")
        ///                 .font(.title2)
        ///             Text("Title 3")
        ///                 .font(.title3)
        ///             Text("Headline")
        ///                 .font(.headline)
        ///             Text("SubHeadline")
        ///                .font(.subheadline)
        ///         }
        ///         Group {
        ///             Text("Body")
        ///                 .font(.body)
        ///             Text("Callout")
        ///                 .font(.callout)
        ///            Text("Footnote")
        ///                 .font(.footnote)
        ///             Text("Caption")
        ///                 .font(.caption)
        ///              Text("Caption2")
        ///                .font(.caption2)
        ///      }
        ///       }
        ///  }
        /// ```
        @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
        case caption2

        /// A collection of all values of this type.
        public static var allCases: [Font.TextStyle]

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Font.TextStyle, b: Font.TextStyle) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [Font.TextStyle]
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Font {

    /// Adds italics to the font.
    public func italic() -> Font { }

    /// Adjusts the font to enable all small capitals.
    ///
    /// See `Font/lowercaseSmallCaps()` and `Font/uppercaseSmallCaps()` for
    /// more details.
    public func smallCaps() -> Font { }

    /// Adjusts the font to enable lowercase small capitals.
    ///
    /// This function turns lowercase characters into small capitals for the
    /// font. It is generally used for display lines set in large and small
    /// caps, such as titles. It may include forms related to small capitals,
    /// such as old-style figures.
    public func lowercaseSmallCaps() -> Font { }

    /// Adjusts the font to enable uppercase small capitals.
    ///
    /// This feature turns capital characters into small capitals. It is
    /// generally used for words which would otherwise be set in all caps, such
    /// as acronyms, but which are desired in small-cap form to avoid disrupting
    /// the flow of text.
    public func uppercaseSmallCaps() -> Font { }

    /// Adjusts the font to use monospace digits.
    ///
    /// For example, to adjust a ``Text`` to use monospaced digits:
    ///
    /// ![monospacedDigit example 1](monospaced-digit-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    @State private var toggleStatus: Bool = false
    ///
    ///    var body: some View {
    ///        Text("Some monospaced digits: 0123456789")
    ///            .font(Font.system(size: 15).monospacedDigit())
    ///    }
    /// }
    /// ```
    ///
    /// Note that this does not actually update the font to use the `.monospace` design.
    /// Rather, it updates digits to have a "fixed" width. For an example of the difference
    /// between a normal proportional font and a monospaced font on digits see:
    ///
    /// Proportional font:
    /// ![Proportional font example](monospaced-digit-proportional-font.png)
    ///
    /// Monospaced font:
    /// ![Monospaced font example](monospaced-digit-mono-font.png)
    /// [Image credits to Lior Azi](https://blog.usejournal.com/proportional-vs-monospaced-numbers-when-to-use-which-one-in-order-to-avoid-wiggling-labels-e31b1c83e4d0)
    public func monospacedDigit() -> Font { }

    /// Sets the weight of the font.
    ///
    /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
    ///
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             VStack {
    ///                 Text("ultraLight 🍌")
    ///                     .fontWeight(Font.Weight.ultraLight)
    ///                 Text("thin🍌")
    ///                     .fontWeight(Font.Weight.thin)
    ///                 Text("light🍌")
    ///                     .fontWeight(Font.Weight.light)
    ///                 Text("regular🍌")
    ///                     .fontWeight(Font.Weight.regular)
    ///                 Text("medium🍌")
    ///                     .fontWeight(Font.Weight.medium)
    ///                 Text("semibold🍌")
    ///                     .fontWeight(Font.Weight.semibold)
    ///                 Text("bold🍌")
    ///                     .fontWeight(Font.Weight.bold)
    ///                 Text("heavy🍌")
    ///                     .fontWeight(Font.Weight.heavy)
    ///                 Text("black🍌")
    ///                     .fontWeight(Font.Weight.black)
    ///            }
    ///            .font(.title)
    ///         }
    ///     }
    ///
    ///
    public func weight(_ weight: Font.Weight) -> Font { }

    /// Adds bold styling to the font.
    public func bold() -> Font { }

    /// Create a version of `self` that uses leading (line spacing) adjustment.
    ///
    /// The availability of leading adjustments depends on font.
    ///
    /// For example, `Font.body.tightLeading()` will return a `Font` in `body`
    /// text style with tight line spacing. This modifier may return the
    /// original `Font` unchanged for some fonts.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public func leading(_ leading: Font.Leading) -> Font { }

    /// A weight to use for fonts.
    @frozen public struct Weight : Hashable {

    	/// A font weight of ultra light.
      ///
      /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
      ///
      ///
      ///     struct ExampleView: View {
      ///         var body: some View {
      ///             VStack {
      ///                 Text("ultraLight 🍌")
      ///                     .fontWeight(Font.Weight.ultraLight)
      ///                 Text("thin🍌")
      ///                     .fontWeight(Font.Weight.thin)
      ///                 Text("light🍌")
      ///                     .fontWeight(Font.Weight.light)
      ///                 Text("regular🍌")
      ///                     .fontWeight(Font.Weight.regular)
      ///                 Text("medium🍌")
      ///                     .fontWeight(Font.Weight.medium)
      ///                 Text("semibold🍌")
      ///                     .fontWeight(Font.Weight.semibold)
      ///                 Text("bold🍌")
      ///                     .fontWeight(Font.Weight.bold)
      ///                 Text("heavy🍌")
      ///                     .fontWeight(Font.Weight.heavy)
      ///                 Text("black🍌")
      ///                     .fontWeight(Font.Weight.black)
      ///            }
      ///            .font(.title)
      ///         }
      ///     }
      ///
      ///
        public static let ultraLight: Font.Weight

        /// A font weight of thin.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let thin: Font.Weight

        /// A font weight of light.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let light: Font.Weight

        /// A font weight of regular.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let regular: Font.Weight

        /// A font weight of medium.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let medium: Font.Weight

        /// A font weight of semibold.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let semibold: Font.Weight

        /// A font weight of bold.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let bold: Font.Weight

        /// A font weight of heavy.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let heavy: Font.Weight

        /// A font weight of black.
        ///
        /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
        ///
        ///
        ///     struct ExampleView: View {
        ///         var body: some View {
        ///             VStack {
        ///                 Text("ultraLight 🍌")
        ///                     .fontWeight(Font.Weight.ultraLight)
        ///                 Text("thin🍌")
        ///                     .fontWeight(Font.Weight.thin)
        ///                 Text("light🍌")
        ///                     .fontWeight(Font.Weight.light)
        ///                 Text("regular🍌")
        ///                     .fontWeight(Font.Weight.regular)
        ///                 Text("medium🍌")
        ///                     .fontWeight(Font.Weight.medium)
        ///                 Text("semibold🍌")
        ///                     .fontWeight(Font.Weight.semibold)
        ///                 Text("bold🍌")
        ///                     .fontWeight(Font.Weight.bold)
        ///                 Text("heavy🍌")
        ///                     .fontWeight(Font.Weight.heavy)
        ///                 Text("black🍌")
        ///                     .fontWeight(Font.Weight.black)
        ///            }
        ///            .font(.title)
        ///         }
        ///     }
        ///
        ///
        public static let black: Font.Weight

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Font.Weight, b: Font.Weight) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }

    /// The different types of line spacing.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public enum Leading {

    	/// Normal, medium line spacing.
        case standard

        /// Tight, small line spacing.
        case tight

        /// Loose, large line spacing.
        case loose

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Font.Leading, b: Font.Leading) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Font {

    /// Specifies a system font to use, along with the style, weight, and any
    /// design parameters you want applied to the text.
    ///
    /// Use this function to create a system font by specifying the size and
    /// weight, and a type design together. The following styles the system font
    /// as 17 point, `Font/Weight/semibold` text:
    ///
    ///     Text("Hello").font(.system(size: 17, weight: .semibold))
    ///
    /// While the following styles the text as 17 point `Font/Weight/bold`,
    /// and applies a `serif` `Font/Design` to the system font:
    ///
    ///     Text("Hello").font(.system(size: 17, weight: .bold, design: .serif))
    ///
    /// If you want to use the default `Font/Weight`
    /// (`Font/Weight/regular`), you don't need to specify the `weight` in the
    /// method. The following example styles the text as 17 point
    /// `Font/Weight/regular`, and uses a `Font/Design/rounded` system font:
    ///
    ///     Text("Hello").font(.system(size: 17, design: .rounded))
    ///
    /// Other examples of system font include:
    ///
    ///         struct ExampleView: View {
    ///             var body: some View {
    ///                 Text("Bananas 🍌🍌")
    ///                     .font(.system(size: 32, weight: .light, design: .monospaced))
    ///             }
    ///         }
    ///
    /// And:
    ///
    ///         struct ExampleView: View {
    ///             var body: some View {
    ///                 Text("Bananas 🍌🍌")
    ///                     .font(.system(size: 32, weight: .heavy, design: .rounded))
    ///             }
    ///         }
    ///
    public static func system(size: CGFloat, weight: Font.Weight = .regular, design: Font.Design = .default) -> Font { }

    /// A design to use for fonts.
    public enum Design : Hashable {

    	/// The standard sans-serif font design.
        case `default`

        /// A font design with serifs, or small strokes attached to the end of letters.
        @available(watchOS 7.0, *)
        case serif

        /// A rounded font design.
        case rounded

        /// A monospaced font design.
        @available(watchOS 7.0, *)
        case monospaced

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Font.Design, b: Font.Design) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Font {

    /// Create a custom font with the given `name` and `size` that scales with
    /// the body text style.
    public static func custom(_ name: String, size: CGFloat) -> Font { }

    /// Create a custom font with the given `name` and `size` that scales
    /// relative to the given `textStyle`.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public static func custom(_ name: String, size: CGFloat, relativeTo textStyle: Font.TextStyle) -> Font { }

    /// Create a custom font with the given `name` and a fixed `size` that does
    /// not scale with Dynamic Type.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public static func custom(_ name: String, fixedSize: CGFloat) -> Font { }

    /// Creates a custom font from a platform font instance.
    ///
    /// Initializing `Font` with platform font instance
    /// (<doc://com.apple.documentation/documentation/CoreText/CTFont-q6r>) can bridge SwiftUI
    /// `Font` with <doc://com.apple.documentation/documentation/AppKit/NSFont> or
    /// <doc://com.apple.documentation/documentation/UIKit/UIFont>, both of which are
    /// toll-free bridged to
    /// <doc://com.apple.documentation/documentation/CoreText/CTFont-q6r>. For example:
    ///
    ///     // Use native Core Text API to create desired ctFont.
    ///     let ctFont = CTFontCreateUIFontForLanguage(.system, 12, nil)!
    ///
    ///     // Create SwiftUI Text with the CTFont instance.
    ///     let text = Text("Hello").font(Font(ctFont))
    public init(_ font: CTFont) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Font.TextStyle : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Font.TextStyle : Hashable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Font.Leading : Equatable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Font.Leading : Hashable {
}

/// Creates views from a collection of identified data.
///
/// ForEach supports three identifiers:
/// * `ForEach/init(_:content:)-ed9f4`, for iterating over a range
/// * `ForEach/init(_:content:)-72c77`, for iterating over data that conforms to identifiable
/// * `ForEach/init(_:id:content:)` for iterating over that can be identified, but does not conform to identifiable
///
/// ### Iterating over a range
/// [[foreach-fixed-range]]
///
/// ### Iterating over `Identifiable` data
/// [[foreach-identifiable-content]]
///
/// ### Explicitly identifying data
/// [[foreach-dynamic-content]]
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ForEach<Data, ID, Content> where Data : RandomAccessCollection, ID : Hashable {

    /// The collection of underlying identified data that SwiftUI uses to create
    /// views dynamically.
    public var data: Data

    /// A function you can use to create content on demand using the underlying
    /// data.
    public var content: (Data.Element) -> Content
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ForEach : DynamicViewContent where Content : View {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ForEach : View where Content : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ForEach where ID == Data.Element.ID, Content : View, Data.Element : Identifiable {

    /// Creates a view from data that conforms to `Identifiable`.
    /// [foreach-identifiable-content ->]
    /// If your data does not conform to identifiable, use `ForEach/init(_:id:content)`.
    ///
    /// Note: if your data does not conform to identifiable you will receive the following error:
    ///
    /// `Initializer 'init(_:rowContent:)' requires that ‘SomeType’ conform to 'Identifiable`
    ///
    /// An array of primitive types, such as strings & ints, will throw this error. Identify these items with `id: \.self` – because they themselves can be used as the identifiable object. See more in `ForEach/init(_:id:content)`.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     let myFruits: [Fruit] = [
    ///         Fruit(emoji: "🍌🍌", name: "Banana"),
    ///         Fruit(emoji: "🍑🍑", name: "Peach"),
    ///         Fruit(emoji: "🍎🍎", name: "Apple")
    ///     ]
    ///
    ///     var body: some View {
    ///         ForEach(myFruits) { fruit in
    ///             HStack {
    ///                 Text(fruit.name + fruit.emoji)
    ///             }
    ///         }
    ///     }
    /// }
    ///
    /// struct Fruit: Identifiable {
    ///     var emoji: String
    ///     var name: String
    ///     //  Create a unique ID for our object
    ///     //  This idea allows Fruit to conform to Identifiable
    ///     let id = UUID()
    /// }
    /// ```
    /// [<-]
    /// Note:  It's important that the `id` of a data element doesn't change unless you
    /// replace the data element with a new data element that has a new
    /// identity. If the `id` of a data element changes, the content view
    /// generated from that data element loses any current state and animations.
    ///
    /// - Parameters:
    ///   - data: The identified data that the `ForEach` instance uses to
    ///     create views dynamically.
    ///   - content: The view builder that creates views dynamically.
    public init(_ data: Data, @ViewBuilder content: @escaping (Data.Element) -> Content) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ForEach where Content : View {

    /// Creates an instance that uniquely identifies and computes views.
    /// [foreach-dynamic-content ->]
    /// For data that does not conform to `Identifiable`, use this initializer.
    ///
    /// A very common use case for this initialier is iterating over primitive data, such as strings or ints. In the following example, the fruit string is used as the identifiable unit.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     let myFruits: [String] = ["🍌🍌", "🍑🍑", "🍎🍎"]
    ///
    ///     var body: some View {
    ///         ForEach(myFruits, id:/\.self) { fruit in
    ///             HStack {
    ///                 Text(fruit)
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// This initializer can also be used with objects that don't conform to `Identifiable`, but have identifiable properties. For example:
    ///
    /// ```
    /// struct ExampleView: View {
    ///     let myFruits: [Fruit] = [
    ///         Fruit(emoji: "🍌🍌", name: "Banana"),
    ///         Fruit(emoji: "🍑🍑", name: "Peach"),
    ///         Fruit(emoji: "🍎🍎", name: "Apple")
    ///     ]
    ///
    ///     var body: some View {
    ///         ForEach(myFruits, id:/\.emoji) { fruit in
    ///             HStack {
    ///                 Text(fruit.name + fruit.emoji)
    ///             }
    ///         }
    ///     }
    /// }
    ///
    /// struct Fruit {
    ///     var emoji: String
    ///     var name: String
    /// }
    /// ```
    ///
    /// Notice, this initializer can be used for data that can change. For example:
    ///
    /// ![Changing List](foreach.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var myFruits: [String] = ["🍌🍌", "🍑🍑", "🍎🍎"]
    ///
    ///     var body: some View {
    ///         Button("New Fruit") {
    ///             newFruit()
    ///         }
    ///
    ///         ForEach(myFruits, id:\.self) { fruit in
    ///             HStack {
    ///                 Text(fruit)
    ///             }
    ///         }
    ///     }
    ///
    ///     func newFruit() {
    ///         let allFruit: [String] = ["🍏🍏", "🍒🍒", "🍓🍓", "🥝🥝", "🥭🥭", "🍊🍊", "🍍🍍"]
    ///
    ///         myFruits.append(allFruit.randomElement()!)
    ///     }
    /// }
    /// ```
    ///
    /// **Note:** This initializer works well for externally loaded data. It enables your app's frontend to automatically reflect data as it arrives.
    /// [<-]
    /// **Note:** It's important that the `id` of a data element doesn't change, unless
    /// SwiftUI considers the data element to have been replaced with a new data
    /// element that has a new identity. If the `id` of a data element changes,
    /// then the content view generated from that data element will lose any
    /// current state and animations.
    ///
    /// - Parameters:
    ///   - data: The data that the `ForEach` instance uses to create views
    ///     dynamically.
    ///   - id: The key path to the provided data's identifier.
    ///   - content: The view builder that creates views dynamically.
    public init(_ data: Data, id: KeyPath<Data.Element, ID>, @ViewBuilder content: @escaping (Data.Element) -> Content) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ForEach where Data == Range<Int>, ID == Int, Content : View {

    /// Computes views over a given constant range.
    /// [foreach-fixed-range ->]
    /// This initializer is ForEach's most trivial. It is analogous to a common for loop.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     let myFruits: [String] = ["🍌🍌", "🍑🍑", "🍎🍎"]
    ///
    ///     var body: some View {
    ///         ForEach(0..<myFruits.count) { index in
    ///             HStack {
    ///                 Text(myFruits[index])
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// Notice however, that this view is only rendered once. Therefore, if `myFruits.count` changes, the view will **not update**. For example, clicking `New Fruit` in the following code returns the error:
    ///
    /// `ForEach(_:content:) should only be used for *constant* data.`
    ///
    /// ```
    /// struct ErrorView: View {
    ///     @State var myFruits: [String] = ["🍌🍌", "🍑🍑", "🍎🍎"]
    ///
    ///     var body: some View {
    ///         Button("New Fruit") {
    ///             newFruit()
    ///         }
    ///
    ///         ForEach(0..<myFruits.count) { index in
    ///             HStack {
    ///                 Text(myFruits[index])
    ///             }
    ///         }
    ///     }
    ///
    ///     func newFruit() {
    ///         let allFruit: [String] = ["🍏🍏", "🍒🍒", "🍓🍓", "🥝🥝", "🥭🥭", "🍊🍊", "🍍🍍"]
    ///
    ///         myFruits.append(allFruit.randomElement()!)
    ///     }
    /// }
    /// ```
    ///
    /// The instance only reads the initial value of the provided `data` and
    /// doesn't need to identify views across updates. To compute views on
    /// demand over a dynamic range, use `ForEach/init(_:id:content:)`.
    /// [<-]
    ///
    /// - Parameters:
    ///   - data: A constant range.
    ///   - content: The view builder that creates views dynamically.
    public init(_ data: Range<Int>, @ViewBuilder content: @escaping (Int) -> Content) { }
}

/// A ShapeStyle that shows the correct fill for the foreground based on the current
/// context.
///
/// For example, to create a square view with a ForegroundStyle:
///
/// ![ForegroundStyle Example 1](foreground-style-example.png)
///
/// ```
/// struct ForegroundStyleRectangle: View {
///    var body: some View {
///        Rectangle()
///            .fill(ForegroundStyle())
///            .frame(width: 150, height: 150)
///            .foregroundColor(Color.pink)
///    }
///
/// }
/// ```
///
/// Note:
/// - ForegroundStyle is typically the default ShapeStyle, so it is rare to explicitly need it.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ForegroundStyle {

    /// Creates a foreground style.
    ///
    /// For example, to create a square view with a ForegroundStyle:
    ///
    /// ```
    /// struct ForegroundStyleRectangle: View {
    ///    var body: some View {
    ///        Rectangle()
    ///            .fill(ForegroundStyle())
    ///            .frame(width: 150, height: 150)
    ///            .foregroundColor(Color.pink)
    ///    }
    /// }
    /// ```
    @inlinable public init() { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ForegroundStyle : ShapeStyle {
}

/// A container for grouping controls used for data entry, such as in settings
/// or inspectors.
///
/// SwiftUI renders forms in a manner appropriate for the platform. For example,
/// on iOS, forms appear as grouped lists. Use `Section` to group different
/// parts of a form's content.
///
/// For example,
///
/// ![Form Example 1](form-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     let gradient = Gradient(colors: [.red,.yellow])
///     @State private var myFruit = ""
///
///     var body: some View {
///         Form {
///             TextField("Banana 🍌", text: $myFruit)
///             TextField("Banana 🍌", text: $myFruit)
///             TextField("Banana 🍌", text: $myFruit)
///         }
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Form<Content> : View where Content : View {

	/// Creates a form from a view builder containing child views.
	///
	/// The content of a form is almost always different `Section`s.
	///
    ///
	/// The form view knows how to arrange standard controls inside it such as pickers, textfields and toggles.
    /// However, when using a custom control results are undefined.
    ///
    /// Controls can be grouped using the ``Section`` view as seen in the example below.
    ///
    /// ![Form Example 2](form-example-2.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     let gradient = Gradient(colors: [.red,.yellow])
    ///     @State private var email = ""
    ///     @State private var first = ""
    ///     @State private var last = ""
    ///     @State private var not = true
    ///     @State private var dark = true
    ///
    ///
    ///     var body: some View {
    ///         Form {
    ///             Section(header: Text("Contact Information")) {
    ///                 TextField("First Name", text: $first)
    ///                 TextField("Last Name ", text: $last)
    ///                 TextField("Email", text: $email)
    ///             }
    ///             Section(header: Text("Preferences")) {
    ///                 Toggle(isOn: $not) {
    ///                     Text("Notifications ")
    ///                 }
    ///                 Toggle(isOn: self.$dark) {
    ///                         Text("Dark Mode ")
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    ///
    ///
	/// - Parameter content: A closure that returns the view to the `Form`.
	///
	/// - SeeAlso: Section
    public init(@ViewBuilder content: () -> Content) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

/// An effect that changes the visual appearance of a view, largely without
/// changing its ancestors or descendants.
///
/// The only change the effect makes to the view's ancestors and descendants is
/// to change the coordinate transform to and from them.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol GeometryEffect : Animatable, ViewModifier where Self.Body == Never{ }
extension GeometryEffect : Animatable, ViewModifier where Self.Body == Never {

    /// Returns the current value of the effect.
    func effectValue(size: CGSize) -> ProjectionTransform { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension GeometryEffect {

    /// Returns an effect that produces the same geometry transform as this
    /// effect, but only applies the transform while rendering its view.
    ///
    /// Use this method to disable layout changes during transitions. The view
    /// ignores the transform returned by this method while the view is
    /// performing its layout calculations.
    @inlinable public func ignoredByLayout() -> _IgnoredByLayoutEffect<Self> { }
}

/// A proxy that encapsulates the container's frame and safe area insets, used by ``GeometryReader``.
///
/// For example, to create a new GeometryProxy for use in a GeometryReader:
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         GeometryReader { (proxy: GeometryProxy) in
///             Color.green
///                 .frame(
///                     width: proxy.size.width / 2,
///                     height: proxy.size.height / 2
///                 )
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct GeometryProxy {

    /// The size of the container view.
    public var size: CGSize { get }

    /// Converts the anchor to a value in the coordinate space of the target view.
    public subscript<T>(anchor: Anchor<T>) -> T { get }

    /// The safe area inset of the container view.
    public var safeAreaInsets: EdgeInsets { get }

    /// Returns the parent ``GeometryReader``'s frame, converted to a defined
    /// ``CoordinateSpace``.
    public func frame(in coordinateSpace: CoordinateSpace) -> CGRect { }
}

/// A type that reads the geometry of its container to produce a view.
///
/// ### How it works
///
/// `GeometryReader` can be expressed simply with the following pseudocode:
///
/// ```
/// struct GeometryReader<Content: View> {
///     var content: (GeometryProxy) -> Content
///
///     var body: some View {
///         content(<container geometry>)
///     }
/// }
/// ```
///
/// In the implementation above, `<container geometry>` is an instance of `GeometryProxy`. `GeometryProxy` simply encapsulates the container's frame and safe area insets, provided at runtime by SwiftUI.
///
/// ### `GeometryReader` to get container bounds
///
/// In this example, `GeometryReader` is used to create a view scaled down to exactly half of its parent container:
///
/// ![GeometryReader Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/GeometryReader-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         GeometryReader { (proxy: GeometryProxy) in
///             Color.green
///                 .frame(
///                     width: proxy.size.width / 2,
///                     height: proxy.size.height / 2
///                 )
///         }
///     }
/// }
/// ```
///
/// Note: `GeometryReader` **fills into** its parent container, and the current default alignment of its content is `.topLeading`. The example above results in a green rectangle aligned to the top left corner of the screen, inset by the screen's safe area. The alignment cannot be overriden, and is liable to change in the future.
///
/// ### `GeometryReader` to get a view's frame
///
/// `GeometryReader` can also be used with`View/background(_:)`, to acquire the geometry of a target view. Consider `SomeView` in the following example:
///
/// ```
/// struct ExampleView: View {
///     struct SomeView: View {
///         var body: some View {
///             Rectangle()
///                 .fill(Color.red)
///                 .frame(width: 500, height: 500)
///         }
///     }
///
///     @State var someFrame: CGRect? // will be updated after the first layout pass
///
///     var body: some View {
///         VStack {
///             SomeView()
///                 .frame(width: 500, height: 500)
///                 .background(
///                     GeometryReader { (proxy: GeometryProxy) -> EmptyView in
///                         if someFrame != proxy.frame(in: .global) {
///                             DispatchQueue.main.async {
///                                 someFrame = proxy.frame(in: .global)
///                             }
///                         }
///
///                         return EmptyView()
///                     }
///                 )
///             Text("Hello, World!")
///         }
///     }
/// }
/// ```
///
/// Note that `someFrame` will be updated to hold the frame of `SomeView`, *not* the frame of its container, the `VStack`. This is achieved by forcing a `GeometryReader` as a background of `SomeView`, thereby constraining it to `SomeView`'s bounds.
///
/// This task of acquiring a view's frame can be done in a generic and reusable way using `ViewModifier`:
///
/// ![GeometryReader Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/GeometryReader-example-2.png)
///
/// ```
/// struct GetGlobalFrame: ViewModifier {
///     @Binding var globalFrame: CGRect?
///
///     func body(content: Content) -> some View {
///         content.background(
///             GeometryReader { (proxy: GeometryProxy) -> EmptyView in
///                 if globalFrame != proxy.frame(in: .global) {
///                     DispatchQueue.main.async {
///                         globalFrame = proxy.frame(in: .global)
///                     }
///                 }
///
///                 return EmptyView()
///             }
///         )
///     }
/// }
/// ```
///
/// The modifier above can be used in the following manner:
///
/// ![GeometryReader Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/GeometryReader-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     struct SomeView: View {
///         var body: some View {
///             Rectangle()
///                 .fill(Color.red)
///                 .frame(width: 500, height: 500)
///         }
///     }
///
///     @State var someFrame: CGRect? // will be updated after the first layout pass
///
///     var body: some View {
///         VStack {
///             SomeView()
///                 .frame(width: 500, height: 500)
///                 .modifier(GetGlobalFrame(globalFrame: $someFrame))
///
///             Text("Hello, World!")
///         }
///     }
/// }
///
/// struct GetGlobalFrame: ViewModifier {
///     @Binding var globalFrame: CGRect?
///
///     func body(content: Content) -> some View {
///         content.background(
///             GeometryReader { (proxy: GeometryProxy) -> EmptyView in
///                 if globalFrame != proxy.frame(in: .global) {
///                     DispatchQueue.main.async {
///                         globalFrame = proxy.frame(in: .global)
///                     }
///                 }
///
///                 return EmptyView()
///             }
///         )
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct GeometryReader<Content> : View where Content : View {

	/// The content displayed within the `GeometryReader` view.
	///
	/// Unlike traditional view builders, the content builder is generated from
	/// a parameter of type `GeometryProxy`, giving you access to the geometric
	/// properties of the parent view.
    public var content: (GeometryProxy) -> Content

    /// Creates a `GeometryReader` parent view using the parent's geometry.
    ///
    /// - Parameter content: A closure that takes the geometry of the parent view and returns a content view.
    @inlinable public init(@ViewBuilder content: @escaping (GeometryProxy) -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// An instance that matches a sequence of events to a gesture, and returns a
/// stream of values for each of its states.
///
/// Create custom gestures by declaring types that conform to the `Gesture`
/// protocol.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol Gesture{ }
extension Gesture {

    /// The type representing the gesture's value.
    associatedtype Value

    /// The type of gesture representing the body of `Self`.
    associatedtype Body : Gesture

    /// The content and behavior of the gesture.
    var body: Self.Body { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Sequences a gesture with another one to create a new gesture, which
    /// results in the second gesture only receiving events after the first
    /// gesture succeeds.
    ///
    /// - Parameter other: A gesture you want to combine with another gesture to
    ///   create a new, sequenced gesture.
    ///
    /// - Returns: A gesture that's a sequence of two gestures.
    @inlinable public func sequenced<Other>(before other: Other) -> SequenceGesture<Self, Other> where Other : Gesture { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Combines a gesture with another gesture to create a new gesture that
    /// recognizes both gestures at the same time.
    ///
    /// - Parameter other: A gesture that you want to combine with your gesture
    ///   to create a new, combined gesture.
    ///
    /// - Returns: A gesture with two simultaneous gestures.
    @inlinable public func simultaneously<Other>(with other: Other) -> SimultaneousGesture<Self, Other> where Other : Gesture { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Adds an action to perform when the gesture ends.
    ///
    /// - Parameter action: The action to perform when this gesture ends. The
    ///   `action` closure's parameter contains the final value of the gesture.
    ///
    /// - Returns: A gesture that triggers `action` when the gesture ends.
    public func onEnded(_ action: @escaping (Self.Value) -> Void) -> _EndedGesture<Self> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture where Self.Value : Equatable {

    /// Adds an action to perform when the gesture's value changes.
    ///
    /// - Parameter action: The action to perform when this gesture's value
    ///   changes. The `action` closure's parameter contains the gesture's new
    ///   value.
    ///
    /// - Returns: A gesture that triggers `action` when this gesture's value
    ///   changes.
    public func onChanged(_ action: @escaping (Self.Value) -> Void) -> _ChangedGesture<Self> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Returns a gesture that's the result of mapping the given closure over
    /// the gesture.
    public func map<T>(_ body: @escaping (Self.Value) -> T) -> _MapGesture<Self, T> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Combines two gestures exclusively to create a new gesture where only one
    /// gesture succeeds, giving precedence to the first gesture.
    ///
    /// - Parameter other: A gesture you combine with your gesture, to create a
    ///   new, combined gesture.
    ///
    /// - Returns: A gesture that's the result of combining two gestures where
    ///   only one of them can succeed. SwiftUI gives precedence to the first
    ///   gesture.
    @inlinable public func exclusively<Other>(before other: Other) -> ExclusiveGesture<Self, Other> where Other : Gesture { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Gesture {

    /// Updates the provided gesture state property as the gesture's value
    /// changes.
    ///
    /// Use this callback to update transient UI state as described in
    /// <doc:Adding-Interactivity-with-Gestures>.
    ///
    /// - Parameters:
    ///   - state: A binding to a view's `GestureState` property.
    ///   - body: The callback that SwiftUI invokes as the gesture's value
    ///     changes. Its `currentState` parameter is the updated state of the
    ///     gesture. The `gestureState` parameter is the previous state of the
    ///     gesture, and the `transaction` is the context of the gesture.
    ///
    /// - Returns: A version of the gesture that updates the provided `state` as
    ///   the originating gesture's value changes, and that resets the `state`
    ///   to its initial value when the users cancels or ends the gesture.
    @inlinable public func updating<State>(_ state: GestureState<State>, body: @escaping (Self.Value, inout State, inout Transaction) -> Void) -> GestureStateGesture<Self, State> { }
}

/// Options that control how adding a gesture to a view affect's other gestures
/// recognized by the view and its subviews.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct GestureMask : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: UInt32

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: UInt32) { }

    /// Disable all gestures in the subview hierarchy, including the added
    /// gesture.
    public static let none: GestureMask

    /// Enable the added gesture but disable all gestures in the subview
    /// hierarchy.
    public static let gesture: GestureMask

    /// Enable all gestures in the subview hierarchy but disable the added
    /// gesture.
    public static let subviews: GestureMask

    /// Enable both the added gesture as well as all other gestures on the view
    /// and its subviews.
    public static let all: GestureMask

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = GestureMask

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = GestureMask

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = UInt32
}

/// A property wrapper type that updates a property while the user performs a
/// gesture and resets the property back to its initial state when the gesture
/// ends.
///
/// Declare a property as `@GestureState`, pass as a binding to it as a
/// parameter to a gesture's `Gesture/updating(_:body:)` callback, and receive
/// updates to it. A property that's declared as `@GestureState` implicitly
/// resets when the gesture becomes inactive, making it suitable for tracking
/// transient state.
///
/// Add a long-press gesture to a `Circle`, and update the interface during
/// the gesture by declaring a property as `@GestureState`:
///
///     struct SimpleLongPressGestureView: View {
///         @GestureState var isDetectingLongPress = false
///
///         var longPress: some Gesture {
///             LongPressGesture(minimumDuration: 3)
///                 .updating($isDetectingLongPress) { currentstate, gestureState, transaction in
///                     gestureState = currentstate
///                 }
///         }
///
///         var body: some View {
///             Circle()
///                 .fill(self.isDetectingLongPress ? Color.red : Color.green)
///                 .frame(width: 100, height: 100, alignment: .center)
///                 .gesture(longPress)
///         }
///     }
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@propertyWrapper @frozen public struct GestureState<Value> : DynamicProperty {

    /// Creates a view state that's derived from a gesture.
    ///
    /// - Parameter wrappedValue: A wrapped value for the gesture state
    ///   property.
    public init(wrappedValue: Value) { }

    /// Creates a view state that's derived from a gesture with an initial
    /// value.
    ///
    /// - Parameter initialValue: An initial value for the gesture state
    ///   property.
    public init(initialValue: Value) { }

    /// Creates a view state that's derived from a gesture with a wrapped state
    /// value and a transaction to reset it.
    ///
    /// - Parameters:
    ///   - wrappedValue: A wrapped value for the gesture state property.
    ///   - resetTransaction: A transaction that provides metadata for view
    ///     updates.
    public init(wrappedValue: Value, resetTransaction: Transaction) { }

    /// Creates a view state that's derived from a gesture with an initial state
    /// value and a transaction to reset it.
    ///
    /// - Parameters:
    ///   - initialValue: An initial state value.
    ///   - resetTransaction: A transaction that provides metadata for view
    ///     updates.
    public init(initialValue: Value, resetTransaction: Transaction) { }

    /// Creates a view state that's derived from a gesture with a wrapped state
    /// value and a closure that provides a transaction to reset it.
    ///
    /// - Parameters:
    ///   - wrappedValue: A wrapped value for the gesture state property.
    ///   - reset: A closure that provides a `Transaction`.
    public init(wrappedValue: Value, reset: @escaping (Value, inout Transaction) -> Void) { }

    /// Creates a view state that's derived from a gesture with an initial state
    /// value and a closure that provides a transaction to reset it.
    ///
    /// - Parameters:
    ///   - initialValue: An initial state value.
    ///   - reset: A closure that provides a `Transaction`.
    public init(initialValue: Value, reset: @escaping (Value, inout Transaction) -> Void) { }

    /// The wrapped value referenced by the gesture state property.
    public var wrappedValue: Value { get }

    /// A binding to the gesture state property.
    public var projectedValue: GestureState<Value> { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension GestureState where Value : ExpressibleByNilLiteral {

    /// Creates a view state that's derived from a gesture with a transaction to
    /// reset it.
    ///
    /// - Parameter resetTransaction: A transaction that provides metadata for
    ///   view updates.
    public init(resetTransaction: Transaction = Transaction()) { }

    /// Creates a view state that's derived from a gesture with a closure that
    /// provides a transaction to reset it.
    ///
    /// - Parameter reset: A closure that provides a `Transaction`.
    public init(reset: @escaping (Value, inout Transaction) -> Void) { }
}

/// A gesture that updates the state provided by a gesture's updating callback.
///
/// A gesture's `Gesture/updating(_:body:)` callback returns a
/// `GestureStateGesture` instance for updating a transient state property
/// that's annotated with the `GestureState` property wrapper.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct GestureStateGesture<Base, State> : Gesture where Base : Gesture {

    /// The type representing the gesture's value.
    public typealias Value = Base.Value

    /// The originating gesture.
    public var base: Base

    /// A value that changes as the user performs the gesture.
    public var state: GestureState<State>

    /// The updating gesture containing the originating gesture's value, the
    /// updated state of the gesture, and a transaction.
    public var body: (GestureStateGesture<Base, State>.Value, inout State, inout Transaction) -> Void

    /// Creates a new gesture that's the result of an ongoing gesture.
    ///
    /// - Parameters:
    ///   - base: The originating gesture.
    ///   - state: The wrapped value of a `GestureState` property.
    ///   - body: The callback that SwiftUI invokes as the gesture's value
    ///     changes.
    @inlinable public init(base: Base, state: GestureState<State>, body: @escaping (GestureStateGesture<Base, State>.Value, inout State, inout Transaction) -> Void) { }

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

/// A color gradient represented as an array of color stops, each having a
/// parametric location value.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Gradient : Equatable {

    /// One color stop in the gradient.
    @frozen public struct Stop : Equatable {

        /// The color for the stop.
        public var color: Color

        /// The parametric location of the stop.
        ///
        /// This value must be in the range `[0, 1]`.
        public var location: CGFloat

        /// Creates a color stop with a color and location.
        public init(color: Color, location: CGFloat) { }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Gradient.Stop, b: Gradient.Stop) -> Bool { }
    }

    /// The array of color stops.
    public var stops: [Gradient.Stop]

    /// Creates a gradient from an array of color stops.
    public init(stops: [Gradient.Stop]) { }

    /// Creates a gradient from an array of colors.
    ///
    /// The gradient synthesizes its location values to evenly space the colors
    /// along the gradient.
    public init(colors: [Color]) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Gradient, b: Gradient) -> Bool { }
}

/// An interactive calendar or clock.
///
/// > "This style is useful when wanting to allow browsing through days in a calendar, or when the look of a clock face is appropriate."
///
/// ![Graphical Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/date-pickerstyle-graphical-example-1.gif)
///
///
///      struct ExampleView: View {
///          @State var date: Date = Date()
///
///          var body: some View {
///              DatePicker("Date",selection: $date)
///                 .datePickerStyle(GraphicalDatePickerStyle())
///                 .padding()
///          }
///      }
///
///
@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GraphicalDatePickerStyle : DatePickerStyle {

	/// Create a graphical date picker style.
    public init() { }
}

/// A description of a single grid item, such as a row or a column.
///
/// You use `GridItem` instances to configure the layout of items in
/// `LazyHGrid` and `LazyVGrid` views. Each grid item specifies layout
/// properties like spacing and alignment, which the grid view uses to size and
/// position all items in a given column or row.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct GridItem {

    /// The size in the minor axis of one or more rows or columns in a grid
    /// layout.
    ///
    /// There are three types of sizes:
    /// 1. ``griditem/size/fixed``
    /// 2. ``griditem/size/flexible`
    /// 3. ``griditem/size/adaptive``
    ///
    public enum Size {

        /// A single item with the specified fixed size.
        case fixed(CGFloat)

        /// A single flexible item.
        ///
        /// The size of this item is the size of the grid with spacing and
        /// inflexible items removed, divided by the number of flexible items,
        /// clamped to the provided bounds.
        case flexible(minimum: CGFloat = 10, maximum: CGFloat = .infinity)

        /// Multiple items in the space of a single flexible item.
        ///
        /// This size case places one or more items into the space assigned to
        /// a single `flexible` item, using the provided bounds and
        /// spacing to decide exactly how many items fit. This approach prefers
        /// to insert as many items of the `minimum` size as possible
        /// but lets them increase to the `maximum` size.
        case adaptive(minimum: CGFloat, maximum: CGFloat = .infinity)
    }

    /// The size of the item, which is the width of a column item or the
    /// height of a row item.
    public var size: GridItem.Size

    /// The spacing to the next item.
    ///
    /// If this value is `nil`, the item uses a reasonable default for the
    /// current platform.
    public var spacing: CGFloat?

    /// The alignment to use when placing each view.
    ///
    /// Use this property to anchor the view's relative position to the same
    /// relative position in the view's assigned grid space.
    public var alignment: Alignment?

    /// Creates a grid item with the provided size, spacing, and alignment
    /// properties.
    ///
    /// - Parameters:
    ///   - size: The size of the grid item.
    ///   - spacing: The spacing to use between this and the next item.
    ///   - alignment: The alignment to use for this grid item.
    public init(_ size: GridItem.Size = .flexible(), spacing: CGFloat? = nil, alignment: Alignment? = nil) { }
}

/// A structure that groups other structure together.
///
/// Use this structure to group together structures of different types.
/// There are five different types of groups. Each groups together
/// a type of content.
///
/// 1. ``ToolbarContent``
/// 2. ``CustomizableToolbarContent``
/// 3. ``Scene``
/// 4. ``View``
/// 5. ``Commands``
///
/// There are 2 main reasons to use a `Group`:
/// - To exceed the 10 struct limitation of a function builder
/// - To improve code readability.
///
/// Here is an example creating a `Group` of `View`s:
///
/// 	var body: some View {
///         Group {
/// 			Text("1")
/// 			Text("2")
/// 			Text("3")
/// 			Text("4")
/// 			Text("5")
/// 		}
/// 	}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Group<Content> {

    /// The type of content representing the body of this toolbar content.
    public typealias Body = Never
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Group : ToolbarContent where Content : ToolbarContent {

	/// Creates a `Group` from toolbar content.
    ///
    /// Groups are particularly useful when you want several toolbar items to act
	/// together.
	///
	/// Another time when `Group` is useful is when trying to return more than
	/// 10 toolbar items to a toolbar content builder at once. For technical reasons, a toolbar content
	/// builder can generally only take 10 toolbar items at once. So if you try to do
	/// this, you'll get an error:
	///
    /// ```
    /// struct ErrorView: View {
    ///     var body: some View {
    ///         EmptyView()
    ///             .toolbar {
    ///                 ToolbarItem { Text("1") }
    ///                 ToolbarItem { Text("2") }
    ///                 ToolbarItem { Text("3") }
    ///                 ToolbarItem { Text("4") }
    ///                 ToolbarItem { Text("5") }
    ///                 ToolbarItem { Text("6") }
    ///                 ToolbarItem { Text("7") }
    ///                 ToolbarItem { Text("8") }
    ///                 ToolbarItem { Text("9") }
    ///                 ToolbarItem { Text("10") }
    ///                 ToolbarItem { Text("11") } //ERROR!
    ///             }
    ///     }
    /// }
    /// ```
	///
	/// Instead, you should put your toolbar items into `Group`s:
	///
    ///
    /// ```
    /// struct NoErrorView: View {
    ///     var body: some View {
    ///         EmptyView()
    ///             .toolbar {
    ///                 Group {
    ///                     ToolbarItem { Text("1") }
    ///                     ToolbarItem { Text("2") }
    ///                     ToolbarItem { Text("3") }
    ///                     ToolbarItem { Text("4") }
    ///                     ToolbarItem { Text("5") }
    ///                 }
    ///                 Group {
    ///                     ToolbarItem { Text("6") }
    ///                     ToolbarItem { Text("7") }
    ///                     ToolbarItem { Text("8") }
    ///                     ToolbarItem { Text("9") }
    ///                     ToolbarItem { Text("10") }
    ///                     ToolbarItem { Text("11") } //No error 😎
    ///                 }
    ///             }
    ///     }
    /// }
    /// ```
	///
	/// - Parameter content: A toolbar content builder.
    public init(@ToolbarContentBuilder content: () -> Content) { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Group : CustomizableToolbarContent where Content : CustomizableToolbarContent {

	/// Creates a `Group` from a customizable toolbar content.
    ///
    /// Groups are particularly useful when you want several customizable toolbar items to act
	/// together.
	///
	/// Another time when `Group` is useful is when trying to return more than
	/// 10 customizable toolbar items to a toolbar content builder at once. For technical reasons, a toolbar content
	/// builder can generally only take 10 customizable toolbar items at once. So if you try to do
	/// this, you'll get an error:
    ///
    /// ```
    /// struct ErrorView: View {
    ///     var body: some View {
    ///         EmptyView()
    ///             .toolbar(id: "customizabletoolbar") {
    ///                 ToolbarItem(id: "1", placement: .automatic) { Text("1") }
    ///                 ToolbarItem(id: "2", placement: .automatic) { Text("2") }
    ///                 ToolbarItem(id: "3", placement: .automatic) { Text("3") }
    ///                 ToolbarItem(id: "4", placement: .automatic) { Text("4") }
    ///                 ToolbarItem(id: "5", placement: .automatic) { Text("5") }
    ///                 ToolbarItem(id: "6", placement: .automatic) { Text("6") }
    ///                 ToolbarItem(id: "7", placement: .automatic) { Text("7") }
    ///                 ToolbarItem(id: "8", placement: .automatic) { Text("8") }
    ///                 ToolbarItem(id: "9", placement: .automatic) { Text("9") }
    ///                 ToolbarItem(id: "10", placement: .automatic) { Text("10") }
    ///                 ToolbarItem(id: "11", placement: .automatic) { Text("11") } //ERROR!
    ///             }
    ///     }
    /// }
    /// ```
	///
	/// Instead, you should put your toolbar items into `Group`s:
	///
    ///
    /// ```
    /// struct NoErrorView: View {
    ///     var body: some View {
    ///         EmptyView()
    ///             .toolbar(id: "customizabletoolbar") {
    ///                 Group {
    ///                     ToolbarItem(id: "1", placement: .automatic) { Text("1") }
    ///                     ToolbarItem(id: "2", placement: .automatic) { Text("2") }
    ///                     ToolbarItem(id: "3", placement: .automatic) { Text("3") }
    ///                     ToolbarItem(id: "4", placement: .automatic) { Text("4") }
    ///                     ToolbarItem(id: "5", placement: .automatic) { Text("5") }
    ///                 }
    ///                 Group {
    ///                     ToolbarItem(id: "6", placement: .automatic) { Text("6") }
    ///                     ToolbarItem(id: "7", placement: .automatic) { Text("7") }
    ///                     ToolbarItem(id: "8", placement: .automatic) { Text("8") }
    ///                     ToolbarItem(id: "9", placement: .automatic) { Text("9") }
    ///                     ToolbarItem(id: "10", placement: .automatic) { Text("10") }
    ///                     ToolbarItem(id: "11", placement: .automatic) { Text("11") } //No error 😎
    ///                 }
    ///             }
    ///     }
    /// }
    /// ```
	///
	/// - Parameter content: A toolbar content builder.
    public init(@ToolbarContentBuilder content: () -> Content) { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Group : Scene where Content : Scene {

	/// Creates a `Group` of from component scenes.
	///
    /// Groups are particularly useful when you want several scenes to act
	/// together.
	///
	/// Another time when `Group` is useful is when trying to return more than
	/// 10 scenes to a scene builder at once. For technical reasons, a scene
	/// builder can generally only take 10 scenes at once. So if you try to do
	/// this, you'll get an error:
	///
    /// ```
    /// @main
    /// struct ErrorApp: App {
	/// 	var body: some Scene {
    ///         WindowGroup(id: "id1") { ContentView() }
    ///         WindowGroup(id: "id2") { ContentView() }
    ///         WindowGroup(id: "id3") { ContentView() }
    ///         WindowGroup(id: "id4") { ContentView() }
    ///         WindowGroup(id: "id5") { ContentView() }
    ///         WindowGroup(id: "id6") { ContentView() }
    ///         WindowGroup(id: "id7") { ContentView() }
    ///         WindowGroup(id: "id8") { ContentView() }
    ///         WindowGroup(id: "id9") { ContentView() }
    ///         WindowGroup(id: "id10") { ContentView() }
    ///         WindowGroup(id: "id11") { ContentView() } //ERROR!
	/// 	}
    /// ```
	///
	/// Instead, you should put your scenes into `Group`s:
	///
    /// ```
    /// @main
    /// struct NoErrorApp: App {
	/// 	var body: some Scene {
    ///         Group {
    ///             WindowGroup(id: "id1") { ContentView() }
    ///             WindowGroup(id: "id2") { ContentView() }
    ///             WindowGroup(id: "id3") { ContentView() }
    ///             WindowGroup(id: "id4") { ContentView() }
    ///             WindowGroup(id: "id5") { ContentView() }
    ///             WindowGroup(id: "id6") { ContentView() }
    ///         }
    ///         Group {
    ///             WindowGroup(id: "id7") { ContentView() }
    ///             WindowGroup(id: "id8") { ContentView() }
    ///             WindowGroup(id: "id9") { ContentView() }
    ///             WindowGroup(id: "id10") { ContentView() }
    ///             WindowGroup(id: "id11") { ContentView() } //No error 😎
    ///         }
	/// 	}
    /// ```
    ///
	/// - Parameter content: A scene builder.
    @inlinable public init(@SceneBuilder content: () -> Content) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Group : View where Content : View {

	/// Creates a `Group` from view content.
	///
	/// Groups are particularly useful when you want several views to act
	/// together, like for example, in transitions.
	///
	/// Another time when `Group` is useful is when trying to return more than
	/// 10 views to a view builder at once. For technical reasons, a view
	/// builder can generally only take 10 views at once. So if you try to do
	/// this, you'll get an error:
	///
	/// 	var body: some View {
	/// 		VStack {
	/// 			Text("1")
	/// 			Text("2")
	/// 			Text("3")
	/// 			Text("4")
	/// 			Text("5")
	/// 			Text("6")
	/// 			Text("7")
	/// 			Text("8")
	/// 			Text("9")
	/// 			Text("10")
	/// 			Text("11") // ERROR!
	/// 		}
	/// 	}
	///
	/// Instead, you should put your text into `Group`s:
	///
	/// 	var body: some View {
	/// 		VStack {
	/// 			Group {
	/// 				Text("1")
	/// 				Text("2")
	/// 				Text("3")
	/// 				Text("4")
	/// 				Text("5")
	/// 			}
	///				Group {
	///					Text("6")
	/// 				Text("7")
	/// 				Text("8")
	/// 				Text("9")
	/// 				Text("10")
	/// 				Text("11") //No error 😎
	///				}
	/// 		}
	/// 	}
	///
	/// - Parameter content: A view content builder.
    @inlinable public init(@ViewBuilder content: () -> Content) { }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Group : Commands where Content : Commands {

	/// Creates a `Group` from command content.
	///
    /// Groups are particularly useful when you want several commands to act
	/// together.
	///
	/// Another time when `Group` is useful is when trying to return more than
	/// 10 commands to a command builder at once. For technical reasons, a command
	/// builder can generally only take 10 commands at once. So if you try to do
	/// this, you'll get an error:
	///
    /// ```
    /// @main
    /// struct ErrorApp: App {
	/// 	var body: some Scene {
    ///         WindowGroup {
    ///             ContentView()
    ///         }
    ///         .commands {
    ///             EmptyCommands() //1
    ///             EmptyCommands() //2
    ///             EmptyCommands() //3
    ///             EmptyCommands() //4
    ///             EmptyCommands() //5
    ///             EmptyCommands() //6
    ///             EmptyCommands() //7
    ///             EmptyCommands() //8
    ///             EmptyCommands() //9
    ///             EmptyCommands() //10
    ///             EmptyCommands() //11 - ERROR!
	/// 		}
	/// 	}
    /// ```
	///
	/// Instead, you should put your commands into `Group`s:
	///
    /// ```
    /// @main
    /// struct NoErrorApp: App {
	/// 	var body: some Scene {
    ///         WindowGroup {
    ///             ContentView()
    ///         }
    ///         .commands {
    ///             Group {
    ///                 EmptyCommands() //1
    ///                 EmptyCommands() //2
    ///                 EmptyCommands() //3
    ///                 EmptyCommands() //4
    ///                 EmptyCommands() //5
    ///                 EmptyCommands() //6
    ///             }
    ///             Group {
    ///                 EmptyCommands() //7
    ///                 EmptyCommands() //8
    ///                 EmptyCommands() //9
    ///                 EmptyCommands() //10
    ///                 EmptyCommands() //11 - No error 😎
    ///             }
	/// 		}
	/// 	}
    /// }
    /// ```
    ///
	/// - Parameter content: A command content builder.
    @inlinable public init(@CommandsBuilder content: () -> Content) { }
}

/// A stylized view with an optional label that is associated with a logical
/// grouping of content.
@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GroupBox<Label, Content> : View where Label : View, Content : View {

	/// Creates a group box from a label and a view builder of content.
	///
	/// - Parameters:
	///   - label: The label to associate with the grouped content.
	///   - content: The grouped content to appear with the label.
    public init(label: Label, @ViewBuilder content: () -> Content) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GroupBox where Label == GroupBoxStyleConfiguration.Label, Content == GroupBoxStyleConfiguration.Content {

    /// Creates an instance representing the configuration of a `GroupBoxStyle`.
    public init(_ configuration: GroupBoxStyleConfiguration) { }
}

@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GroupBox where Label == EmptyView {

	/// Creates a group box from only content, without including a label.
	///
	/// - Parameter content: The grouped content that you want in the group box.
    public init(@ViewBuilder content: () -> Content) { }
}

/// This protocol is used to create a style for a GroupBox
///
/// By using GroupBoxStyle, the style can be used for a ``GroupBox`` across your application.
/// To configure the current `GroupBoxStyle` for a view hiearchy, you only need to use the
/// `.groupBoxStyle()` modifier.
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol GroupBoxStyle{ }
extension GroupBoxStyle {

    /// A `View` representing the body of a `GroupBox`.
    associatedtype Body : View

    /// Creates a `View` representing the body of a `GroupBox`.
    ///
    /// Implement this method to create the view for a `GroupBox` that uses this style.
    /// The configuration contains:
    /// - label
    /// - content
    ///
    /// For example,
    ///     struct ExampleView: View {
    ///     @State private var username: String = ""
    ///     @State private var password: String = ""
    ///
    ///     var body: some View {
    ///         GroupBox(label: Text("Account Login")) {
    ///             Form {
    ///                 Text("Username")
    ///                 TextField("", text: $username)
    ///
    ///                 Text("Password")
    ///                 SecureField("", text: $password)
    ///
    ///             }.padding(10)
    ///         }
    ///         .groupBoxStyle(MyStyle())
    ///         .frame(width: 300)
    ///     }
    ///
    //     struct MyStyle: GroupBoxStyle {
    //         func makeBody(configuration: Configuration) -> some View {
    //             VStack {
    //                 HStack {
    //                     Rectangle().fill(Color.red).frame(width: 30, height: 3)

    //                     configuration.label

    //                     Rectangle().fill(Color.red).frame(width: 30, height: 3)
    //                 }

    //                 configuration.content
    //             }
    //         }
    //     }
    // }

    /// - Parameter configuration: The properties of the group box instance being
    ///   created.
    ///
    /// This method will be called for each instance of `GroupBox` created within
    /// a view hierarchy where this style is the current `GroupBoxStyle`.
    func makeBody(configuration: Self.Configuration) -> Self.Body { }

    /// The properties of a `GroupBox` instance being created.
    typealias Configuration = GroupBoxStyleConfiguration
}

/// The properties of a `GroupBox` instance being created.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GroupBoxStyleConfiguration {

    /// A type-erased label of a `GroupBox`.
    public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A type-erased content of a `GroupBox`.
    public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A view that describes the `GroupBox`.
    public let label: GroupBoxStyleConfiguration.Label

    /// A view that represents the content of the `GroupBox`.
    public let content: GroupBoxStyleConfiguration.Content
}

/// A standard grouped list style.
///
/// ![GroupedListStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/liststyle-grouped-example-1.png)
///
///
///      struct ExampleView: View {
///          var body: some View {
///             List {
///              Text("Bananas 🍌🍌")
///              Text("Apples 🍎🍎")
///              Text("Peaches 🍑🍑")
///             }
///             .listStyle(GroupedListStyle())
///          }
///      }
///
///
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct GroupedListStyle : ListStyle {

    /// Creates a grouped list style.
    public init() { }
}

/// A view that arranges children horizontally.
///
/// `HStack` is a horizontal stack of views.
///
///  ![HStack Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/hstack-example-1.png)
///
///     struct ExampleView: View {
///         var body: some View {
///             HStack {
///                 Text("🍌🍌")
///                 Text("🍏🍏")
///                 Text("🍑🍑")
///             }
///         }
///     }
///
/// Modify your stack's alignment or spacing with the built in initializer.
///
///  ![HStack Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/hstack-example-2.png)
///
///     struct ExampleView: View {
///         var body: some View {
///             HStack(alignment: .top, spacing: 32) {
///                 Text("🍌🍌")
///                 Text("🍏🍏")
///                 Text("🍑🍑")
///             }
///         }
///     }
///
/// Learn more about the properties of each alignment choice via the `VerticalAlignment` struct.
///
/// `HStack` uses a `ViewBuilder` to construct the content.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct HStack<Content> : View where Content : View {

    /// Creates an instance with the given spacing and vertical alignment.
    ///
    ///  ![HStack Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/hstack-example-2.png)
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             HStack(alignment: .top, spacing: 32) {
    ///                 Text("🍌🍌")
    ///                 Text("🍏🍏")
    ///                 Text("🍑🍑")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - alignment: The guide for aligning the subviews in this stack. It has
    ///     the same vertical screen coordinate for all children.
    ///   - spacing: The distance between adjacent subviews, or `nil` if you
    ///     want the stack to choose a default distance for each pair of
    ///     subviews.
    ///   - content: A view builder that creates the content of this stack.
    @inlinable public init(alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, @ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// An alignment position along the horizontal axis.
///
/// Use this structure in the initializers of 3 structures:
/// - ``VStack``
/// - ``LazyVStack``
/// - ``LazyVGrid``
///
/// See those pages for more on how to construct them.
///
/// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
/// view modifier. See that page for more on adding alignment
/// guides to views.
///
/// There are just 3 possible horizontal alignments:
/// 1. ``HorizontalAlignment/leading``
/// 2. ``HorizontalAlignment/center``
/// 3. ``HorizontalAlignment/trailing``
///
/// See the example below for all three.
///
/// ```
/// struct HorizontallyAlignedView: View {
///     var body: some View {
///         VStack(alignment: HorizontalAlignment.leading) {
///             Text("⬅️")
///         }
///         VStack(alignment: HorizontalAlignment.center) {
///             Text("🤠")
///         }
///         VStack(alignment: HorizontalAlignment.trailing) {
///             Text("➡️")
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct HorizontalAlignment : Equatable {

    /// Creates an instance with the given identifier.
    ///
    /// In addition to the 3 out-of-the-box horizontal alignments,
    /// leading, center, and trailing, you can also create your own
    /// custom horizontal alignment. Do this by passing this intializer
    /// a ``AlignmentID.Type`` from an ``AlignmentID``.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``VStack``
    /// - ``LazyVStack``
    /// - ``LazyVGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// extension HorizontalAlignment {
    ///     private enum HeightBasedAlignment: AlignmentID {
    ///         static func defaultValue(in d: ViewDimensions) -> CGFloat {
    ///             return d.height
    ///         }
    ///     }
    ///     static let height = HorizontalAlignment(HeightBasedAlignment.self)
    /// }
    /// ```
    ///
    /// See [this article](https://swiftui-lab.com/alignment-guides/) for help with alignment guides.
    ///
    /// - Parameter id: An identifier that uniquely identifies the horizontal
    ///   alignment.
    public init(_ id: AlignmentID.Type) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: HorizontalAlignment, b: HorizontalAlignment) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension HorizontalAlignment {

    /// A guide marking the leading edge of the view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``VStack``
    /// - ``LazyVStack``
    /// - ``LazyVGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct HorizontallyAlignedView: View {
    ///     var body: some View {
    ///         VStack(alignment: .leading) {
    ///             Text("⬅️")
    ///     }
    /// }
    /// ```
    public static let leading: HorizontalAlignment

    /// A guide marking the horizontal center of the view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``VStack``
    /// - ``LazyVStack``
    /// - ``LazyVGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct HorizontallyAlignedView: View {
    ///     var body: some View {
    ///         VStack(alignment: .center) {
    ///             Text("🤠")
    ///     }
    /// }
    /// ```
    public static let center: HorizontalAlignment

    /// A guide marking the trailing edge of the view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``VStack``
    /// - ``LazyVStack``
    /// - ``LazyVGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct HorizontallyAlignedView: View {
    ///     var body: some View {
    ///         VStack(alignment: .trailing) {
    ///             Text("➡️")
    ///     }
    /// }
    /// ```
    public static let trailing: HorizontalAlignment
}

/// An effect applied when the pointer hovers over a view.
///
/// HoverEffects are only used on iPadOS when a user is interacting with a pointer.
/// See ``View/hoverEffect(_:)`` for how to apply the different HoverEffects.
/// The available options are:
/// - automatic: the default effect for the platform
/// - highlight: morphs the pointer into a platter behind the view and shows a light source
/// - lift: slides the pointer under the view and scaled up the view with a shadow
///
/// For example:
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        VStack {
///            Rectangle()
///                .fill(Color.red)
///                .frame(width: 100, height: 100)
///                .hoverEffect(.automatic)
///        }.padding(75).background(Color.blue)
///    }
/// }
/// ```
///
/// See the individual HoverEffect value pages for a visualization of each effect.
@available(iOS 13.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct HoverEffect {

    /// An effect that attempts to determine the effect automatically.
    /// This is the default effect.
    ///
    /// For example:
    ///
    /// ![Hover effect automatic example](hovereffect-automatic-example.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        VStack {
    ///            Rectangle()
    ///                .fill(Color.red)
    ///                .frame(width: 100, height: 100)
    ///                .hoverEffect(.automatic)
    ///        }.padding(75).background(Color.blue)
    ///    }
    /// }
    /// ```
    public static let automatic: HoverEffect

    /// An effect that morphs the pointer into a platter behind the view
    /// and shows a light source indicating position.
    ///
    /// For example:
    ///
    /// ![Hover effect highlight example](hovereffect-highlight-example.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        VStack {
    ///            Rectangle()
    ///                .fill(Color.red)
    ///                .frame(width: 100, height: 100)
    ///                .hoverEffect(.highlight)
    ///        }.padding(75).background(Color.blue)
    ///    }
    /// }
    /// ```
    public static let highlight: HoverEffect

    /// An effect that slides the pointer under the view and disappears as the
    /// view scales up and gains a shadow.
    ///
    /// For example:
    ///
    /// ![Hover effect lift example](hovereffect-lift-example.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        VStack {
    ///            Rectangle()
    ///                .fill(Color.red)
    ///                .frame(width: 100, height: 100)
    ///                .hoverEffect(.lift)
    ///        }.padding(75).background(Color.blue)
    ///    }
    /// }
    /// ```
    public static let lift: HoverEffect
}

/// A label style that only displays the icon of the label.
///
/// ![IconOnlyLabelStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/labelstyle-icon-only-example-1.png)
///
///
///    struct ExampleView: View {
///        var body: some View {
///             Label("Banana🍌", systemImage: "heart.fill")
///                 .labelStyle(IconOnlyLabelStyle())
///        }
///    }
///
///
/// > The title of the label is still used for non-visual descriptions, such as VoiceOver.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct IconOnlyLabelStyle : LabelStyle {

    /// Creates an icon-only label style.
    public init() { }

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each `Label` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    public func makeBody(configuration: IconOnlyLabelStyle.Configuration) -> some View { }


    /// A view that represents the body of a label.
    public typealias Body = some View
}

/// A view that displays a drawable resource
///
/// Images in SwiftUI are much easier than in UIKit. Instead of needing to create a UIImage(named: “Your file name”) and assigning it to yourUIImageView.image, Image is about as easy to create as Text.
///
/// Just pass it a String and it’ll set it to a file with that name. If you launch your app and it doesn’t have a file with that name, you’ll get a useful console message saying:
///
///  `No image named ‘Your file name’ found in asset catalog for main bundle.`
///
/// If you find images not turning up in your app, you may want to search for this in the console.
///
/// ```
/// struct ExampleView: View {
///   var body: some View {
///     List {
///       Image("Your file name")
///       Image("Your file name", bundle: Bundle.main)
///         .resizable()
///         .frame(width: 100)
///       Image("Your file name", label: Text("My image label"))
///         .resizable()
///         .scaledToFit()
///       Image(decorative: "Your file name")
///         .resizable()
///         .scaledToFill()
///       Image(systemName: "gamecontroller")
///       Image(uiImage: UIImage(named: "Your file name")!)
///       Image(decorative: UIImage(named: "Your file name")!.cgImage!, scale: 0.5, orientation: .rightMirrored)
///     }
///   }
/// }```
/// ### Image is not resizable by default
///
/// The `.resizable()` modifier must come first on an Image before making changes to its size in subsequent modifiers. The `scaledToFit` modifier will lock the aspect ratio of the image and scale it to the maximum size it can be without being too large for the screen. The `scaledToFill` modifier also scales the image, but it does not lock the aspect ratio and, subsequently, is likely to stretch or shrink the image to fit the available space.
///
/// ### SF Symbols
///
/// SF Symbols is a library of over 1500 symbols that Apple provides in nine weights from ultralight to black. To use these in custom images, simply label the String is passed into an Image as systemName. It’s probably worth downloading the SF Symbols Mac app to make the symbol names easier to find. Using SF Symbols gives your app a consistent look that will probably be taking over the iOS ecosystem in the coming years due to the flexibility and accessibility of these free symbols.
///
/// Xcode 12 brought support for use in Mac apps. Attempting to use Image(systemNamed:) to use an SF Symbol in Xcode 11 causes the error “Extraneous argument label ‘systemNamed:’ in call”. This means that you could not use SF Symbols in any native Mac app or even a Catalyst app, as macOS had no way of displaying them. As of Xcode 12 and macOS 11 Big Sur, you will not get those warnings and can use Image(systemNamed:) in native macOS and Mac Catalyst apps.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Image : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Image, rhs: Image) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

    /// Creates a labeled image that you can use as content for controls.
    ///
    /// - Parameters:
    ///   - name: the name of the image resource to lookup, as well as the
    ///     localization key with which to label the image.
    ///   - bundle: the bundle to search for the image resource and localization
    ///     content. If `nil`, uses the main `Bundle`. Defaults to `nil`.
    public init(_ name: String, bundle: Bundle? = nil) { }

    /// Creates a labeled image that you can use as content for controls, with
    /// the specified label.
    ///
    /// - Parameters:
    ///   - name: the name of the image resource to lookup
    ///   - bundle: the bundle to search for the image resource. If `nil`, uses
    ///     the main `Bundle`. Defaults to `nil`.
    ///   - label: The label associated with the image. The label is used for
    ///     things like accessibility.
    public init(_ name: String, bundle: Bundle? = nil, label: Text) { }

    /// Creates an unlabeled, decorative image.
    ///
    /// This image is ignored for accessibility purposes.
    ///
    /// - Parameters:
    ///   - name: the name of the image resource to lookup
    ///   - bundle: the bundle to search for the image resource. If `nil`, uses
    ///     the main `Bundle`. Defaults to `nil`.
    public init(decorative name: String, bundle: Bundle? = nil) { }

    /// Creates a system symbol image.
    ///
    /// This initializer creates an image using a system-provided symbol. To
    /// create a custom symbol image from your app's asset catalog, use
    /// `init(_:)` instead.
    ///
    /// - Parameters:
    ///   - systemName: The name of the system symbol image.
    ///     Use the SF Symbols app to look up the names of system symbol images.
    @available(macOS 11.0, *)
    public init(systemName: String) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

	/// Modifies the image rendering mode as either regular or template.
	///
	/// There are two types of rendering modes:
	/// - Original
	/// - Template
	///
	/// Original mode will draw the image normally, as-is. Template mode will
	/// turn all the parts of the image that are not transparent to one color
	/// that you can set yourself. By default, the color is black.
	///
	/// A common use case for this modifier would be like this:
	///
	/// 	Image("Bird")
	/// 		.renderingMode(.template)
	/// 		.resizable()
	/// 		.frame(width: 50, height: 50)
	/// 		.foregroundColor(.blue)
	///
	/// The modifier does nothing if renderingMode is `nil`.
	///
	/// - Parameter renderingMode: The image rendering mode.
	///
	/// - SeeAlso: Image.TemplateRenderingMode.
    public func renderingMode(_ renderingMode: Image.TemplateRenderingMode?) -> Image { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

    /// Constants that specify the intended display orientation for an image.
    @frozen public enum Orientation : UInt8, CaseIterable, Hashable {

    	/// The original pixel data matches the intended display orientation.
        case up

        /// The image has been horizontally flipped from the orientation of its
        /// original pixel data.
        case upMirrored

        /// The image has been rotated 180° from the orientation of its original
        /// pixel data.
        case down

        /// The image has been vertically flipped from the orientation of its
        /// original pixel data.
        case downMirrored

        /// The image has been rotated 90° counterclockwise from the orientation
        /// of its original pixel data.
        case left

        /// The image has been rotated 90° clockwise and flipped horizontally
        /// from the orientation of its original pixel data.
        case leftMirrored

        /// The image has been rotated 90° clockwise from the orientation of its
        /// original pixel data.
        case right

        /// The image has been rotated 90° counterclockwise and flipped
        /// horizontally from the orientation of its original pixel data.
        case rightMirrored

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = UInt8

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: UInt8) { }

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: UInt8 { get }

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [Image.Orientation]

        /// A collection of all values of this type.
        public static var allCases: [Image.Orientation] { get }
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

	/// Options for rendering the image normally, or with only 1 color.
    public enum TemplateRenderingMode {

    	/// Render the image as all black except where opacity is 0.
    	///
    	/// This is often used if the image is going to be a mask or otherwise
    	/// used only for its outline.
        case template

        /// Render the image as usual.
        case original

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Image.TemplateRenderingMode, b: Image.TemplateRenderingMode) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }

    /// The scale to apply to vector images relative to text.
    @available(macOS 11.0, *)
    public enum Scale {

    	/// The small image scale size.
    	///
    	/// - SeeAlso: Image.imageScale(_:)
        case small

        /// The medium image scale size.
        ///
        /// - SeeAlso: Image.imageScale(_:)
        case medium

        /// The large image scale size.
        ///
        /// - SeeAlso: Image.imageSclae(_:)
        case large

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Image.Scale, b: Image.Scale) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

	/// The different amounts of interpolation that can be applied to an image.
	///
	/// Image interpolation is a digital process that occurs when an image is
	/// either scaled up or scaled down, or when rotating an image.
	///
	/// Interpolation uses what is known in the image to estimate unknown
	/// values.
	///
	/// Interpolation can make scaled up images retain some of their clarity,
	/// and can make scaled down images look better.
    public enum Interpolation {

    	/// Apply no interpolation to the image when remapping.
        case none

        /// Apply a low amount of interpolation to the image when remapping.
        case low

        /// Apply a medium amount of interpolation to the image when remapping.
        case medium

        /// Apply a high amount of interpolation to the image when remapping.
        case high

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Image.Interpolation, b: Image.Interpolation) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

	/// Adjusts the interpolation property of an image.
	///
	/// - Parameter interpolation: The image's interpolation property.
	///
	/// - SeeAlso: Image.Interpolation
    public func interpolation(_ interpolation: Image.Interpolation) -> Image { }

    /// Adjusts the antialiasing properties of an image.
    ///
    /// If an image is antialiased, then it resists being distorted when it is
    /// shrunk to a lower resolution.
    ///
    /// - Paramter isAntialiased: Whether the image is antialiased.
    public func antialiased(_ isAntialiased: Bool) -> Image { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

    /// Creates a labeled image based on a `CGImage`, usable as content for
    /// controls.
    ///
    /// - Parameters:
    ///   - cgImage: the base graphical image
    ///   - scale: the scale factor the image is intended for
    ///     (e.g. 1.0, 2.0, 3.0)
    ///   - orientation: the orientation of the image
    ///   - label: The label associated with the image. The label is used for
    ///     things like accessibility.
    public init(_ cgImage: CGImage, scale: CGFloat, orientation: Image.Orientation = .up, label: Text) { }

    /// Creates an unlabeled, decorative image based on a `CGImage`.
    ///
    /// This image is ignored for accessibility purposes.
    ///
    /// - Parameters:
    ///   - cgImage: the base graphical image
    ///   - scale: the scale factor the image is intended for
    ///     (e.g. 1.0, 2.0, 3.0)
    ///   - orientation: the orientation of the image
    public init(decorative cgImage: CGImage, scale: CGFloat, orientation: Image.Orientation = .up) { }
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension Image {

	/// Creates a new `Image` from a specified `UIImage`.
    public init(uiImage: UIImage) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image {

	/// The different ways of resizing an image to fill a view.
    public enum ResizingMode {

    	/// The resizing method of maintaining image properties, positioning
    	/// several in a grid to fill the space if necessary.
        case tile

        /// The resizing method of stretching the image, distorting the properties
        /// if necessary.
        case stretch

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Image.ResizingMode, b: Image.ResizingMode) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }

    /// Modifies an image to make it resizable.
    ///
    /// Applying this modifier before reframing an image or in other ways
    /// distorting it is necessary otherwise the images view will change, but
    /// the image itself will not be resized.
    ///
    /// - Parameters:
    ///   - capInsets: The values to use for the cap insets.
    ///   - resizingMode: The mode of resizing to use.
    public func resizable(capInsets: EdgeInsets = EdgeInsets(), resizingMode: Image.ResizingMode = .stretch) -> Image { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image.Orientation : RawRepresentable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image.TemplateRenderingMode : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image.TemplateRenderingMode : Hashable {
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 11.0, *)
extension Image.Scale : Equatable {
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 11.0, *)
extension Image.Scale : Hashable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image.Interpolation : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image.Interpolation : Hashable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image.ResizingMode : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Image.ResizingMode : Hashable {
}

/// A shape style that fills a shape by repeating a region of an image.
///
/// Use this shape style to tile images as strokes or fills.
///
/// See ``ShapeStyle`` for more info on how and where to use shape styles.
///
/// ```
/// struct DogsEverywhereView: View {
///     var body: some View {
///         Rectangle()
///             .fill(ImagePaint(image: Image("dog")))
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ImagePaint : ShapeStyle {

    /// The image to be drawn.
    ///
    /// This image property must be declared when the ``ImagePaint`` structure
    /// is initialized, but it can be read or written to later.
    ///
    /// ```
    /// struct DogsEverywhereView: View {
    ///     var body: some View {
    ///         var imagePaint = ImagePaint(image: Image("placeholder"))
    ///         imagePaint.image = Image("dog")
    ///
    ///         return Rectangle()
    ///             .fill(imagePaint)
    ///     }
    /// }
    /// ```
    public var image: Image

    /// A unit-space rectangle defining how much of the source image to draw.
    ///
    /// This of this as the 1-by-1 rectangle from the original image that you
    /// want to be tiled over the entirety of the space.
    ///
    /// The results are undefined if this rectangle selects areas outside the
    /// `[0, 1]` range in either axis.
    ///
    /// This image property can be declared when the ``ImagePaint`` structure
    /// is initialized, or written to or read later.
    ///
    /// ```
    /// struct TrippyDogsEverywhereView: View {
    ///     var body: some View {
    ///         var imagePaint = ImagePaint(image: Image("dog"))
    ///         imagePaint.sourceRect = CGRect(x: 0.0, y: 0.0, width: 0.34, height: 1.0)
    ///
    ///         return Rectangle()
    ///             .fill(imagePaint)
    ///     }
    /// }
    /// ```
    public var sourceRect: CGRect

    /// A scale factor applied to the image while being drawn.
    ///
    /// This image property can be declared when the ``ImagePaint`` structure
    /// is initialized, or written to or read later.
    ///
    /// ```
    /// struct BigDogsEverywhereView: View {
    ///     var body: some View {
    ///         var imagePaint = ImagePaint(image: Image("dog"))
    ///         imagePaint.scale = 3
    ///
    ///         return Rectangle()
    ///             .fill(imagePaint)
    ///     }
    /// }
    /// ```
    public var scale: CGFloat

    /// Creates a shape-filling shape style from a source image.
    ///
    /// ```
    /// struct DogsEverywhereView: View {
    ///     let imagePaint = ImagePaint(image: Image("dog"),
    ///                                 sourceRect: CGRect(x: 0.0, y: 0.0, width: 0.34, height: 1.0),
    ///                                 scale: 4)
    ///     var body: some View {
    ///         Rectangle()
    ///             .fill(imagePaint)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - image: The image to be drawn.
    ///   - sourceRect: A unit-space rectangle defining how much of the source
    ///     image to draw. The results are undefined if `sourceRect` selects
    ///     areas outside the `[0, 1]` range in either axis.
    ///   - scale: A scale factor applied to the image during rendering.
    public init(image: Image, sourceRect: CGRect = CGRect(x: 0, y: 0, width: 1, height: 1), scale: CGFloat = 1) { }
}

/// Types conforming to this protocol are used to style page index ``TabView``'s.
///
/// Currently the IndexViewStyle protocol is not public, so it cannot be implemented for
/// a custom view. The only type conforming to this protocol is ``PageIndexViewStyle``.
/// To configure the current `IndexViewStyle` for a view hierarchy, use the
/// `.indexViewStyle()` modifier.
///
/// For example:
///
/// ![Index view style protocol example 1](indexviewstyle-protocol-example-1.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        TabView {
///            Text("Tab 1")
///            Text("Tab 2")
///            Text("Tab 3")
///        }
///        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
///        .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .always))
///    }
/// }
/// ```
@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public protocol IndexViewStyle{ }
extension IndexViewStyle {
}

/// A `PickerStyle` where each option is displayed inline with
/// other views in the current container.
///
/// [pickerstyle-inline ->]
/// Your app can use explicit tags to identify picker content.
///
/// ![Inline Example](/picker-style-2.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var favoriteFruit: MyFruit = MyFruit.banana
///
///     var fruitName: String {
///         switch favoriteFruit{
///         case .apple:
///             return "Apple 🍎🍎"
///         case .banana:
///             return "Banana 🍌🍌"
///         case .peach:
///             return "Peach 🍑🍑"
///         }
///     }
///
///     var body: some View {
///         Text("My Favorite Fruit: \(fruitName)")
///
///         Picker("My Picker", selection: $favoriteFruit) {
///             Text("Banana 🍌🍌")
///                 .tag(MyFruit.banana)
///             Text("Apple 🍎🍎")
///                 .tag(MyFruit.apple)
///             Text("Peach 🍑🍑")
///                 .tag(MyFruit.peach)
///         }.pickerStyle(InlinePickerStyle())
///     }
/// }
/// ```
///
/// [<-]
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct InlinePickerStyle : PickerStyle {

    /// Creates an inline picker style.
    ///
    /// ![Inline Example](/picker-style-2.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var favoriteFruit: MyFruit = MyFruit.banana
    ///
    ///     var fruitName: String {
    ///         switch favoriteFruit{
    ///         case .apple:
    ///             return "Apple 🍎🍎"
    ///         case .banana:
    ///             return "Banana 🍌🍌"
    ///         case .peach:
    ///             return "Peach 🍑🍑"
    ///         }
    ///     }
    ///
    ///     var body: some View {
    ///         Text("My Favorite Fruit: \(fruitName)")
    ///
    ///         Picker("My Picker", selection: $favoriteFruit) {
    ///             Text("Banana 🍌🍌")
    ///                 .tag(MyFruit.banana)
    ///             Text("Apple 🍎🍎")
    ///                 .tag(MyFruit.apple)
    ///             Text("Peach 🍑🍑")
    ///                 .tag(MyFruit.peach)
    ///         }.pickerStyle(InlinePickerStyle())
    ///     }
    /// }
    /// ```
    ///
    public init() { }
}

/// The instance that describes the behavior and appearance of an inset grouped list.
///
/// ![InsetGroupedListStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/liststyle-inset-grouped-example-1.png)
///
///
///      struct ExampleView: View {
///          var body: some View {
///             List {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍎🍎")
///                 Text("Peaches 🍑🍑")
///             }
///             .listStyle(InsetGroupedListStyle())
///          }
///      }
///
///
@available(iOS 14.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct InsetGroupedListStyle : ListStyle {

    /// Creates an inset grouped list style.
    public init() { }
}

/// The behavior and appearance of an inset list.
///
/// ![InsetListStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/liststyle-inset-example-1.png)
///
///
///      struct ExampleView: View {
///          var body: some View {
///             List {
///                Text("Bananas 🍌🍌")
///                Text("Apples 🍎🍎")
///                Text("Peaches 🍑🍑")
///             }
///             .listStyle(InsetListStyle())
///          }
///      }
///
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct InsetListStyle : ListStyle {

    /// Creates an inset list style.
    public init() { }
}

/// A shape type that is able to inset itself to produce another shape.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol InsettableShape : Shape{ }
extension InsettableShape : Shape {

    /// The type of the inset shape.
    associatedtype InsetShape : InsettableShape

    /// Returns `self` inset by `amount`.
    func inset(by amount: CGFloat) -> Self.InsetShape { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension InsettableShape {

    /// Returns a view that is the result of insetting `self` by
    /// `style.lineWidth / 2`, stroking the resulting shape with
    /// `style`, and then filling with `content`.
    @inlinable public func strokeBorder<S>(_ content: S, style: StrokeStyle, antialiased: Bool = true) -> some View where S : ShapeStyle { }


    /// Returns a view that is the result of insetting `self` by
    /// `style.lineWidth / 2`, stroking the resulting shape with
    /// `style`, and then filling with the foreground color.
    @inlinable public func strokeBorder(style: StrokeStyle, antialiased: Bool = true) -> some View { }


    /// Returns a view that is the result of filling the `width`-sized
    /// border (aka inner stroke) of `self` with `content`. This is
    /// equivalent to insetting `self` by `width / 2` and stroking the
    /// resulting shape with `width` as the line-width.
    @inlinable public func strokeBorder<S>(_ content: S, lineWidth: CGFloat = 1, antialiased: Bool = true) -> some View where S : ShapeStyle { }


    /// Returns a view that is the result of filling the `width`-sized
    /// border (aka inner stroke) of `self` with the foreground color.
    /// This is equivalent to insetting `self` by `width / 2` and
    /// stroking the resulting shape with `width` as the line-width.
    @inlinable public func strokeBorder(lineWidth: CGFloat = 1, antialiased: Bool = true) -> some View { }

}

/// Key equivalents consist of a letter, punctuation, or function key that can
/// be combined with an optional set of modifier keys to specify a keyboard
/// shortcut.
///
/// Key equivalents are used to establish keyboard shortcuts to app
/// functionality. Any key can be used as a key equivalent as long as pressing
/// it produces a single character value. Key equivalents are typically
/// initialized using a single-character string literal, with constants for
/// unprintable or hard-to-type values.
///
/// The modifier keys necessary to type a key equivalent are factored in to the
/// resulting keyboard shortcut. That is, a key equivalent whose raw value is
/// the capitalized string "A" corresponds with the keyboard shortcut
/// Command-Shift-A. The exact mapping may depend on the keyboard layout—for
/// example, a key equivalent whith the character value "}" produces a shortcut
/// equivalent to Command-Shift-] on ANSI keyboards, but would produce a
/// different shortcut for keyboard layouts where punctuation characters are in
/// different locations.
///
/// Use this structure with the ``View/keyboardShortcut(_:modifiers:)``
/// view modifier to add keyboard shortcuts to a view.
///
/// Key equivalents are also used in constructing ``KeyboardShortcut``
/// objects, which are used extensively in ``Commands``.
///
/// ```
/// struct ShortcutEnabledView: View {
///     var body: some View {
///         Button("Press command-P to print the 🍌") {
///             print("🍌")
///         }
///         .keyboaredShortcut(KeyEquivalent("p"), modifiers: [.command])
///     }
/// }
/// ```
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct KeyEquivalent {

    /// Up Arrow (U+F700) key equivalent.
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-up to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.upArrow, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let upArrow: KeyEquivalent

    /// Down Arrow (U+F701) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-down to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.downArrow, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let downArrow: KeyEquivalent

    /// Left Arrow (U+F702) key equivalent.
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-left to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.leftArrow, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let leftArrow: KeyEquivalent

    /// Right Arrow (U+F703) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-right to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.rightArrow, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let rightArrow: KeyEquivalent

    /// Escape (U+001B) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-ctrl-esacpe to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.escape, modifiers: [.command, .control])
    ///     }
    /// }
    /// ```
    public static let escape: KeyEquivalent

    /// Delete (U+0008) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-delete to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.delete, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let delete: KeyEquivalent

    /// Delete Forward (U+F728) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// - Note: Many keyboards don't have this key.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-delete forward to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.deleteForward, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let deleteForward: KeyEquivalent

    /// Home (U+F729) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// - Note: Many keyboards don't have this key. If yours doesn't, press
    /// fn+left arrow instead.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-home to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.home, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let home: KeyEquivalent

    /// End (U+F72B)
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// - Note: Many keyboards don't have this key. If yours doesn't, press
    /// fn+right arrow instead.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-end to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.end, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let end: KeyEquivalent

    /// Page Up (U+F72C) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-page up to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.pageUp, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let pageUp: KeyEquivalent

    /// Page Down (U+F72D) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-page down to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.pageDown, modifiers: [.command])
    ///     }
    /// }
    /// ```
    public static let pageDown: KeyEquivalent

    /// Clear (U+F739) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-control-clear to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.clear, modifiers: [.command, .control])
    ///     }
    /// }
    /// ```
    public static let clear: KeyEquivalent

    /// Tab (U+0009) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-control-tab to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.tab, modifiers: [.command, .control])
    ///     }
    /// }
    /// ```
    public static let tab: KeyEquivalent

    /// Space (U+0020) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-control-option-sace to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.space, modifiers: [.command, .control, .option])
    ///     }
    /// }
    /// ```
    public static let space: KeyEquivalent

    /// Return (U+000D) key equivalent
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ``KeyEquivalent``s are also used in constructing ``KeyboardShortcut``
    /// objects, which are used extensively in ``Commands``.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-control-return to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboaredShortcut(.return, modifiers: [.command, .control])
    ///     }
    /// }
    /// ```
    public static let `return`: KeyEquivalent

    /// The character value that the key equivalent represents.
    ///
    /// In the following example, command-control-P prints "P", and they are
    /// both constructed from the same ``Character`` object!
    ///
    /// ```
    /// struct PPrinterView: View {
    ///     let p = Character("p")
    ///     var body: some View {
    ///         Button("Print p!") {
    ///             print(p)
    ///         }
    ///         .keyboardShortcut(KeyEquivalent(p), modifiers: [.command, .control])
    ///     }
    /// }
    /// ```
    public var character: Character

    /// Creates a new key equivalent from the given character value.
    ///
    /// A character is just like a string, but it's only 1 letter long.
    /// See [Character](https://developer.apple.com/documentation/swift/character)
    /// for more on characters and how to create them.
    ///
    /// Note that characters are case sensitive, and passing a capital key
    /// equivalent to ``View/keyboardShortcut(_:modifiers)``
    /// means [modifiers]+SHIFT+letter.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         Button("Press command-p to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboardShortcut(KeyEquivalent(Character("p")), modifiers: [.command, .control])
    ///     }
    /// }
    /// ```
    public init(_ character: Character) { }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension KeyEquivalent : ExpressibleByExtendedGraphemeClusterLiteral {

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(extendedGraphemeClusterLiteral: Character) { }

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    public typealias ExtendedGraphemeClusterLiteralType = Character

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = Character
}

/// Keyboard shortcuts describe combinations of keys on a keyboard that the user
/// can press in order to activate a button or toggle.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct KeyboardShortcut {

    /// The standard keyboard shortcut for the default button, consisting of
    /// the Return (↩) key and no modifiers.
    ///
    /// On macOS, the default button is designated with special coloration. If
    /// more than one control is assigned this shortcut, only the first one is
    /// emphasized.
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ```
    /// struct KeyboardShortcutView: View {
    ///     var body: some View {
    ///         Text("Press ENTER to save or ESC to cancel.")
    ///         HStack {
    ///             Button("Cancel") { print("cancel") }
    ///                 .keyboardShortcut(.cancelAction)
    ///             Button("Save") { print("save") }
    ///                 .keyboardShortcut(.defaultAction)
    ///         }
    ///     }
    /// }
    /// ```
    public static let defaultAction: KeyboardShortcut

    /// The standard keyboard shortcut for cancelling the in-progress action
    /// or dismissing a prompt, consisting of the Escape (⎋) key and no
    /// modifiers.
    ///
    /// Use this property with the ``View/keyboardShortcut(_:modifiers:)``
    /// view modifier to add keyboard shortcuts to a view.
    ///
    /// ```
    /// struct KeyboardShortcutView: View {
    ///     var body: some View {
    ///         Text("Press ENTER to save or ESC to cancel.")
    ///         HStack {
    ///             Button("Cancel") { print("cancel") }
    ///                 .keyboardShortcut(.cancelAction)
    ///             Button("Save") { print("save") }
    ///                 .keyboardShortcut(.defaultAction)
    ///         }
    ///     }
    /// }
    /// ```
    public static let cancelAction: KeyboardShortcut

    /// The key equivalent that the user presses in conjunction with any
    /// specified modifier keys to activate the shortcut.
    ///
    /// This property is usually specified from the
    /// ``KeyboardShortcut``'s initializer, but can also be written to
    /// or read directly.
    ///
    /// See ``KeyEquivalent`` for more on key equivalents.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         var shortcut = KeyboardShortcut(.esc, modifiers: [.command, .control])
    ///         shortcut.key = .return
    ///
    ///         return Button("Press command-control-return to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboardShortcut(shortcut)
    ///     }
    /// }
    /// ```
    public var key: KeyEquivalent

    /// The modifier keys that the user presses in conjunction with a key
    /// equivalent to activate the shortcut.
    ///
    /// This property is usually specified from the
    /// ``KeyboardShortcut``'s initializer, but can also be written to
    /// or read directly.
    ///
    /// See ``EventModifiers`` for more on event modifiers.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         var shortcut = KeyboardShortcut(.return)
    ///         shortcut.modifiers = [.command, .control]
    ///
    ///         return Button("Press command-control-return to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboardShortcut(shortcut)
    ///     }
    /// }
    /// ```
    public var modifiers: EventModifiers

    /// Creates a new keyboard shortcut with the given key equivalent and set of
    /// modifier keys.
    ///
    /// ```
    /// struct ShortcutEnabledView: View {
    ///     var body: some View {
    ///         var shortcut = KeyboardShortcut(.return, modifiers = [.command, .control])
    ///
    ///         return Button("Press command-control-return to print the 🍌") {
    ///             print("🍌")
    ///         }
    ///         .keyboardShortcut(shortcut)
    ///     }
    /// }
    /// ```
    public init(_ key: KeyEquivalent, modifiers: EventModifiers = .command) { }
}

/// A standard label, consisting of an icon with a title.
///
/// One of the most common and recognizable user interface components is the
/// combination of an icon and a label. This idiom appears across many kinds of
/// apps and shows up in collections, lists, menus of action items, and
/// disclosable lists, just to name a few.
///
/// You create a label, in its simplest form, by providing a title and the name
/// of an image, such as an icon from the
/// [SF Symbols](https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/)
/// collection:
///
/// ```
/// struct BoltView: View {
///     var body: some View {
///         Label("Lightning", systemImage: "bolt.fill")
///     }
/// }
/// ```
///
/// You can also apply styles to labels in several ways. In the case of dynamic
/// changes to the view after device rotation or change to a window size you
/// might want to show only the text portion of the label using the title-only
/// label style:
///
/// ```
/// struct TitleOnlyBoltView: View {
///     var body: some View {
///         Label("Lightning", systemImage: "bolt.fill")
///             .labelStyle(TitleOnlyLabelStyle())
///     }
/// }
/// ```
///
/// Conversely, there's also an icon-only label style:
///
/// ```
/// struct IconOnlyBoltView: View {
///     var body: some View {
///     Label("Lightning", systemImage: "bolt.fill")
///         .labelStyle(IconOnlyLabelStyle())
///     }
/// }
/// ```
///
/// You can also create a customized label style by modifying an existing
/// style; this example adds a red border to the default label style:
///
/// ```
/// struct RedBorderedLabelStyle: LabelStyle {
///     func makeBody(configuration: Configuration) -> some View {
///         Label(configuration)
///             .padding()
///             .border(Color.red)
///     }
/// }
///
/// struct RedBorderedBoltView: View {
///     var body: some View {
///         Label("Lightning", systemImage: "bolt.fill")
///             .labelStyle(RedBorderedLabelStyle())
///     }
/// }
/// ```
///
/// For more extensive customization or to create a completely new label style,
/// you'll need to adopt the `LabelStyle` protocol and implement a
/// `LabelStyleConfiguration` for the new style.
///
/// To apply a common label style to a group of labels, apply the style
/// to the view hierarchy that contains the labels:
///
/// ```
/// struct WeatherView: View {
///     var body: some View {
///         VStack {
///             Label("Rain", systemImage: "cloud.rain")
///             Label("Snow", systemImage: "snow")
///             Label("Sun", systemImage: "sun.max")
///         }
///         .labelStyle(IconOnlyLabelStyle())
///     }
/// }
/// ```
///
/// It's also possible to make labels using views to compose the label's icon
/// programmatically, rather than using a pre-made image. In this example, the
/// icon portion of the label uses a filled `Circle` overlaid
/// with the user's initials:
///
/// ```
/// struct CustomPersonView: View {
///     var body: some View {
///         Label {
///             Text("Aaron")
///                 .font(.body)
///                 .foregroundColor(.primary)
///             Text("GOAT")
///                 .font(.subheadline)
///                 .foregroundColor(.secondary)
///         } icon: {
///             Circle()
///                 .fill(Color.purple)
///                 .frame(width: 44, height: 44, alignment: .center)
///                 .overlay(Text("AG"))
///         }
///     }
/// }
/// ```
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct Label<Title, Icon> : View where Title : View, Icon : View {

    /// Creates a label with a with a view title and a view icon.
    ///
    /// ```
    /// struct EverythingView: View {
    ///     var body: some View {
    ///         Label {
    ///             Text("Meaning of life")
    ///                 .border(Color.green)
    ///         } icon: {
    ///             Image(systemName: "42.circle")
    ///                 .foregroundColor(.green)
    ///         }
    ///
    /// - Parameters:
    ///   - title: A view builder for the label's title view.
    ///   - icon: A view builder for the label's icon view.
    public init(@ViewBuilder title: () -> Title, @ViewBuilder icon: () -> Icon) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Label where Title == Text, Icon == Image {

    /// Creates a label with a localized string title and image name icon.
    ///
    /// ```
    /// struct EverythingView: View {
    ///     var body: some View {
    ///         Label(LocalizedStringKey("Meaning of life"),
    ///               image: "earth")
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///    - titleKey: A title generated from a localized string.
    ///    - image: The name of the image resource to lookup.
    public init(_ titleKey: LocalizedStringKey, image name: String) { }

    /// Creates a label with a localized string title and system image name icon.
    ///
    /// ```
    /// struct EverythingView: View {
    ///     var body: some View {
    ///         Label(LocalizedStringKey("Meaning of life"),
    ///               systemImage: "42.circle")
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///    - titleKey: A title generated from a localized string.
    ///    - systemImage: The name of the image resource to lookup.
    public init(_ titleKey: LocalizedStringKey, systemImage name: String) { }

    /// Creates a label with a string title and image name icon.
    ///
    /// ```
    /// struct EverythingView: View {
    ///     var body: some View {
    ///         Label("Meaning of life", image: "earth")
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///    - title: A string to used as the label's title.
    ///    - image: The name of the image resource to lookup.
    public init<S>(_ title: S, image name: String) where S : StringProtocol { }

    /// Creates a label with a string title and system image name icon.
    ///
    /// ```
    /// struct EverythingView: View {
    ///     var body: some View {
    ///         Label("Meaning of life", systemImage: "42.circle")
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///    - title: A string to used as the label's title.
    ///    - systemImage: The name of the image resource to lookup.
    public init<S>(_ title: S, systemImage name: String) where S : StringProtocol { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Label where Title == LabelStyleConfiguration.Title, Icon == LabelStyleConfiguration.Icon {

    /// Creates a label representing the configuration of a style.
    ///
    /// You can use this initializer within the `LabelStyle/makeBody(configuration:)`
    /// method of a `LabelStyle` instance to create an instance of the label
    /// that's being styled. This is useful for custom label styles that only
    /// wish to modify the current style, as opposed to implementing a brand new
    /// style.
    ///
    /// For example, the following style adds a red border around the label,
    /// but otherwise preserves the current style:
    ///
    /// ```
    /// struct RedBorderedLabelStyle: LabelStyle {
    ///     func makeBody(configuration: Configuration) -> some View {
    ///         Label(configuration)
    ///             .border(Color.red)
    ///     }
    /// }
    ///
    /// struct RedBorderedBoltView: View {
    ///     var body: some View {
    ///         Label("Lightning", systemImage: "bolt.fill")
    ///             .labelStyle(RedBorderedLabelStyle())
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter configuration: The label style to use.
    public init(_ configuration: LabelStyleConfiguration) { }
}

/// This protocol is used to create styles for Label views
///
///
/// Implement this protocol to create a labelstyle that can easily be reused.
///
/// To configure the current label style for a view hierarchy, you only need to use the
/// `View/labelStyle(_:)` modifier.
///
/// ![LabelStyle Example 1](label-style-example.png)
///
///```
/// struct ExampleView: View {
///     var body: some View {
///         VStack{
///             Label("Banana", systemImage: "suit.heart.fill")
///                 .labelStyle(MyLabelStyle(color:.yellow))
///             Label("Apple", systemImage: "suit.heart.fill")
///                 .labelStyle(MyLabelStyle(color:.red))
///         }
///  }
///     struct MyLabelStyle:LabelStyle{
///         let color:Color
///         func makeBody(configuration: Configuration) -> some View {
///             VStack{
///                 configuration.title
///
///                 configuration.icon.foregroundColor(color)
///             }
///         }
///     }
/// }
/// ```
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol LabelStyle { }
extension LabelStyle {

    /// A view that represents the body of a label.
    associatedtype Body : View

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each `Label` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// ![LabelStyle Example 1](label-style-example.png)
    ///
    ///```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack{
    ///             Label("Banana", systemImage: "suit.heart.fill")
    ///                 .labelStyle(MyLabelStyle(color:.yellow))
    ///             Label("Apple", systemImage: "suit.heart.fill")
    ///                 .labelStyle(MyLabelStyle(color:.red))
    ///         }
    ///  }
    ///     struct MyLabelStyle:LabelStyle{
    ///         let color:Color
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             VStack{
    ///                 configuration.title
    ///
    ///                 configuration.icon.foregroundColor(color)
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    /// - Parameter configuration: The properties of the label.
    func makeBody(configuration: Self.Configuration) -> Self.Body { }

    /// The properties of a label.
    typealias Configuration = LabelStyleConfiguration
}

/// The properties of a label.
///
/// There are 2 properties of a label:
/// 1. Title
/// 2. Icon
///
/// ![DefaultLabelStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/labelstyle-default-example-1.png)
///
///
///    struct ExampleView: View {
///        var body: some View {
///             Label("Banana🍌", systemImage: "heart.fill")
///                 .labelStyle(DefaultLabelStyle())
///        }
///    }
///
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LabelStyleConfiguration {

    /// A type-erased title view of a label.
    public struct Title {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A type-erased icon view of a label.
    public struct Icon {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A description of the labeled item.
    public var title: LabelStyleConfiguration.Title { get }

    /// A symbolic representation of the labeled item.
    public var icon: LabelStyleConfiguration.Icon { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LabelStyleConfiguration.Title : View {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LabelStyleConfiguration.Icon : View {
}

/// The different text directions used in different languages.
///
/// Examples of left-to-right layout directions are English and Russian.
/// Examples of right-to-left layout directions are Arabic and Hebrew.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum LayoutDirection : Hashable, CaseIterable {

	/// The text is read and written from left to right.
	///
	/// In this layout direction, the leading edge would be on the left side,
	/// and the trailing edge would be on the right side.
    case leftToRight

    /// The text is read and written from left to right.
    ///
    /// In this layout direction, the leading edge would be on the right side,
    /// and the trailing edge would be on the left side.
    case rightToLeft

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: LayoutDirection, b: LayoutDirection) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [LayoutDirection]

    /// A collection of all values of this type.
    public static var allCases: [LayoutDirection] { get }
}

extension LayoutDirection {

    /// Create a direction from its UITraitEnvironmentLayoutDirection equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiLayoutDirection: UITraitEnvironmentLayoutDirection) { }
}

/// A container view that arranges its child views in a grid that
/// grows horizontally, creating items only as needed.
///
/// The grid is "lazy," in that the grid view does not create items until
/// they are needed.
///
/// In the following example, a `ScrollView` contains a `LazyHGrid` that
/// consists of a horizontally-arranged grid of `Text` views, aligned to
/// the top of the scroll view. For each column in the grid, the top row shows
/// a Unicode code point from the "Smileys" group, and the bottom shows its
/// corresponding emoji.
///
/// ```
/// struct HorizontalEmojiView: View {
///     var rows: [GridItem] =
///             Array(repeating: .init(.fixed(20)), count: 2)
///
///     var body: some View {
///         ScrollView(.horizontal) {
///             LazyHGrid(rows: rows, alignment: .top) {
///                 ForEach((0...79), id: \.self) {
///                     let codepoint = $0 + 0x1f600
///                     let codepointString = String(format: "%02X", codepoint)
///                     Text("\(codepointString)")
///                         .font(.footnote)
///                     let emoji = String(Character(UnicodeScalar(codepoint)!))
///                     Text("\(emoji)")
///                      .font(.largeTitle)
///                 }
///             }
///         }
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyHGrid<Content> : View where Content : View {

    /// Creates a grid that grows horizontally, given the provided properties.
    ///
    /// The first parameter, rows, takes an array of ``GridItem``s.
    /// For more info on the types of grid items, check out that page.
    ///
    /// ```
    /// struct HorizontalEmojiView: View {
    ///     var rows: [GridItem] =
    ///             Array(repeating: .init(.fixed(20)), count: 2)
    ///
    ///     var body: some View {
    ///         ScrollView(.horizontal) {
    ///             LazyHGrid(rows: rows, alignment: .top) {
    ///                 ForEach((0...79), id: \.self) {
    ///                     let codepoint = $0 + 0x1f600
    ///                     let codepointString = String(format: "%02X", codepoint)
    ///                     Text("\(codepointString)")
    ///                         .font(.footnote)
    ///                     let emoji = String(Character(UnicodeScalar(codepoint)!))
    ///                     Text("\(emoji)")
    ///                      .font(.largeTitle)
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - rows: An array of grid items to size and position each column of
    ///    the grid.
    ///   - alignment: The alignment of the grid within its parent view.
    ///   - spacing: The spacing beween the grid and the next item in its
    ///   parent view.
    ///   - pinnedViews: Views to pin to the bounds of a parent scroll view.
    ///   - content: The content of the grid.
    public init(rows: [GridItem], alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A view that arranges its children in a line that grows horizontally,
/// creating items only as needed.
///
/// The stack is "lazy," in that the stack view doesn't create items until
/// it needs to render them onscreen.
///
/// In the following example, a `ScrollView` contains a `LazyHStack` that
/// consists of a horizontal row of text views. The stack aligns to the top
/// of the scroll view and uses 10-point spacing between each text view.
///
/// ```
/// struct ColumnNumberView: View {
///     var body: some View {
///         ScrollView(.horizontal) {
///             LazyHStack(alignment: .top, spacing: 10) {
///                 ForEach(1...100, id: \.self) {
///                     Text("Column \($0)")
///                 }
///             }
///         }
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyHStack<Content> : View where Content : View {

    /// Creates a lazy horizontal stack view with the given spacing,
    /// vertical alignment, pinning behavior, and content.
    ///
    /// ```
    /// struct ColumnNumberView: View {
    ///     var body: some View {
    ///         ScrollView(.horizontal) {
    ///             LazyHStack(alignment: .top, spacing: 10) {
    ///                 ForEach(1...100, id: \.self) {
    ///                     Text("Column \($0)")
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - alignment: The guide for aligning the subviews in this stack. All
    ///       child views have the same vertical screen coordinate.
    ///     - spacing: The distance between adjacent subviews, or `nil` if you
    ///       want the stack to choose a default distance for each pair of
    ///       subviews.
    ///     - pinnedViews: The kinds of child views that will be pinned.
    ///     - content: A view builder that creates the content of this stack.
    public init(alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A container view that arranges its child views in a grid that
/// grows vertically, creating items only as needed.
///
/// The grid is "lazy," in that the grid view does not create items until
/// they are needed.
///
/// In the following example, a `ScrollView` contains a
/// `LazyVGrid` consisting of a two-column grid of `Text` views, showing
/// Unicode code points from the "Smileys" group and their corresponding emoji:
///
///      var columns: [GridItem] =
///              Array(repeating: .init(.flexible()), count: 2)
///      ScrollView {
///          LazyVGrid(columns: columns) {
///              ForEach((0...79), id: \.self) {
///                  let codepoint = $0 + 0x1f600
///                  let codepointString = String(format: "%02X", codepoint)
///                  Text("\(codepointString)")
///                  let emoji = String(Character(UnicodeScalar(codepoint)!))
///                  Text("\(emoji)")
///              }
///          }.font(.largeTitle)
///      }
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyVGrid<Content> : View where Content : View {

    /// Creates a grid that grows vertically, given the provided properties.
    ///
    /// - Parameters:
    ///   - columns: An array of grid items to size and position each row of
    ///    the grid.
    ///   - alignment: The alignment of the grid within its parent view.
    ///   - spacing: The spacing beween the grid and the next item in its
    ///   parent view.
    ///   - pinnedViews: Views to pin to the bounds of a parent scroll view.
    ///   - content: The content of the grid.
    public init(columns: [GridItem], alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A view that arranges its children in a line that grows vertically,
/// creating items only as needed.
///
/// The stack is "lazy," in that the stack view doesn't create items until
/// it needs to render them onscreen.
///
/// In the following example, a `ScrollView` contains a `LazyVStack` that
/// consists of a vertical row of text views. The stack aligns to the
/// leading edge of the scroll view, and uses default spacing between the
/// text views.
///
/// ```
/// struct RowNumbersView: View {
///     var body: some View {
///         ScrollView {
///             LazyVStack(alignment: .leading) {
///                 ForEach(1...100, id: \.self) { number in
///                     Text("Row \(number)")
///                 }
///             }
///         }
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LazyVStack<Content> : View where Content : View {

    /// Creates a lazy vertical stack view with the given spacing,
    /// vertical alignment, pinning behavior, and content.
    ///
    /// ```
    /// struct RowNumbersView: View {
    ///     var body: some View {
    ///         ScrollView {
    ///             LazyVStack(alignment: .leading) {
    ///                 ForEach(1...100, id: \.self) { number in
    ///                     Text("Row \(number)")
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - alignment: The guide for aligning the subviews in this stack. All
    ///     child views have the same horizontal screen coordinate.
    ///     - spacing: The distance between adjacent subviews, or `nil` if you
    ///       want the stack to choose a default distance for each pair of
    ///       subviews.
    ///     - pinnedViews: The kinds of child views that will be pinned.
    ///     - content: A view builder that creates the content of this stack.
    public init(alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), @ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// The Accessibility Bold Text user setting options.
///
/// The app can't override the user's choice.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum LegibilityWeight : Hashable {

    /// Use regular font weight (no Accessibility Bold).
    case regular

    /// Use heavier font weight (force Accessibility Bold).
    case bold

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: LegibilityWeight, b: LegibilityWeight) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

extension LegibilityWeight {

    /// Creates a legibility weight from its UILegibilityWeight equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiLegibilityWeight: UILegibilityWeight) { }
}

/// A linear gradient.
///
/// ![Rectangle Example](rounded-rectangle.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         RoundedRectangle(cornerRadius: 10)
///             .fill(LinearGradient(
///                     gradient: Gradient(colors: [.green, .blue, .purple]),
///                     startPoint: .leading,
///                     endPoint: .trailing))
///             .padding()
///     }
/// }
/// ```
///
/// The gradient applies the color function along an axis, as defined by its
/// start and end points. The gradient maps the unit-space points into the
/// bounding rectangle of each shape filled with the gradient.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct LinearGradient : ShapeStyle, View {

	/// Creates a new linear gradient from the Gradient colors, the start, and the end.
	///
	/// - Parameters:
	///   - gradient: The gradient containing the ordered colors to be used.
	///   - startPoint: The unit point where the gradient starts.
	///   - endPoint: The unit point where the gradient ends.
    public init(gradient: Gradient, startPoint: UnitPoint, endPoint: UnitPoint) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

/// A progress view that visually indicates its progress using a horizontal bar.
///
/// When initializing a ProgressView with ``ProgressView/init(value:,total:)``, the
/// ``DefaultProgressViewStyle`` will typically display a linear progress view style.
///
/// For example, to create a new ``ProgressView`` with this style:
///
/// ![Linear progress view example 1](linearprogressview-example-1.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        ProgressView()
///            .progressViewStyle(LinearProgressViewStyle())
///            .padding(20)
///    }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct LinearProgressViewStyle : ProgressViewStyle {

    /// Creates a linear progress view style.
    ///
    /// For example, to create a new ``ProgressView`` with this style:
    ///
    /// ![Linear progress view example 1](linearprogressview-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///
    ///    var body: some View {
    ///        ProgressView()
    ///            .progressViewStyle(LinearProgressViewStyle())
    ///            .padding(20)
    ///    }
    /// }
    /// ```
    public init() { }

    /// Creates a linear progress view style with a tint color.
    ///
    /// For example, to create a new ``ProgressView`` with this style:
    ///
    /// ![Linear progress view example 2](linearprogressview-example-2.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///
    ///    var body: some View {
    ///        ProgressView(value: 5, total: 10)
    ///            .progressViewStyle(LinearProgressViewStyle(tint: Color.red))
    ///            .padding(20)
    ///    }
    /// }
    /// ```
    public init(tint: Color) { }

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    public func makeBody(configuration: LinearProgressViewStyle.Configuration) -> some View { }


    /// A view representing the body of a progress view.
    public typealias Body = some View
}


///  A button that opens a URL
///
///  Before Link was added to SwiftUI, there was no way equivalent of a hyperlink outside of a WKWebView. It was possible to create a button with blue text that opens a URL, but this requires the logic to be added manually each time.
///
///  ```
///  if URL(string: urlString) != nil {
///    //The old way to create a Link-style Button
///    Button("Read more") {
///      if let url = URL(string: urlString) {
///        UIApplication.shared.open(url, options: [:], completionHandler: {_ in })
///      }
///    }
///  } else {
///      EmptyView()
///          .onAppear { assertionFailure("URL was nil") }
///      }
///  }
///     ```
///
///  In iOS 14 there is the option of Link, which does the action part of the Button above for us. Apple’s documentation unsafely unwraps a URL using the ‘!’ operator, but this is an extremely bad practice. You may know that this particular URL is created successfully because it links to example.com/TOS.html, a site owned by the Internet Assigned Numbers Authority (IANA) that convert URLs to IP addresses. But it's a mistake to assume that a URL string is valid and force unwrap the optional.

///  This example is held back by the lack of optional binding (if let or guard let) in the first version of SwiftUI, as it is instead restricted to comparing the URL to nil to ensure it exists. When this comparison confirms that the URL is not nil, this still doesn’t mean I can use it in the Button without unwrapping it first. This is why there is a slightly confusing additional step in the Button action, which optionally binds the URL to ensure that it is not nil.

///  The assertionFailure could have been in an else statement after the if let in the Button action, but the EmptyView has been added for consistency with the above Link example. An else statement containing EmptyView is not required, as any if statement around the only occupant of a ViewBuilder closure will return EmptyView when the if condition is false. If the URL was nil the user would see nothing, but an assertion would be triggered for the developer in debug mode.

///  This would allow us to be aware that the URL was nil, but without causing a crash for the end-user.
///  ```
///  struct ExampleView: View {
///    let urlString = "bananadocs.org"
///    var body: some View {
///      Group {
///        if let url = URL(string: urlString) {
///          //The new way to create a Link
///          Link("Read more", destination: url)
///         } else {
///           EmptyView()
///             .onAppear { assertionFailure("URL was nil") }
///         }
///      }
///    }
///  }
///  ```
///
///  Now that SwiftUI supports if let, it is possible to directly create properties like the URL and create Views that use that data. Just as before, the link is only shown when the URL can be created, but it is not necessary to do multiple checks just to make sure that this is the case.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct Link<Label> : View where Label : View {

    /// Creates a control, consisting of a URL and a label, used to navigate
    /// to the given URL.
    ///
    /// - Parameters:
    ///     - destination: The URL for the link.
    ///     - label: A view that describes the destination of URL.
    public init(destination: URL, @ViewBuilder label: () -> Label) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Link where Label == Text {

    /// Creates a control, consisting of a URL and a title key, used to
    /// navigate to a URL.
    ///
    /// Use `Link` to create a control that your app uses to navigate to a
    /// URL that you provide. The example below creates a link to
    /// `example.com` and uses `Visit Example Co` as the title key to
    /// generate a link-styled view in your app:
    ///
    ///     Link("Visit Example Co",
    ///           destination: URL(string: "https://www.example.com/")!)
    ///
    /// - Parameters:
    ///     - titleKey: The key for the localized title that describes the
    ///       purpose of this link.
    ///     - destination: The URL for the link.
    public init(_ titleKey: LocalizedStringKey, destination: URL) { }

    /// Creates a control, consisting of a URL and a title string, used to
    /// navigate to a URL.
    ///
    /// Use `Link` to create a control that your app uses to navigate to a
    /// URL that you provide. The example below creates a link to
    /// `example.com` and displays the title string you provide as a
    /// link-styled view in your app:
    ///
    ///     func marketingLink(_ callToAction: String) -> Link {{}
    ///         Link(callToAction,
    ///             destination: URL(string: "https://www.example.com/")!)
    ///     }
    ///
    /// - Parameters:
    ///     - title: A text string used as the title for describing the
    ///       underlying `destination` URL.
    ///     - destination: The URL for the link.
    public init<S>(_ title: S, destination: URL) where S : StringProtocol { }
}

/// A scrollable list of data.
///
/// `List` is a view that represents a scrollable list of data.
///
/// ### Creating a `List` with a fixed number of elements
///
/// The following creates a `List` with three rows of text:
///
/// ![List Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         List {
///             Text("Bananas 🍌🍌")
///             Text("Apples 🍏🍏")
///             Text("Peaches 🍑🍑")
///         }
///     }
/// }
/// ```
///
/// ### Creating a `List` with a variable number of elements
///
/// In the following example, `List/init(_:id:rowContent:)` is used to dynamically create a `List` over an array of strings, `fruits`.
///
/// ![List Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits: [String] = ["Bananas 🍌🍌", "Apples 🍏🍏", "Peaches 🍑🍑"]
///
///     var body: some View {
///         List.init(fruits, id: /\.self) { (fruit: String) in
///             Text(fruit)
///         }
///     }
/// }
/// ```
///
/// This is different from the previous example, because this initializer accepts a `rowContent` parameter that allows the `List` to generate SwiftUI views for the list's rows on-demand.
///
/// The `id` parameter requires a key-path to the *identifier* for each row of the `List`. This is required so that `List` can efficiently process changes in the data source (in this example, the array `fruits`). These changes to the data source are animated as insertions, removals and reorders - reflecting the changes in the source.
///
/// It is up to the programmer to decide what property best represents the 'identiifer' of a particular type. In this example, the `String` itself is a valid identifier for the data, therefore `\.self` is passed along to the `id` parameter.
///
/// ### Creating a `List` with both fixed and dynamic elements
///
/// `List` allows you to mix both fixed and dynamic elements using `ForEach`.
///
/// The following example displays a `List` of a fixed element ("Hello, World!") followed by dynamic elements from the previous example (using the `fruits` array):
///
/// ![List Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits: [String] = ["Bananas 🍌🍌", "Apples 🍏🍏", "Peaches 🍑🍑"]
///
///     var body: some View {
///         List {
///             Text("Hello, World!")
///
///             ForEach(fruits, id: /\.self) { (fruit: String) in
///                 Text(fruit)
///             }
///         }
///     }
/// }
/// ```
///
/// As seen in the above example, `ForEach` also accepts an `id` parameter along with a `rowContent`.
/// [list-sections ->]
/// ### Adding sections to a `List`
///
/// The following example demonstrates the usage of `Section`.
///
/// ![List Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-4.png)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits: [String] = ["Bananas 🍌🍌", "Apples 🍏🍏", "Peaches 🍑🍑"]
///
///     var body: some View {
///         List {
///             Section(header: Text("Not a fruit")) {
///                 Text("Hello, World!")
///             }
///
///             Section(header: Text("Fruit")) {
///                 ForEach(fruits, id: /\.self) { (fruit: String) in
///                     Text(fruit)
///                 }
///             }
///         }
///     }
/// }
/// ```
///
/// A `Section` used within a `List` will render as a table-section containing the elements wrapped by that section. Just as for unsectioned elements, sections can hold both fixed and dynamic elements.
/// [<-]
/// [list-style ->]
/// ### Styling a `List`
///
/// A `List` can be styled using the `View/listStyle(_:)` modifier.
///
/// The following example demonstrates how to style a `List` to use a grouped-inset style:
///
/// ![List Example 5](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-5.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         List {
///             Text("Bananas 🍌🍌")
///             Text("Apples 🍏🍏")
///             Text("Peaches 🍑🍑")
///         }
///         .listStyle(InsetGroupedListStyle())
///     }
/// }
/// ```
///
/// SwiftUI offers various list styles:
///
/// - `DefaultListStyle`
/// - `GroupedListStyle`
/// - `InsetGroupedListStyle`
/// - `InsetListStyle`
/// - `PlainListStyle`
/// - `SidebarListStyle`
///
/// Note: List styles only modify the appearance of a `List`. They do not affect the order or positioning of rows within the `List`.
/// [<-]
/// [list-row-background ->]
/// ### Setting the background view for a list row
///
/// Use `View/listRowBackground(_:)` to set the background view for a given row.
///
/// The following example demonstrates how `View/listRowBackground(_:)` can be used to provide specific background colors for a list's rows:
///
/// ![List Example 6](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-6.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         List {
///             Text("Bananas 🍌🍌")
///                 .listRowBackground(Color.yellow)
///             Text("Apples 🍏🍏")
///                 .listRowBackground(Color.red)
///             Text("Peaches 🍑🍑")
///                 .listRowBackground(Color.orange)
///         }
///     }
/// }
/// ```
///
/// A background can be provided for multiple list rows at a time, by applying the `View/listRowBackground(_:)` modifier to `ForEach`.
///
/// In the following example, all the rows of the `List` have the background view `Color.yellow`.
///
/// ![List Example 7](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-7.png)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits: [String] = ["Bananas 🍌🍌", "Apples 🍏🍏", "Peaches 🍑🍑"]
///
///     var body: some View {
///         List {
///             ForEach(fruits, id: /\.self) { (fruit: String) in
///                 Text(fruit)
///             }
///             .listRowBackground(Color.yellow)
///         }
///     }
/// }
/// ```
/// [<-]
///
/// [list-deletable ->]
/// ### Making list rows deletable
///
/// Apply the `DynamicViewContent/onDelete(_:)` modifier on a `ForEach` within a `List` to allow the list rows to become deletable.
///
/// ![List Example 8](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-8.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits = ["🍌", "🍏", "🍑"]
///
///     var body: some View {
///         NavigationView {
///             List {
///                 ForEach(fruits, id: /\.self) { fruit in
///                     Text(fruit)
///                 }
///                 .onDelete { offsets in
///                     fruits.remove(atOffsets: offsets)
///                 }
///             }
///             .toolbar {
///                 EditButton()
///             }
///         }
///     }
/// }
/// ```
/// [<-]
///
/// [list-edit-button ->]
/// ### Editing a `List` using `EditButton`
///
/// An `EditButton` placed in the navigation bar of a `NavigationView` with a `List` in it can be used to provide an edit button for the `List`.
///
/// ![List Example 9](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/List-example-9.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var fruits = ["🍌", "🍏", "🍑"]
///
///     var body: some View {
///         NavigationView {
///             List {
///                 ForEach(fruits, id: /\.self) { fruit in
///                     Text(fruit)
///                 }
///                 .onDelete { offets in
///                     fruits.remove(atOffsets: offets)
///                 }
///             }
///             .toolbar {
///                 EditButton()
///             }
///         }
///     }
/// }
/// ```
/// [<-]
/// ### Further notes
///
/// Although `List` is very powerful, it currently has some limitations:
///
/// - The separator of a `List` cannot be removed.
/// - `SidebarListStyle` is broken on macCatalyst.
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct List<SelectionValue, Content> : View where SelectionValue : Hashable, Content : View {

    /// Creates a list with the given content that supports selecting multiple
    /// rows.
    ///
    /// On iOS and tvOS, you must explicitly put the list into edit mode for
    /// the selection to apply.
    ///
    /// - Parameters:
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - content: The content of the list.
    @available(watchOS, unavailable)
    public init(selection: Binding<Set<SelectionValue>>?, @ViewBuilder content: () -> Content) { }

    /// Creates a list with the given content that supports selecting a single
    /// row.
    ///
    /// On iOS and tvOS, you must explicitly put the list into edit mode for
    /// the selection to apply.
    ///
    /// - Parameters:
    ///   - selection: A binding to a selected row.
    ///   - content: The content of the list.
    @available(watchOS, unavailable)
    public init(selection: Binding<SelectionValue?>?, @ViewBuilder content: () -> Content) { }

    /// The content of the list.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension List {

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, optionally allowing users to select
    /// multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    public init<Data, RowContent>(_ data: Data, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, Data.Element.ID, HStack<RowContent>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable { }

    /// Creates a hierarchical list that computes its rows on demand from an
    /// underlying collection of identifiable data, optionally allowing users to
    /// select multiple rows.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<Data, RowContent>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable { }

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data, optionally allowing users to select
    /// multiple rows.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, ID, HStack<RowContent>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View { }

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data, optionally allowing users to
    /// select multiple rows.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View { }

    /// Creates a list that computes its views on demand over a constant range.
    ///
    /// This instance only reads the initial value of `data` and doesn't need to
    /// identify views across updates. To compute views on demand over a dynamic
    /// range, use `List/init(_:id:selection:rowContent:)-8ef64`.
    ///
    /// - Parameters:
    ///   - data: A *constant* range of data to populate the list.
    ///   - selection: A binding to a set that identifies selected rows.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    public init<RowContent>(_ data: Range<Int>, selection: Binding<Set<SelectionValue>>?, @ViewBuilder rowContent: @escaping (Int) -> RowContent) where Content == ForEach<Range<Int>, Int, HStack<RowContent>>, RowContent : View { }

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data, optionally allowing users to select a
    /// single row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    public init<Data, RowContent>(_ data: Data, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, Data.Element.ID, HStack<RowContent>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable { }

    /// Creates a hierarchical list that computes its rows on demand from an
    /// underlying collection of identifiable data, optionally allowing users to
    /// select a single row.
    ///
    /// - Parameters:
    ///   - data: The identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<Data, RowContent>(_ data: Data, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable { }

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data, optionally allowing users to select a
    /// single row.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, ID, HStack<RowContent>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View { }

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data, optionally allowing users to
    /// select a single row.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View { }

    /// Creates a list that computes its views on demand over a constant range.
    ///
    /// This instance only reads the initial value of `data` and doesn't need to
    /// identify views across updates. To compute views on demand over a dynamic
    /// range, use `List/init(_:id:selection:rowContent:)-9r2hz`.
    ///
    /// - Parameters:
    ///   - data: A *constant* range of data to populate the list.
    ///   - selection: A binding to a selected value.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(watchOS, unavailable)
    public init<RowContent>(_ data: Range<Int>, selection: Binding<SelectionValue?>?, @ViewBuilder rowContent: @escaping (Int) -> RowContent) where Content == ForEach<Range<Int>, Int, HStack<RowContent>>, RowContent : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension List where SelectionValue == Never {

    /// Creates a list with the given content.
    ///
    /// - Parameter content: The content of the list.
    public init(@ViewBuilder content: () -> Content) { }

    /// Creates a list that computes its rows on demand from an underlying
    /// collection of identifiable data.
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    public init<Data, RowContent>(_ data: Data, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, Data.Element.ID, HStack<RowContent>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable { }

    /// Creates a hierarchical list that computes its rows on demand from an
    /// underlying collection of identifiable data.
    ///
    /// - Parameters:
    ///   - data: A collection of identifiable data for computing the list.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<Data, RowContent>(_ data: Data, children: KeyPath<Data.Element, Data?>, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, Data.Element.ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, RowContent : View, Data.Element : Identifiable { }

    /// Creates a list that identifies its rows based on a key path to the
    /// identifier of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == ForEach<Data, ID, HStack<RowContent>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View { }

    /// Creates a hierarchical list that identifies its rows based on a key path
    /// to the identifier of the underlying data.
    ///
    /// - Parameters:
    ///   - data: The data for populating the list.
    ///   - id: The key path to the data model's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes a node capable
    ///     of having children that is currently childless, such as an empty
    ///     directory in a file system. On the other hand, if the property at the
    ///     key path is `nil`, then `data` is treated as a leaf node in the tree,
    ///     like a regular file in a file system.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    @available(iOS 14.0, macOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<Data, ID, RowContent>(_ data: Data, id: KeyPath<Data.Element, ID>, children: KeyPath<Data.Element, Data?>, @ViewBuilder rowContent: @escaping (Data.Element) -> RowContent) where Content == OutlineGroup<Data, ID, RowContent, RowContent, DisclosureGroup<RowContent, OutlineSubgroupChildren>>, Data : RandomAccessCollection, ID : Hashable, RowContent : View { }

    /// Creates a list that computes its views on demand over a constant range.
    ///
    /// This instance only reads the initial value of `data` and doesn't need to
    /// identify views across updates. To compute views on demand over a dynamic
    /// range, use `List/init(_:id:rowContent:)`.
    ///
    /// - Parameters:
    ///   - data: A *constant* range of data to populate the list.
    ///   - rowContent: A view builder that creates the view for a single row of
    ///     the list.
    public init<RowContent>(_ data: Range<Int>, @ViewBuilder rowContent: @escaping (Int) -> RowContent) where Content == ForEach<Range<Int>, Int, HStack<RowContent>>, RowContent : View { }
}

/// The configuration of a tint effect applied to content within a List.
///
/// - See Also: `View.listItemTint(_:)`
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ListItemTint {

    /// An explicit tint color.
    ///
    /// This tint effect is fixed and not overridable by other
    /// system effects.
    public static func fixed(_ tint: Color) -> ListItemTint { }

    /// An explicit tint color that is overridable.
    ///
    /// This tint effect is overridable by system effects, for
    /// example when the system has a custom user accent
    /// color on macOS.
    public static func preferred(_ tint: Color) -> ListItemTint { }

    /// A standard grayscale tint effect.
    ///
    /// Monochrome tints are not overridable.
    public static let monochrome: ListItemTint
}

/// This protocol modifies how a list appears and behaves.
///
/// No public interface is provided for this protocol, but several styles are provided by SwiftUI. These can be applied to a `List` with the `View/listStyle(_:)` modifier.
///
/// ![ListStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ListStyle-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         List {
///             Text("🍌🍌")
///             Text("🍎🍎")
///         }
///         .listStyle(InsetListStyle())
///     }
/// }
/// ```
///
/// Two list styles are included specifically for rendering grouped lists:
/// - `GroupedListStyle`
/// - `InsetGroupedListStyle`
///
/// These styles provide styling consistent with operating system standards for sectioned lists, including header styling.
///
/// ![ListStyle Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ListStyle-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///          List {
///               Section(header: Text("🍌🍌")) {
///                    Text("🔥🔥")
///               }
///               Section(header: Text("🍎🍎")) {
///                     Text("🔥🔥")
///               }
///          }
///         .listStyle(GroupedListStyle())
///     }
/// }
/// ```
///
/// Many SwiftUI list styles can be visualized [here](https:///swift-cast.com/2020/10/1/). All styles are explicitly referenced below.
///
/// - `DefaultListStyle` - provides the default list behavior and appearence for the platform.
/// - `GroupedListStyle` - provides default list behavior for grouped lists, including appropriate formating of section headers.
/// - `InsetGroupedListStyle` - is a variation of GroupedListStyle with insets including row backgrounds with rounded corners.
/// - `InsetListStyle` - is similar to a plain list, but includes additional layout insets.
/// - `PlainListStyle` - provides platform standard list appearance and behavior.
/// - `SidebarListStyle` - provides styling and behavior designed for an application level navigation bar used in iPadOS and MacOS. An example implementation can be found [here](https:swiftwithmajid.com/2020/07/21/sidebar-navigation-in-swiftui/). Currently not working properly on MacCatalyst.
/// - `EllipticalListStyle` - provides an elliptical list experience on WatchOS, including haptic feedback and unique animation when scrolling.
/// - `CarouselListStyle` - provides a coverflow-like experience on WatchOS lists including scroll animations that shrinks cells off-screen.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol ListStyle{ }
extension ListStyle {
}

/// The key used to look up a string in a strings file or strings dictionary
/// file.
///
/// To make the text in your app appear as many different languages
/// depending on the user's preference, use this structure in place
/// of ``String``.
///
/// Essentially the way localization works is that rather than using
/// strings directly throughout your app, you use this structure instead.
/// This lets you look up string keys which are translated to all
/// the app's supported languages in a .strings file.
///
/// To learn about creating this file and the process of setting up
/// your project for localization, check out these sources:
/// - [Swift with Majid](https://swiftwithmajid.com/2019/10/16/localization-in-swiftui/)
/// - [StackOverflow](https://stackoverflow.com/questions/58578341/how-to-implement-localization-in-swift-ui)
///
/// ### Creating a localized string key
///
/// The most straightforward way to create a localized string key is
/// using its initializer:
///
///     let hello = LocalizedStringKey("Hello")
///
/// You can also create a localized string key from a string literal,
/// but you must specify the type explicitly or else it will be
/// interpreted as a ``String:
///
///     let hello1 = "Hello" //Type String
///     let hello2: LocalizedStringKey = "Hello" //Type LocalizedStringKey
///
/// ### Using a localized string key
///
/// Many views in SwiftUI, like ``Button`` and ``Text``
/// accept localized string keys directly through their initializers by default.
///
///     struct UsingLocalizationView: View {
///         let text: LocalizedStringKey = "Hello"
///         var body: some View {
///             Button(text) { }
///             Text(text)
///         }
///
/// Also, since SwiftUI is localization-first, if you pass a string literal
/// to these initializers, they will be interpreted as localized string keys!
///
///     struct WithStringLiteralView: View {
///         var body: some View {
///             Text("This gets localized!")
///         }
///     }
///
/// However, if your variable is already a string, the intializer will
/// not localize the string:
///
///     struct RightAndWrongView: View {
///         let s = "Hello"
///         var body: some View {
///             Text(s) //Not localized
///             Text("Hello") //Localized!
///         }
///     }
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct LocalizedStringKey : Equatable, ExpressibleByStringInterpolation {

	/// Creates a localized string key from a `String` value.
    ///
    /// See ``LocalizedStringKey`` for more on how to use localization.
    ///
    ///     struct UsingLocalizationView: View {
    ///         let text = LocalizedStringKey("Hello")
    ///         var body: some View {
    ///             Text(text)
    ///         }
    ///     }
	///
	/// - Parameter value: The value for keying a string.
    public init(_ value: String) { }

    /// Creates an instance initialized to the given string value.
    ///
    /// Use this intializer when you would not like localization.
    ///
    ///     struct SameInEveryLanguageView: View {
    ///         let text = LocalizedStringKey(stringLiteral: "Aloha")
    ///         var body: some View {
    ///             Text(text) //"Aloha"
    ///         }
    ///     }
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String) { }

    /// Creates an instance from a string interpolation.
    ///
    /// Most `StringInterpolation` types will store information about the
    /// literals and interpolations appended to them in one or more properties.
    /// `init(stringInterpolation:)` should use these properties to initialize
    /// the instance.
    ///
    ///     struct UsingLocalizationView: View {
    ///         let name = "Majid"
    ///         var body: some View {
    ///             Text("myNameIs \(name)") //My name is Majid"
    ///         }
    ///     }
    ///
    /// And in the localization file, we will have:
    ///
    ///     "myNameIs %@" = "My name is %@.";
    ///
    /// - Parameter stringInterpolation: An instance of `StringInterpolation`
    ///             which has had each segment of the string literal appended
    ///             to it.
    public init(stringInterpolation: LocalizedStringKey.StringInterpolation) { }

    /// The type each segment of a string literal containing interpolations
    /// should be appended to.
    ///
    /// The `StringLiteralType` of an interpolation type must match the
    /// `StringLiteralType` of the conforming type.
    public struct StringInterpolation : StringInterpolationProtocol {

        /// Creates an empty instance ready to be filled with string literal content.
        ///
        /// Don't call this initializer directly. Instead, initialize a variable or
        /// constant using a string literal with interpolated expressions.
        ///
        /// Swift passes this initializer a pair of arguments specifying the size of
        /// the literal segments and the number of interpolated segments. Use this
        /// information to estimate the amount of storage you will need.
        ///
        /// - Parameter literalCapacity: The approximate size of all literal segments
        ///   combined. This is meant to be passed to `String.reserveCapacity(_:)`;
        ///   it may be slightly larger or smaller than the sum of the counts of each
        ///   literal segment.
        /// - Parameter interpolationCount: The number of interpolations which will be
        ///   appended. Use this value to estimate how much additional capacity will
        ///   be needed for the interpolated segments.
        public init(literalCapacity: Int, interpolationCount: Int) { }

        /// Appends a literal segment to the interpolation.
        ///
        /// Don't call this method directly. Instead, initialize a variable or
        /// constant using a string literal with interpolated expressions.
        ///
        /// Interpolated expressions don't pass through this method; instead, Swift
        /// selects an overload of `appendInterpolation`. For more information, see
        /// the top-level `StringInterpolationProtocol` documentation.
        ///
        /// - Parameter literal: A string literal containing the characters
        ///   that appear next in the string literal.
        public mutating func appendLiteral(_ literal: String) { }

        /// Interpolates the given value’s textual representation into the
        /// string literal being created.
        ///
        /// Do not call this method directly. It is used by the compiler when
        /// interpreting string interpolations. Instead, use string
        /// interpolation to create a new string by including values, literals,
        /// variables, or expressions enclosed in parentheses, prefixed by a
        /// backslash (\(…)).
        ///
        /// 	let price = 2
		///		let number = 3
		///		let message = """
        /// 				  If one cookie costs \(price) dollars, \
        ///                   \(number) cookies cost \(price * number) dollars.
        ///            	      """
		///		print(message)
		/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
        public mutating func appendInterpolation(_ string: String) { }

        /// Interpolates the given value’s textual representation into the
        /// string literal being created.
        ///
        /// Do not call this method directly. It is used by the compiler when
        /// interpreting string interpolations. Instead, use string
        /// interpolation to create a new string by including values, literals,
        /// variables, or expressions enclosed in parentheses, prefixed by a
        /// backslash (\(…)).
        ///
        /// 	let price = 2
		///		let number = 3
		///		let message = """
        /// 				  If one cookie costs \(price) dollars, \
        ///                   \(number) cookies cost \(price * number) dollars.
        ///            	      """
		///		print(message)
		/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
        public mutating func appendInterpolation<Subject>(_ subject: Subject, formatter: Formatter? = nil) where Subject : ReferenceConvertible { }

        /// Interpolates the given value’s textual representation into the
        /// string literal being created.
        ///
        /// Do not call this method directly. It is used by the compiler when
        /// interpreting string interpolations. Instead, use string
        /// interpolation to create a new string by including values, literals,
        /// variables, or expressions enclosed in parentheses, prefixed by a
        /// backslash (\(…)).
        ///
        /// 	let price = 2
		///		let number = 3
		///		let message = """
        /// 				  If one cookie costs \(price) dollars, \
        ///                   \(number) cookies cost \(price * number) dollars.
        ///            	      """
		///		print(message)
		/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
        public mutating func appendInterpolation<Subject>(_ subject: Subject, formatter: Formatter? = nil) where Subject : NSObject { }

        /// Interpolates the given value’s textual representation into the
        /// string literal being created.
        ///
        /// Do not call this method directly. It is used by the compiler when
        /// interpreting string interpolations. Instead, use string
        /// interpolation to create a new string by including values, literals,
        /// variables, or expressions enclosed in parentheses, prefixed by a
        /// backslash (\(…)).
        ///
        /// 	let price = 2
		///		let number = 3
		///		let message = """
        /// 				  If one cookie costs \(price) dollars, \
        ///                   \(number) cookies cost \(price * number) dollars.
        ///            	      """
		///		print(message)
		/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
        public mutating func appendInterpolation<T>(_ value: T) where T : _FormatSpecifiable { }

        /// Interpolates the given value’s textual representation into the
        /// string literal being created.
        ///
        /// Do not call this method directly. It is used by the compiler when
        /// interpreting string interpolations. Instead, use string
        /// interpolation to create a new string by including values, literals,
        /// variables, or expressions enclosed in parentheses, prefixed by a
        /// backslash (\(…)).
        ///
        /// 	let price = 2
		///		let number = 3
		///		let message = """
        /// 				  If one cookie costs \(price) dollars, \
        ///                   \(number) cookies cost \(price * number) dollars.
        ///            	      """
		///		print(message)
		/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
        public mutating func appendInterpolation<T>(_ value: T, specifier: String) where T : _FormatSpecifiable { }

        /// Interpolates the given value’s textual representation into the
        /// string literal being created.
        ///
        /// Do not call this method directly. It is used by the compiler when
        /// interpreting string interpolations. Instead, use string
        /// interpolation to create a new string by including values, literals,
        /// variables, or expressions enclosed in parentheses, prefixed by a
        /// backslash (\(…)).
        ///
        /// 	let price = 2
		///		let number = 3
		///		let message = """
        /// 				  If one cookie costs \(price) dollars, \
        ///                   \(number) cookies cost \(price * number) dollars.
        ///            	      """
		///		print(message)
		/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
        @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
        public mutating func appendInterpolation(_ text: Text) { }

        /// The type that should be used for literal segments.
        public typealias StringLiteralType = String
    }

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    public typealias StringLiteralType = String

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = String

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: LocalizedStringKey, b: LocalizedStringKey) -> Bool { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LocalizedStringKey.StringInterpolation {

	    /// Interpolates the given value’s textual representation into the
        /// string literal being created.
        ///
        /// Do not call this method directly. It is used by the compiler when
        /// interpreting string interpolations. Instead, use string
        /// interpolation to create a new string by including values, literals,
        /// variables, or expressions enclosed in parentheses, prefixed by a
        /// backslash (\(…)).
        ///
        /// 	let price = 2
		///		let number = 3
		///		let message = """
        /// 				  If one cookie costs \(price) dollars, \
        ///                   \(number) cookies cost \(price * number) dollars.
        ///            	      """
		///		print(message)
		/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public mutating func appendInterpolation(_ image: Image) { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension LocalizedStringKey.StringInterpolation {

    /// Interpolates the given value’s textual representation into the
    /// string literal being created.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (\(…)).
    ///
    /// 	let price = 2
	///		let number = 3
	///		let message = """
    /// 				  If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///            	      """
	///		print(message)
	/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public mutating func appendInterpolation(_ date: Date, style: Text.DateStyle) { }

    /// Interpolates the given value’s textual representation into the
    /// string literal being created.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (\(…)).
    ///
    /// 	let price = 2
	///		let number = 3
	///		let message = """
    /// 				  If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///            	      """
	///		print(message)
	/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public mutating func appendInterpolation(_ dates: ClosedRange<Date>) { }

    /// Interpolates the given value’s textual representation into the
    /// string literal being created.
    ///
    /// Do not call this method directly. It is used by the compiler when
    /// interpreting string interpolations. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (\(…)).
    ///
    /// 	let price = 2
	///		let number = 3
	///		let message = """
    /// 				  If one cookie costs \(price) dollars, \
    ///                   \(number) cookies cost \(price * number) dollars.
    ///            	      """
	///		print(message)
	/// 	// Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public mutating func appendInterpolation(_ interval: DateInterval) { }
}

/// A gesture that succeeds when the user performs a long press.
///
/// To recognize a long-press gesture on a view, create and configure the
/// gesture, then add it to the view using the `View/gesture(_:including:)`
/// modifier.
///
/// Add a long-press gesture to a `Circle` to animate its color from blue to
/// red, and then change it to green when the gesture ends:
///
///     struct LongPressGestureView: View {
///         @GestureState var isDetectingLongPress = false
///         @State var completedLongPress = false
///
///         var longPress: some Gesture {
///             LongPressGesture(minimumDuration: 3)
///                 .updating($isDetectingLongPress) { currentstate, gestureState,
///                         transaction in
///                     gestureState = currentstate
///                     transaction.animation = Animation.easeIn(duration: 2.0)
///                 }
///                 .onEnded { finished in
///                     self.completedLongPress = finished
///                 }
///         }
///
///         var body: some View {
///             Circle()
///                 .fill(self.isDetectingLongPress ?
///                     Color.red :
///                     (self.completedLongPress ? Color.green : Color.blue))
///                 .frame(width: 100, height: 100, alignment: .center)
///                 .gesture(longPress)
///         }
///     }
@available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 14.0, *)
public struct LongPressGesture : Gesture {

    /// The minimum duration of the long press that must elapse before the
    /// gesture succeeds.
    public var minimumDuration: Double

    /// The maximum distance that the long press can move before the gesture
    /// fails.
    @available(tvOS, unavailable)
    public var maximumDistance: CGFloat

    /// Creates a long-press gesture with a minimum duration and a maximum
    /// distance that the interaction can move before the gesture fails.
    ///
    /// - Parameters:
    ///   - minimumDuration: The minimum duration of the long press that must
    ///     elapse before the gesture succeeds.
    ///   - maximumDistance: The maximum distance that the fingers or cursor
    ///     performing the long press can move before the gesture fails.
    @available(tvOS, unavailable)
    public init(minimumDuration: Double = 0.5, maximumDistance: CGFloat = 10) { }

    /// The type representing the gesture's value.
    public typealias Value = Bool

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

/// A gesture that recognizes a magnification motion and tracks the amount of
/// magnification.
///
/// A magnification gesture tracks how a magnification event sequence changes.
/// To recognize a magnification gesture on a view, create and configure the
/// gesture, and then add it to the view using the
/// `View/gesture(_:including:)` modifier.
///
/// Add a magnification gesture to a `Circle` that changes its size while the
/// user performs the gesture:
///
///     struct MagnificationGestureView: View {
///
///         @GestureState var magnifyBy = CGFloat(1.0)
///
///         var magnification: some Gesture {
///             MagnificationGesture()
///                 .updating($magnifyBy) { currentState, gestureState, transaction in
///                     gestureState = currentState
///                 }
///         }
///
///         var body: some View {
///             Circle()
///                 .frame(width: 100 * magnifyBy,
///                        height: 100 * magnifyBy,
///                        alignment: .center)
///                 .gesture(magnification)
///         }
///     }
///
/// The circle's size resets to its original size when the gesture finishes.
@available(iOS 13.0, macOS 10.15, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct MagnificationGesture : Gesture {

    /// The minimum required delta before the gesture starts.
    public var minimumScaleDelta: CGFloat

    /// Creates a magnification gesture with a given minimum delta for the
    /// gesture to start.
    ///
    /// - Parameter minimumScaleDelta: The minimum scale delta required before
    ///   the gesture starts.
    public init(minimumScaleDelta: CGFloat = 0.01) { }

    /// The type representing the gesture's value.
    public typealias Value = CGFloat

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

/// A set of view properties that may be synchronized between views
/// using the `View.matchedGeometryEffect()` function.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public struct MatchedGeometryProperties : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: UInt32

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    @inlinable public init(rawValue: UInt32) { }

    /// The view's position, in window coordinates.
    public static let position: MatchedGeometryProperties

    /// The view's size, in local coordinates.
    public static let size: MatchedGeometryProperties

    /// Both the `position` and `size` properties.
    public static let frame: MatchedGeometryProperties

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = MatchedGeometryProperties

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = MatchedGeometryProperties

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = UInt32
}

/// A control for presenting a menu of actions.
///
/// A menu is created from a view builder of different views. Each
/// acceptable view will be shown as a different row in the menu.
/// The canonical view for using in a menu is ``Button``, but
/// these views also work: ``Menu``, ``Text``, ``Button``,
/// ``Link``, ``Label``, ``Divider``, and ``Image``.
///
/// There are 3 different initializers, one for each of the different label types:
/// 1. String
/// 2. Localized string key
/// 3. View
///
/// The following example presents a menu of three buttons and a submenu, which
/// contains three buttons of its own.
///
/// ```
/// struct MenuView: View {
///     var body: some View {
///         Menu("Actions") {
///             Button("Duplicate", action: { print("‼️") })
///             Button("Delete…", action: { print("🗑") })
///             Menu("Copy") {
///                 Button("Copy", action: { print("📑") })
///                 Button("Copy Formatted", action: { print("🔤") })
///             }
///         }
///     }
/// }
/// ```
///
/// You can create the menu's title with a `LocalizedStringKey`, as seen in
/// the previous example, or with a view builder that creates multiple views,
/// such as an image and a text view:
///
/// ```
/// struct MenuView: View {
///     var body: some View {
///         Menu {
///             Button("Open in Preview", action: { })
///             Button("Save as PDF", action: { })
///         } label: {
///             Image(systemName: "doc")
///             Text("PDF")
///         }
///     }
/// }
/// ```
///
/// ### Styling Menus
///
/// Use the `View/menuStyle(_:)` modifier to change the style of all menus
/// in a view. The following example shows how to apply a custom style:
///
/// ```
/// struct MenuView: View {
///     var body: some View {
///         Menu("Editing") {
///             Button("Set In Point", action: { })
///             Button("Set Out Point", action: { })
///         }
///         .menuStyle(EditingControlsMenuStyle())
///     }
/// }
/// ```
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Menu<Label, Content> : View where Label : View, Content : View {

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Menu {

    /// Creates a menu with a view label.
    ///
    /// ```
    /// struct MenuView: View {
    ///     var body: some View {
    ///         Menu {
    ///             Button("Open in Preview", action: { })
    ///             Button("Save as PDF", action: { })
    ///         } label: {
    ///             Image(systemName: "doc")
    ///             Text("PDF")
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - content: A group of menu items.
    ///     - label: A view describing the content of the menu.
    public init(@ViewBuilder content: () -> Content, @ViewBuilder label: () -> Label) { }

    /// Creates a menu with a localized string key label.
    ///
    /// ```
    /// struct MenuView: View {
    ///     var body: some View {
    ///         Menu(LocalizedStringKey("Actions")) {
    ///             Button("Duplicate", action: { print("‼️") })
    ///             Button("Delete…", action: { print("🗑") })
    ///             Menu("Copy") {
    ///                 Button("Copy", action: { print("📑") })
    ///                 Button("Copy Formatted", action: { print("🔤") })
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - titleKey: The key for the link's localized title, which describes
    ///         the contents of the menu.
    ///     - content: A group of menu items.
    public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content) where Label == Text { }

    /// Creates a menu with a string label.
    ///
    /// ```
    /// struct MenuView: View {
    ///     var body: some View {
    ///         Menu("Actions") {
    ///             Button("Duplicate", action: { print("‼️") })
    ///             Button("Delete…", action: { print("🗑") })
    ///             Menu("Copy") {
    ///                 Button("Copy", action: { print("📑") })
    ///                 Button("Copy Formatted", action: { print("🔤") })
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - title: A string that describes the contents of the menu.
    ///     - content: A group of menu items.
    public init<S>(_ title: S, @ViewBuilder content: () -> Content) where Label == Text, S : StringProtocol { }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Menu where Label == MenuStyleConfiguration.Label, Content == MenuStyleConfiguration.Content {

    /// Creates a menu based on a style configuration.
    ///
    /// Use this initializer within the `MenuStyle/makeBody(configuration:)`
    /// method of a `MenuStyle` instance to create an instance of the menu
    /// being styled. This is useful for custom menu styles that modify the
    /// current menu style.
    ///
    /// For example, the following code creates a new, custom style that adds a
    /// red border around the current menu style:
    ///
    ///     struct RedBorderMenuStyle: MenuStyle {
    ///         func makeBody(configuration: Configuration) -> some View {{}
    ///             Menu(configuration)
    ///                 .border(Color.red)
    ///         }
    ///     }
    ///
    public init(_ configuration: MenuStyleConfiguration) { }
}

/// A menu-formatted picker style.
///
/// > `MenuPickerStyle` is picker style that presents the options as a menu when the user presses a button, or as a submenu when nested within a larger menu.
///
/// > Use this style when there are more than five options. Consider using `InlinePickerStyle` when there are fewer than five options.
///
/// ![MenuPickerStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/pickerstyle-menu-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var fruits = ["Banana🍌🍌","Apple🍎🍎", "Peach🍑🍑", "Watermelon🍉🍉", "Grapes🍇🍇" ]
///     @State private var selectedFruit = 0
///
///     var body: some View {
///           VStack {
///               Picker(selection: $selectedFruit, label: Text("Select Favorite Fruit")) {
///                   ForEach(0..<fruits.count) {
///                       Text(self.fruits[$0])
///                   }
///               }
///
///               Text("Your Favorite Fruit: \(self.fruits[selectedFruit])")
///           }
///           .pickerStyle(MenuPickerStyle())
///     }
/// }
/// ```
///
/// [pickerstyle-menu ->]
/// Your app can also use explicit tags to identify picker content.
///
/// ![Menu Picker Style Example](/picker-style-3.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var favoriteFruit: MyFruit = MyFruit.banana
///
///     var fruitName: String {
///         switch favoriteFruit{
///         case .apple:
///             return "Apple 🍎🍎"
///         case .banana:
///             return "Banana 🍌🍌"
///         case .peach:
///             return "Peach 🍑🍑"
///         }
///     }
///
///     var body: some View {
///         Text("My Favorite Fruit: \(fruitName)")
///
///         Picker("My Picker", selection: $favoriteFruit) {
///             Text("Banana 🍌🍌")
///                 .tag(MyFruit.banana)
///             Text("Apple 🍎🍎")
///                 .tag(MyFruit.apple)
///             Text("Peach 🍑🍑")
///                 .tag(MyFruit.peach)
///         }.pickerStyle(MenuPickerStyle())
///     }
/// }
/// ```
///
/// [<-]
///
/// > The button itself indicates the selected option. You can include additional controls in the set of options, such as a button to customize the list of options.
///
/// > To apply this style to a picker, or to a view that contains pickers, use the `View/pickerStyle(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct MenuPickerStyle : PickerStyle {

    /// Creates a menu picker style.
    public init() { }
}

/// A type that applies standard interaction behavior and a custom appearance
/// to all menus within a view hierarchy.
///
/// To configure the current menu style for a view hiearchy, use the
/// `View/menuStyle(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol MenuStyle{ }
extension MenuStyle {

    /// A view that represents the body of a menu.
    associatedtype Body : View

    /// Creates a view that represents the body of a menu.
    ///
    /// - Parameter configuration: The properties of the menu.
    ///
    /// The system calls this method for each `Menu` instance in a view
    /// hierarchy where this style is the current menu style.
    func makeBody(configuration: Self.Configuration) -> Self.Body { }

    /// The properties of a menu.
    typealias Configuration = MenuStyleConfiguration
}

/// A configuration of a menu.
///
/// Use the `Menu/init(_:)` initializer of `Menu` to create an
/// instance using the current menu style, which you can modify to create a
/// custom style.
///
/// For example, the following code creates a new, custom style that adds a red
/// border to the current menu style:
///
///     struct RedBorderMenuStyle : MenuStyle {
///         func makeBody(configuration: Configuration) -> some View {{}
///             Menu(configuration)
///                 .border(Color.red)
///         }
///     }
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct MenuStyleConfiguration {

    /// A type-erased label of a menu.
    public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A type-erased content of a menu.
    public struct Content : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }
}

/// A value with a modifier applied to it.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ModifiedContent<Content, Modifier> {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never

    /// The content that the modifier transforms into a new view or new
    /// view modifier.
    public var content: Content

    /// The view modifier.
    public var modifier: Modifier

    /// A structure that the defines the content and modifier needed to produce
    /// a new view or view modifier.
    ///
    /// If `content` is a `View` and `modifier` is a `ViewModifier`, the
    /// result is a `View`. If `content` and `modifier` are both view
    /// modifiers, then the result is a new `ViewModifier` combining them.
    ///
    /// - Parameters:
    ///     - content: The content that the modifier changes.
    ///     - modifier: The modifier to apply to the content.
    @inlinable public init(content: Content, modifier: Modifier) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Allow an assistive technology to programmatically invoke the actions of the modified view.
    public func accessibilityAction(_ actionKind: AccessibilityActionKind = .default, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier> { }

    /// Allow an assistive technology to programmatically invoke the actions of the modified view and all subviews.
    public func accessibilityAction(named name: Text, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier> { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Allow an assistive technology to programmatically invoke the actions of the modified view and all subviews.
    public func accessibilityAction(named nameKey: LocalizedStringKey, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier> { }

    /// Allow an assistive technology to programmatically invoke the actions of the modified view and all subviews.
    public func accessibilityAction<S>(named name: S, _ handler: @escaping () -> Void) -> ModifiedContent<Content, Modifier> where S : StringProtocol { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent : Equatable where Content : Equatable, Modifier : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ModifiedContent<Content, Modifier>, b: ModifiedContent<Content, Modifier>) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent : View where Content : View, Modifier : ViewModifier {

    /// The content and behavior of the view.
    public var body: ModifiedContent<Content, Modifier>.Body { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent : ViewModifier where Content : ViewModifier, Modifier : ViewModifier {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent : DynamicViewContent where Content : DynamicViewContent, Modifier : ViewModifier {

    /// The collection of underlying data.
    public var data: Content.Data { get }

    /// The type of the underlying collection of data.
    public typealias Data = Content.Data
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent : Scene where Content : Scene, Modifier : _SceneModifier {

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from primitive scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's `SwiftUI/Scene/Body-swift.associatedtype`
    /// associated type based on the contents of the `body` property.
    public var body: ModifiedContent<Content, Modifier>.Body { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Specifies whether to hide this view from system accessibility features.
    public func accessibilityHidden(_ hidden: Bool) -> ModifiedContent<Content, Modifier> { }

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    public func accessibilityLabel(_ label: Text) -> ModifiedContent<Content, Modifier> { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    public func accessibilityValue(_ value: Text) -> ModifiedContent<Content, Modifier> { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    public func accessibilityHint(_ hint: Text) -> ModifiedContent<Content, Modifier> { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// If you don't specify any input labels, the user can still refer to the view using the accessibility
    /// label that you add with the accessibilityLabel() modifier. Provide labels in descending order
    /// of importance. Voice Control and Full Keyboard Access use the input labels.
    public func accessibilityInputLabels(_ inputLabels: [Text]) -> ModifiedContent<Content, Modifier> { }

    /// Adds the given traits to the view.
    public func accessibilityAddTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier> { }

    /// Removes the given traits from this view.
    public func accessibilityRemoveTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier> { }

    /// Uses the specified string to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    public func accessibilityIdentifier(_ identifier: String) -> ModifiedContent<Content, Modifier> { }

    /// Sets the sort priority order for this view's accessibility
    /// element, relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    public func accessibilitySortPriority(_ sortPriority: Double) -> ModifiedContent<Content, Modifier> { }

    /// Specifies the point where activations occur in the view.
    public func accessibilityActivationPoint(_ activationPoint: CGPoint) -> ModifiedContent<Content, Modifier> { }

    /// Specifies the unit point where activations occur in the view.
    public func accessibilityActivationPoint(_ activationPoint: UnitPoint) -> ModifiedContent<Content, Modifier> { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    public func accessibilityLabel(_ labelKey: LocalizedStringKey) -> ModifiedContent<Content, Modifier> { }

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    public func accessibilityLabel<S>(_ label: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    public func accessibilityValue(_ valueKey: LocalizedStringKey) -> ModifiedContent<Content, Modifier> { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    public func accessibilityValue<S>(_ value: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    public func accessibilityHint(_ hintKey: LocalizedStringKey) -> ModifiedContent<Content, Modifier> { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    public func accessibilityHint<S>(_ hint: S) -> ModifiedContent<Content, Modifier> where S : StringProtocol { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    public func accessibilityInputLabels(_ inputLabelKeys: [LocalizedStringKey]) -> ModifiedContent<Content, Modifier> { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    public func accessibilityInputLabels<S>(_ inputLabels: [S]) -> ModifiedContent<Content, Modifier> where S : StringProtocol { }
}

extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Specifies whether to hide this view from system accessibility features.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    public func accessibility(hidden: Bool) -> ModifiedContent<Content, Modifier> { }

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    public func accessibility(label: Text) -> ModifiedContent<Content, Modifier> { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibility(label:),
    /// you can provide the current volume setting, like "60%", using accessibility(value:).
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    public func accessibility(value: Text) -> ModifiedContent<Content, Modifier> { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    public func accessibility(hint: Text) -> ModifiedContent<Content, Modifier> { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// If you don't specify any input labels, the user can still refer to the view using the accessibility
    /// label that you add with the accessibilityLabel() modifier. Provide labels in descending order
    /// of importance. Voice Control and Full Keyboard Access use the input labels.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    public func accessibility(inputLabels: [Text]) -> ModifiedContent<Content, Modifier> { }

    /// Adds the given traits to the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    public func accessibility(addTraits traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier> { }

    /// Removes the given traits from this view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    public func accessibility(removeTraits traits: AccessibilityTraits) -> ModifiedContent<Content, Modifier> { }

    /// Uses the specified string to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    public func accessibility(identifier: String) -> ModifiedContent<Content, Modifier> { }

    @available(iOS, deprecated, introduced: 13.0)
    @available(macOS, deprecated, introduced: 10.15)
    @available(tvOS, deprecated, introduced: 13.0)
    @available(watchOS, deprecated, introduced: 6)
    public func accessibility(selectionIdentifier: AnyHashable) -> ModifiedContent<Content, Modifier> { }

    /// Sets the sort priority order for this view's accessibility
    /// element, relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    public func accessibility(sortPriority: Double) -> ModifiedContent<Content, Modifier> { }

    /// Specifies the point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    public func accessibility(activationPoint: CGPoint) -> ModifiedContent<Content, Modifier> { }

    /// Specifies the unit point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    public func accessibility(activationPoint: UnitPoint) -> ModifiedContent<Content, Modifier> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds an accessibility scroll action to the view.
    public func accessibilityScrollAction(_ handler: @escaping (Edge) -> Void) -> ModifiedContent<Content, Modifier> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ModifiedContent where Modifier == AccessibilityAttachmentModifier {

    /// Adds an accessibility adjustable action to the view.
    public func accessibilityAdjustableAction(_ handler: @escaping (AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Content, Modifier> { }
}

/// A dynamic property type that allows access to a namespace defined
/// by the persistent identity of the object containing the property
/// (e.g. a view).
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen @propertyWrapper public struct Namespace : DynamicProperty {

	/// Create an empty namespace.
    @inlinable public init() { }

    /// The namespace ID from the property wrapper.
    public var wrappedValue: Namespace.ID { get }

    /// A namespace defined by the persistent identity of an
    /// `@Namespace` dynamic property.
    @frozen public struct ID : Hashable {

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Namespace.ID, b: Namespace.ID) -> Bool { }
    }
}

/// A configuration for a navigation bar that represents a view at the top of a
/// navigation stack.
///
/// [[navigation-bar-items]]
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
public struct NavigationBarItem {

    /// A style for displaying the title of a navigation bar.
    public enum TitleDisplayMode {

        /// Inherit the display mode from the previous navigation item.
        case automatic

        /// Display the title within the standard bounds of the navigation bar.
        case inline

        /// Display a large title within an expanded navigation bar.
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        case large

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NavigationBarItem.TitleDisplayMode, b: NavigationBarItem.TitleDisplayMode) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension NavigationBarItem.TitleDisplayMode : Equatable {
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension NavigationBarItem.TitleDisplayMode : Hashable {
}

/// A view that controls a navigation presentation.
///
/// [[navigation-link]]
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct NavigationLink<Label, Destination> : View where Label : View, Destination : View {

    /// Creates an instance that presents `destination`.
    public init(destination: Destination, @ViewBuilder label: () -> Label) { }

    /// Creates an instance that presents `destination` when active.
    public init(destination: Destination, isActive: Binding<Bool>, @ViewBuilder label: () -> Label) { }

    /// Creates an instance that presents `destination` when `selection` is set
    /// to `tag`.
    public init<V>(destination: Destination, tag: V, selection: Binding<V?>, @ViewBuilder label: () -> Label) where V : Hashable { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension NavigationLink where Label == Text {

    /// Creates an instance that presents `destination`, with a `Text` label
    /// generated from a title string.
    public init(_ titleKey: LocalizedStringKey, destination: Destination) { }

    /// Creates an instance that presents `destination`, with a `Text` label
    /// generated from a title string.
    public init<S>(_ title: S, destination: Destination) where S : StringProtocol { }

    /// Creates an instance that presents `destination` when active, with a
    /// `Text` label generated from a title string.
    public init(_ titleKey: LocalizedStringKey, destination: Destination, isActive: Binding<Bool>) { }

    /// Creates an instance that presents `destination` when active, with a
    /// `Text` label generated from a title string.
    public init<S>(_ title: S, destination: Destination, isActive: Binding<Bool>) where S : StringProtocol { }

    /// Creates an instance that presents `destination` when `selection` is set
    /// to `tag`, with a `Text` label generated from a title string.
    public init<V>(_ titleKey: LocalizedStringKey, destination: Destination, tag: V, selection: Binding<V?>) where V : Hashable { }

    /// Creates an instance that presents `destination` when `selection` is set
    /// to `tag`, with a `Text` label generated from a title string.
    public init<S, V>(_ title: S, destination: Destination, tag: V, selection: Binding<V?>) where S : StringProtocol, V : Hashable { }
}

@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension NavigationLink {

    /// Sets whether or not the `NavigationLink` should present its destination
    /// as the "detail" component of the containing `NavigationView`.
    ///
    /// If not set, defaults to `true`.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func isDetailLink(_ isDetailLink: Bool) -> some View { }

}

/// A container for view navigation along with a (optional) navigation bar.
///
/// `NavigationView` is a container that adds stack-based navigation to a view, along with a (optional) navigation bar.
///
/// ### Setting up a navigation stack
///
/// A navigation stack is set up simply by wrapping your view in a `NavigationView`
///
/// ![NavigationView Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///         }
///     }
/// }
/// ```
///
/// A navigation bar is added by default. The navigation bar can be hidden via  `View/navigationBarHidden(_:)`.
/// [navigation-title ->]
/// ### Adding a navigation title
///
/// Use `View/navigationTitle(_:)` to add a title to the navigation bar within your `NavigationView`:
///
/// ![NavigationView Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///                 .navigationTitle("Home")
///         }
///     }
/// }
/// ```
///
/// `View/navigationTitle(_:)` is only available on iOS 14 and higher. If your application targets iOS 13, please use `View/navigationBarTitle(_:)`.
/// [<-]
/// [navigation-title-display-mode ->]
/// ### Setting the navigation title display mode
///
/// The display mode of a navigation bar title can be controlled via `View/navigationBarTitleDisplayMode(_:)`. There are two main display modes:
///
/// - `NavigationBarItem.TitleDisplayMode.inline`
/// - `NavigationBarItem.TitleDisplayMode.large`
///
/// An `.automatic` mode is also present, and represents the system default.
///
/// The following example forces a large navigation title:
///
/// ![NavigationView Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///                 .navigationTitle("Home")
///                 .navigationBarTitleDisplayMode(.large)
///         }
///     }
/// }
/// ```
/// [<-]
/// [navigation-link ->]
/// ### Navigating to a view
///
/// Use `NavigationLink` to add a button that pushes a new view onto the navigation stack.
///
/// For example, the following presents `ApplesView` when the link "I want apples!" is pressed:
///
/// ![NavigationView Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-4.gif)
///
/// ```
/// struct ExampleView: View {
///     struct BananasView: View {
///         var body: some View {
///             Text("Bananas")
///                 .navigationTitle("🍌🍌")
///         }
///     }
///
///     var body: some View {
///         NavigationView {
///             NavigationLink(destination: BananasView()) {
///                 Text("I want bananas!")
///             }
///         }
///     }
/// }
/// ```
/// [<-]
/// [navigation-bar-hidden ->]
/// ### Hiding the navigation bar
///
/// The navigation bar is on by default within a `NavigationView`. It can be hidden using `View/navigationBarHidden(_:)`.
///
/// For example:
///
/// ![NavigationView Example 5](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-5.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///                 .navigationBarHidden(true)
///         }
///     }
/// }
/// ```
///
/// Note that the navigation bar can be unhidden by child views. `View/navigationBarHidden(_:)` is a *preference value*, and uses the value proposed by the deepest view in the hierarchy as its active value. This is to say, a screen with the navigation bar hidden can push a screen that unhides the bar.
///
/// For example, navigating to `SecondScreen` in the following unhides the bar:
///
/// ![NavigationView Example 6](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-6.gif)
///
/// ```
/// struct ExampleView: View {
///     struct SecondScreen: View {
///         var body: some View {
///             Text("Bananas🍌🍌")
///                 .navigationTitle("Second Screen")
///                 .navigationBarHidden(false)
///         }
///     }
///
///     var body: some View {
///         NavigationView {
///             VStack {
///                 Text("Hello Bananas🍌🍌")
///
///                 NavigationLink(destination: SecondScreen()) {
///                     Text("Take me to the second screen!")
///                 }
///             }
///             .navigationBarHidden(true)
///         }
///     }
/// }
/// ```
///
/// And popping `SecondScreen` (or navigating back) hides it again, as `SecondScreen` is removed from the view hierarchy, leaving `ExampleView` as the deepest view in the hierarchy - which has hidden the navigation bar.
/// [<-]
/// [navigation-bar-items ->]
/// ### Adding navigation bar items
///
/// Use `View/navigationBarItems(leading:trailing:)` to add items to a navigation bar's leading and trailing areas.
///
/// For example, the following adds "🍌🍌" to the leading area, and "🍏🍏" to the trailing area:
///
/// ![NavigationView Example 7](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-11.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///                  .navigationBarItems(leading: Text("🍌🍌"), trailing: Text("🍏🍏"))
///         }
///     }
/// }
/// ```
/// [<-]
/// [navigation-view-style ->]
/// ### Styling a navigation view
///
/// Use `View/navigationViewStyle(_:)` to style a navigation view.
///
/// For example, the following forces a stack-based navigation style, overriding the default double-colum style on macCatalyst:
///
/// ![NavigationView Example 8](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-8.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///         }
///         .navigationViewStyle(StackNavigationViewStyle())
///     }
/// }
/// ```
///
/// And the following forces a double-column navigation style, overriding the default stack-based navigation style on iPadOS:
///
/// ![NavigationView Example 9](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-9.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///         }
///         .navigationViewStyle(DoubleColumnNavigationViewStyle())
///     }
/// }
/// ```
/// [<-]
/// ### Handling selection
///
/// `NavigationLink` provides the ability to observe and/or set the active navigation selection via its initializer `NavigationLink/init(destination:tag:selection:label)`.
///
/// For example:
///
/// ![NavigationView Example 10](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-10.gif)
///
/// ```
/// struct ExampleView: View {
///     enum NavigationItem {
///         case bananas
///         case apples
///         case peaches
///     }
///
///     @State var navigatedItem: NavigationItem? = .bananas
///
///     var body: some View {
///         NavigationView {
///             NavigationLink(
///                 destination: Text("🍏🍏"),
///                 tag: NavigationItem.apples,
///                 selection: $navigatedItem
///             ) {
///                 Text("Apples")
///             }
///
///             NavigationLink(
///                 destination: Text("🍌🍌"),
///                 tag: NavigationItem.bananas,
///                 selection: $navigatedItem
///             ) {
///                 Text("Bananas")
///             }
///
///             NavigationLink(
///                 destination: Text("🍑🍑"),
///                 tag: NavigationItem.peaches,
///                 selection: $navigatedItem
///             ) {
///                 Text("Peaches")
///             }
///         }
///     }
/// }
/// ```
///
/// In the example above, the navigation selection is written to a state variable, `navigatedItem`. `navigatedItem` is an optional, because it is possible for the screen to not be navigated to any particular screen (i.e. be at the root view containing the 3 navigation links).
///
///  See `ToolbarItem` for more on what can be placed in the navigation bar.
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
public struct NavigationView<Content> : View where Content : View {

	/// Creates a navigation view from a view builder of content.
	///
	/// - Parameter content: The view builder of content displayed on the first view in the navigation stack.
    public init(@ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// Structures conforming to ``NavigationViewStyle`` can be used to style a ``NavigationView`` via
/// ``View/navigationViewStyle(_:)``.
///
/// There are only 3 styles that conform to the navigation view style protocol:
/// - ``DefaultNavigationViewStyle``
/// - ``DoubleColumnNavigationViewStyle``
/// - ``StackNavigationViewStyle``
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
public protocol NavigationViewStyle{ }
extension NavigationViewStyle {
}

/// A SwiftUI property wrapper that subscribes to an observable object.
///
/// - Like `@StateObject`, this type subscribes to the observable object and invalidates a view whenever the observable object changes.
/// - Unlike `@StateObject,` `@ObservedObject` does not persist the object in state. Objects are only *assigned* to `@ObservedObject`, they should be initialized and persistent by an ancestor view.
///
/// ### Usage
///
/// In the following example, an observable object is assigned to an `@ObservedObject` variable:
///
/// ```
/// class AppModel: ObservableObject {
///     static let shared = AppModel()
///
///     @Published var fruitName: String = "Apple"
/// }
///
/// struct ExampleView: View {
///     @ObservedObject var appModel = AppModel.shared
///
///     var body: some View {
///         VStack {
///             Text(appModel.fruitName)
///
///             Button("Change Text") {
///                 appModel.fruitName = "Banana"
///             }
///         }
///     }
/// }
/// ```
///
/// In the example above, `ExampleView` will update its displayed text to "Banana" when the button labeled "Change Text" is pressed. This is because `ExampleView` has subscribed to `AppModel.shared` via the `@ObservedObject` `appModel` variable.
///
/// Whenever the object referenced by `appModel` (which is `AppModel.shared` in this case) emits a change, `ExampleView` will be invalidated and redrawn.
///
/// ### Creating bindings
///
/// Just like `@State`, `@EnvironmentObject` and `@StateObject`, `@ObservedObject` allows you to create a `Binding` to an object using the `$` prefix syntax.
///
/// For example:
///
/// ```
/// class AppModel: ObservableObject {
///     static let shared = AppModel()
///
///     @Published var fruitName: String = "Apple"
/// }
///
/// struct ExampleView: View {
///     @ObservedObject var appModel = AppModel.shared
///
///     var body: some View {
///         TextField("Enter fruit name", text: $appModel.fruitName)
///     }
/// }
/// ```
///
/// In this example, a two-way connection is established between `appModel.fruitName` and `TextField`, by using the `$` prefix to create a `Binding<String>`. This allows `TextField` to update the `fruitName` variable when the user enters text, and also to update its own displayed text if `fruitName` is changed programmatically.
///
/// ### Passing an observable object to a child view using `@ObservedObject`
///
/// Pass an observable object like you would pass any other variable down to a child view. For example:
///
/// ```
/// struct ExampleView: View {
///     @StateObject var appModel = AppModel()
///
///     struct ChildView: View {
///         @ObservedObject var appModel: AppModel
///
///         var body: some View {
///             TextField("Enter fruit name", text: $appModel.fruitName)
///         }
///     }
///
///     var body: some View {
///         ChildView(appModel: appModel)
///     }
/// }
/// ```
///
/// It is a common pattern for a parent view to create a `@StateObject` to hold an observable object, and then to pass it down to a child using an `@ObservedObject`. `@StateObject` **owns** the object, `@ObservedObject` simply holds a reference to the object.
///
/// ### Comparison with `@StateObject`
///
/// Consider the following:
///
/// ```
/// struct ExampleView: View {
///     class ViewModel: ObservableObject {
///         init() {
///             print("Initialized")
///         }
///     }
///
///     struct ToggleDescription: View {
///         let value: Bool
///
///         @StateObject var viewModel = ViewModel()
///
///         var body: some View {
///             Text("The value is: \(String(describing: value))")
///         }
///     }
///
///     @State var foo = false
///
///     var body: some View {
///         VStack {
///             ToggleDescription(value: foo)
///
///             Toggle("Refresh", isOn: $foo)
///         }
///     }
/// }
/// ```
///
/// `ExampleView` creates a vertical stack of a `Toggle`, and a view that describes the toggle, `ToggleDescription`.
///
/// `ToggleDescription` also contains a `ViewModel`, that is instantiated and held by `@StateObject`. The `ViewModel` prints on initialization. Run this code and observe that the following is printed:
///
/// ```
/// Initialized
/// ```
///
/// Flip the toggle twice. Note that even though `ToggleDescription` is refreshed, nothing is printed further.
///
/// Now consider the following:
///
/// ```
/// struct ExampleView: View {
///     class ViewModel: ObservableObject {
///         init() {
///             print("Initialized")
///         }
///     }
///
///     struct ToggleDescription: View {
///         let value: Bool
///
///         @ObservedObject var viewModel = ViewModel()
///
///         var body: some View {
///             Text("The value is: \(String(describing: value))")
///         }
///     }
///
///     @State var foo = false
///
///     var body: some View {
///         VStack {
///             ToggleDescription(value: foo)
///
///             Toggle("Refresh", isOn: $foo)
///         }
///     }
/// }
/// ```
///
/// This example is identical to the previous example **except** for the fact that `@StateObject` has been replaced with `@ObservedObject`. Run this code now, and observe the following print again:
///
/// ```
/// Initialized
/// ```
///
/// Now flip the toggle twice. The console will print the following:
///
/// ```
/// Initialized
/// Initialized
/// ```
///
/// This highlights the fundamental difference between `@StateObject` and `@ObservedObject`.
///
/// -  `@StateObject` instantiates and holds the object in state.
/// -  `@ObservedObject` is *assigned* an object, and **does not** hold it in state
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@propertyWrapper @frozen public struct ObservedObject<ObjectType> : DynamicProperty where ObjectType : ObservableObject {

    /// A wrapper of the underlying observable object that can create bindings to
    /// its properties using dynamic member lookup.
    @dynamicMemberLookup @frozen public struct Wrapper {

        /// Returns a binding to the resulting value of a given key path.
        ///
        /// - Parameter keyPath  : A key path to a specific resulting value.
        ///
        /// - Returns: A new binding.
        public subscript<Subject>(dynamicMember keyPath: ReferenceWritableKeyPath<ObjectType, Subject>) -> Binding<Subject> { get }
    }

    /// Creates an observed object with an initial value.
    ///
    /// - Parameter initialValue: An initial value.
    public init(initialValue: ObjectType) { }

    /// Creates an observed object with an initial wrapped value.
    ///
    /// You don't call this initializer directly. Instead, declare a property
    /// with the `@ObservedObject` attribute, and provide an initial value.
    ///
    /// - Parameter wrappedValue: An initial value.
    public init(wrappedValue: ObjectType) { }

    /// The underlying value referenced by the observed object.
    ///
    /// This property provides primary access to the value's data. However, you
    /// don't access `wrappedValue` directly. Instead, you use the property
    /// variable created with the `@ObservedObject` attribute.
    ///
    /// When a mutable value changes, the new value is immediately available.
    /// However, a view displaying the value is updated asynchronously and may
    /// not show the new value immediately.
    public var wrappedValue: ObjectType

    /// A projection of the observed object that creates bindings to its
    /// properties using dynamic member lookup.
    ///
    /// Use the projected value to pass a binding value down a view hierarchy.
    /// To get the `projectedValue`, prefix the property variable with `$`.
    public var projectedValue: ObservedObject<ObjectType>.Wrapper { get }
}

/// A shape with a translation offset transform applied to it.
///
/// An offset shape has two use cases:
/// 1. Used directly via its initializer ``RotatedShape/init(shape:offset:)``.
/// 2. The return value of ``Shape/offset(_:)`` and ``Shape/offset(x:y:)``.
///
/// Having an offset shape is helpful because it allows you to translate a shape
/// and then continue to use its shape properties, instead of turning into ``View``.
///
/// A simple example of constructing an `OffsetShape`:
///
/// ```
/// struct OffsetShapeView: View {
///     var body: some View {
///         OffsetShape(shape: Circle(),
///                     offset: CGSize(width: 20, height: 20))
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct OffsetShape<Content> : Shape where Content : Shape {

	/// The original shape that you want to move up, sideways, or both.
    ///
    /// ```
    /// struct OffsetShapeView: View {
    ///     let offsetShape =  OffsetShape(shape: Circle(),
    ///                                    offset: CGSize(width: 20, height: 20))
    ///     var body: some View {
    ///         ZStack {
    ///             offsetShape
    ///             offsetShape.shape
    ///                 .opacity(0.2)
    ///         }
    ///     }
    /// }
    /// ```
    public var shape: Content

    /// The amount the shape is offset.
    ///
    /// ```
    /// struct OffsetShapeView: View {
    ///     let offsetShape =  OffsetShape(shape: Circle(),
    ///                                    offset: CGSize(width: 20, height: 20))
    ///     var body: some View {
    ///         offsetShape
    ///             .onAppear {
    ///                 print(offsetShape.offset.width) //20
    ///             }
    ///     }
    /// }
    /// ```
    public var offset: CGSize

    /// Use this to take an original shape and move it to a new place on the screen.
    ///
    /// ```
    /// struct OffsetShapeView: View {
    ///     var body: some View {
    ///         OffsetShape(shape: Circle(),
    ///                     offset: CGSize(width: 20, height: 20))
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - shape: The original shape that you want to move.
    ///   - offset: The amount that you want to move the shape.
    @inlinable public init(shape: Content, offset: CGSize) { }

    /// Describes this shape as a path within a rectangular frame of reference.
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    public func path(in rect: CGRect) -> Path { }

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<Content.AnimatableData, CGSize.AnimatableData>

    /// The data to animate.
    public var animatableData: OffsetShape<Content>.AnimatableData

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension OffsetShape : InsettableShape where Content : InsettableShape {

    /// Returns `self` inset by `amount`.
    @inlinable public func inset(by amount: CGFloat) -> OffsetShape<Content.InsetShape> { }

    /// The type of the inset shape.
    public typealias InsetShape = OffsetShape<Content.InsetShape>
}

/// Provides functionality for opening a URL.
///
/// The `OpenURLAction` instance in the app's `Environment` offers
/// a handler that you can use to open a URL in response to some action.
/// Use the `EnvironmentValues/openURL` environment value to get the handler.
/// Then call the action's handler when you need to open a URL. For example,
/// you can open a support URL in response to when a user taps a button:
///
///     struct OpenUrlActionView: View {
///         @Environment(\.openURL) var openURL
///
///         var body: some View {
///             Button(action: contactSupport) {
///                 Text("Email Support")
///                 Image(systemName: "envelope.open")
///             }
///         }
///
///         func contactSupport() {{}
///             guard let url = URL(string: "https://www.example.com") else {
///                 return
///             }
///             openURL(url)
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct OpenURLAction {

    /// Opens a URL, following system conventions.
    ///
    /// Use this method to attempt to open a URL. This function handles the
    /// calling of the platform specific URL handler contained in the
    /// `openURL` property stored the app's `Environment`, and is used when
    /// you call the function `openURL(:_)`.
    ///
    /// - Parameters:
    ///   - url: The URL to open.
    public func callAsFunction(_ url: URL) { }

    /// Asynchronously opens a URL, following system conventions.
    ///
    /// Use this method when attempting to asynchronously open a URL; the
    /// result indicates whether the system was able open the URL.
    /// The completion runs after the system decides that it can open the URL,
    /// but the full opening of the URL may not yet be complete when calling the
    /// completion handler.
    ///
    /// - Parameters:
    ///   - url: The URL to open.
    ///   - completion: A closure the method calls after determining if
    ///     it is possible to open the URL, although possibly before fully
    ///     opening the URL. The closure takes a Boolean that indicates whether
    ///     the URL can be opened.
    @available(watchOS, unavailable)
    public func callAsFunction(_ url: URL, completion: @escaping (Bool) -> Void) { }
}

/// A structure that computes views and disclosure groups on demand from an
/// underlying collection of tree-structured, identified data.
///
/// Use an outline group when you need a view that can represent a hierarchy
/// of data by using disclosure views. This allows the user to navigate the
/// tree structure by using the disclosure views to expand and collapse
/// branches.
///
/// In the following example, a tree structure of `FileItem` data offers a
/// simplified view of a file system. Passing the root of this tree and the
/// key path of its children allows you to quickly create a visual
/// representation of the file system.
///
///     struct FileItem: Hashable, Identifiable, CustomStringConvertible {
///         var id: Self { self }
///         var name: String
///         var children: [FileItem]? = nil
///         var description: String {
///             switch children {
///             case nil:
///                 return "📄 \(name)"
///             case .some(let children):
///                 return children.isEmpty ? "📂 \(name)" : "📁 \(name)"
///             }
///         }
///     }
///
///     let data =
///       FileItem(name: "users", children:
///         [FileItem(name: "user1234", children:
///           [FileItem(name: "Photos", children:
///             [FileItem(name: "photo001.jpg"),
///              FileItem(name: "photo002.jpg")]),
///            FileItem(name: "Movies", children:
///              [FileItem(name: "movie001.mp4")]),
///               FileItem(name: "Documents", children: [])
///           ]),
///          FileItem(name: "newuser", children:
///            [FileItem(name: "Documents", children: [])
///            ])
///         ])
///
///     OutlineGroup(data, children: \.children) { item in
///         Text("\(item.description)")
///     }
///
/// ### Type Parameters
///
/// Five generic type constraints define a specific `OutlineGroup` instance:
///
/// - `Data`: The type of a collection containing the children of an element in
///   the tree-shaped data.
/// - `ID`: The type of the identifier for an element.
/// - `Parent`: The type of the visual representation of an element whose
///   children property is non-`nil`
/// - `Leaf`: The type of the visual representation of an element whose
///   children property is `nil`.
/// - `Subgroup`: A type of a view that groups a parent view and a view
///   representing its children, typically with some mechanism for showing and
///   hiding the children
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct OutlineGroup<Data, ID, Parent, Leaf, Subgroup> where Data : RandomAccessCollection, ID : Hashable {
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup where ID == Data.Element.ID, Parent : View, Parent == Leaf, Subgroup == DisclosureGroup<Parent, OutlineSubgroupChildren>, Data.Element : Identifiable {

    /// Creates an outline group from a root data element and a key path to
    /// its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///    element in `data`.
    public init<DataElement>(_ root: DataElement, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement : Identifiable, DataElement == Data.Element { }

    /// Creates an outline group from a collection of root data elements and
    /// a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///    element in `data`.
    public init<DataElement>(_ data: Data, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where ID == DataElement.ID, DataElement : Identifiable, DataElement == Data.Element { }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup where Parent : View, Parent == Leaf, Subgroup == DisclosureGroup<Parent, OutlineSubgroupChildren> {

    /// Creates an outline group from a root data element, the key path to its
    /// identifier, and a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - root: The root of a collection of tree-structured, identified
    ///     data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///    element in `data`.
    public init<DataElement>(_ root: DataElement, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where DataElement == Data.Element { }

    /// Creates an outline group from a collection of root data elements, the
    /// key path to a data element's identifier, and a key path to its children.
    ///
    /// This initializer creates an instance that uniquely identifies views
    /// across updates based on the identity of the underlying data element.
    ///
    /// All generated disclosure groups begin in the collapsed state.
    ///
    /// Make sure that the identifier of a data element only changes if you
    /// mean to replace that element with a new element, one with a new
    /// identity. If the ID of an element changes, then the content view
    /// generated from that element will lose any current state and animations.
    ///
    /// - Parameters:
    ///   - data: A collection of tree-structured, identified data.
    ///   - id: The key path to a data element's identifier.
    ///   - children: A key path to a property whose non-`nil` value gives the
    ///     children of `data`. A non-`nil` but empty value denotes an element
    ///     capable of having children that's currently childless, such as an
    ///     empty directory in a file system. On the other hand, if the property
    ///     at the key path is `nil`, then the outline group treats `data` as a
    ///     leaf in the tree, like a regular file in a file system.
    ///   - content: A view builder that produces a content view based on an
    ///    element in `data`.
    public init<DataElement>(_ data: Data, id: KeyPath<DataElement, ID>, children: KeyPath<DataElement, Data?>, @ViewBuilder content: @escaping (DataElement) -> Leaf) where DataElement == Data.Element { }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension OutlineGroup : View where Parent : View, Leaf : View, Subgroup : View {

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

/// A type-erased view representing the children in an outline subgroup.
///
/// `OutlineGroup` uses this type as a generic constraint for the `Content`
/// of the `DisclosureGroup` instances it creates.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct OutlineSubgroupChildren : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// An index view style that places a page index view over its content.
///
/// ![TabView Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-4.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var items = ["Bananas 🍌🍌", "Apples 🍏🍏", "Peaches 🍑🍑"]
///
///     var body: some View {
///         TabView {
///             ForEach(items, id: /\.self) {
///                 Text($0)
///             }
///         }
///         .tabViewStyle(PageTabViewStyle())
///         .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .never))
///     }
///
/// Currently the PageIndexViewStyle is the only type that allows for customization
/// over a page index view. To configure the current `IndexViewStyle` for a view hierarchy, use the
/// `.indexViewStyle()` modifier. When creating a new PageIndexViewStyle, it will
/// default to the .automatic backgroundDisplayMode if none is specified.
///
/// For example:
///
/// ![Index view style protocol example 1](indexviewstyle-protocol-example-1.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        TabView {
///            Text("Tab 1")
///            Text("Tab 2")
///            Text("Tab 3")
///        }
///        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
///        .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .always))
///    }
/// }
/// ```
@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct PageIndexViewStyle : IndexViewStyle {

    /// The background style for the page index view.
    ///
    /// There are 4 background style options:
    /// - automatic: uses the default background for the platform
    /// - interactive: shows a background when the index is interacted with
    /// - always: the background is always shown
    /// - never: the background is never shown
    ///
    /// See the individual style pages for visualizations of each option.
    public struct BackgroundDisplayMode {

        /// Background will use the default for the platform.
        ///
        /// For example:
        ///
        /// ![PageIndexViewStyle automatic background display mode](pageindexviewstyle-automatic-example.png)
        ///
        /// ```
        /// struct ExampleView: View {
        ///    var body: some View {
        ///        ZStack {
        ///            Color.blue
        ///                .ignoresSafeArea()
        ///
        ///            TabView {
        ///                Text("Tab 1")
        ///                Text("Tab 2")
        ///                Text("Tab 3")
        ///            }
        ///            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
        ///            .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .automatic))
        ///        }
        ///    }
        /// }
        /// ```
        ///
        /// Note that the ``ZStack`` was used to apply a background color to the screen so that
        /// the background styles on the page index view were more clear.
        public static let automatic: PageIndexViewStyle.BackgroundDisplayMode

        /// Background is only shown while the index view is interacted with.
        ///
        /// For example:
        ///
        /// ![PageIndexViewStyle interactive background display mode](pageindexviewstyle-automatic-example.png)
        ///
        /// ```
        /// struct ExampleView: View {
        ///    var body: some View {
        ///        ZStack {
        ///            Color.blue
        ///                .ignoresSafeArea()
        ///
        ///            TabView {
        ///                Text("Tab 1")
        ///                Text("Tab 2")
        ///                Text("Tab 3")
        ///            }
        ///            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
        ///            .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .interactive))
        ///        }
        ///    }
        /// }
        /// ```
        ///
        /// Note that the ``ZStack`` was used to apply a background color to the screen so that
        /// the background styles on the page index view were more clear.
        public static let interactive: PageIndexViewStyle.BackgroundDisplayMode

        /// Background is always displayed behind the page index view.
        ///
        /// For example:
        ///
        /// ![PageIndexViewStyle always background display mode](indexviewstyle-protocol-example-1.png)
        ///
        /// ```
        /// struct ExampleView: View {
        ///    var body: some View {
        ///        ZStack {
        ///            Color.blue
        ///                .ignoresSafeArea()
        ///
        ///            TabView {
        ///                Text("Tab 1")
        ///                Text("Tab 2")
        ///                Text("Tab 3")
        ///            }
        ///            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
        ///            .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .always))
        ///        }
        ///    }
        /// }
        /// ```
        ///
        /// Note that the ``ZStack`` was used to apply a background color to the screen so that
        /// the background styles on the page index view were more clear.
        public static let always: PageIndexViewStyle.BackgroundDisplayMode

        /// Background is never displayed behind the page index view.
        ///
        /// For example:
        ///
        /// ![PageIndexViewStyle never background display mode](pageindexviewstyle-automatic-example.png)
        ///
        /// ```
        /// struct ExampleView: View {
        ///    var body: some View {
        ///        ZStack {
        ///            Color.blue
        ///                .ignoresSafeArea()
        ///
        ///            TabView {
        ///                Text("Tab 1")
        ///                Text("Tab 2")
        ///                Text("Tab 3")
        ///            }
        ///            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
        ///            .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .never))
        ///        }
        ///    }
        /// }
        /// ```
        ///
        /// Note that the ``ZStack`` was used to apply a background color to the screen so that
        /// the background styles on the page index view were more clear.
        public static let never: PageIndexViewStyle.BackgroundDisplayMode
    }

    /// Creates a page index view style.
    ///
    /// When creating a new PageIndexViewStyle, it will default to the .automatic
    /// backgroundDisplayMode if none is specified. For example:
    ///
    /// ![Index view style protocol example 1](indexviewstyle-protocol-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        TabView {
    ///            Text("Tab 1")
    ///            Text("Tab 2")
    ///            Text("Tab 3")
    ///        }
    ///        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
    ///        .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .always))
    ///    }
    /// }
    /// ```
    ///
    /// - Parameter backgroundDisplayMode: The display mode of the background of any
    /// page index views receiving this style
    public init(backgroundDisplayMode: PageIndexViewStyle.BackgroundDisplayMode = .automatic) { }
}

/// A `TabViewStyle` that implements a paged scrolling `TabView`.
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         TabView {
///             Text("Bananas 🍌🍌")
///             Text("Apples 🍏🍏")
///             Text("Peaches 🍑🍑")
///         }
///         .foregroundColor(Color.white)
///         .background(Color.yellow)
///         .tabViewStyle(PageTabViewStyle())
///     }
/// }
/// ```
@available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
@available(macOS, unavailable)
public struct PageTabViewStyle : TabViewStyle {

    /// A style for displaying the page index view
    public struct IndexDisplayMode {

        /// Displays an index view when there are more than one page
        public static let automatic: PageTabViewStyle.IndexDisplayMode

        /// Always display an index view regardless of page count
        @available(watchOS, unavailable)
        public static let always: PageTabViewStyle.IndexDisplayMode

        /// Never display an index view
        @available(watchOS, unavailable)
        public static let never: PageTabViewStyle.IndexDisplayMode
    }

    /// Creates a new `PageTabViewStyle` with an index display mode
    public init(indexDisplayMode: PageTabViewStyle.IndexDisplayMode = .automatic) { }
}

/// The outline of a custom shape.
///
/// Use this structure to outline a custom shape.
///
/// ### Creating a path
///
/// There are 8 different ways to create a path:
/// 1. Empty path: ``Path/init()``
/// 2. Path from closure
/// 3. Path from `CGMutablePath`
/// 4. Path from `CGPath`
/// 5. Path from ``Rectangle``
/// 6. Path from `String`
/// 7. Path from ellipse:
/// ``Path/init(ellipseIn:)``
/// 8. Path from ``RoundedRectangle``:
/// ``Path/init(roundedRect:cornerSize:style:)`` or
/// ``Path/init(roundedRect:cornerRadius:style:)``
///
/// ### Modifying and mutating a path
///
/// Use mutating path methods in conjunction with the init-from-a-closure
/// path initializer to mutate the path before returning it. These methods
/// mutate and return the path.
///
/// Use non-mutating (modifying) path methods on already existing paths
/// similarly to view modifiers to update and return something new.
///
/// In the following example, `move(to:)` and `addLine(to:)` are
/// mutating methods, while `stroke()` is a non-mutating method.
///
/// ```
/// struct PathView: View {
///     var body: some View {
///         Path { path in
///             path.move(to: .zero)
///             path.addLine(to: CGPoint(x: 0, y: 100))
///         }
///         .stroke()
///     }
/// }
/// ```
///
/// ### Using a path
///
/// The primary way to use a path is in conjunction with the
/// ``Shape/path(in:)`` function. Create a custom path,
/// and return it to this function in order to create
/// a custom shape:
///
/// ```
/// struct CustomShapeView: View {
///     var body: some View {
///         CustomShape()
///             .stroke()
///     }
/// }
///
/// struct CustomShape: Shape {
///     func path(in rect: CGRect) -> Path {
///         return Path(rect)
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Path : Equatable, LosslessStringConvertible {

    /// Creates an empty path.
    ///
    /// Use this initializer to create an empty path which can be
    /// mutated later.
    ///
    /// In the following example, we start out by making an empty path,
    /// but then mutate it to the desired shape:
    ///
    /// ```
    /// struct CustomShapeView: View {
    ///     var body: some View {
    ///         CustomShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CustomShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         var path = Path()
    ///
    ///         path.move(to: .zero)
    ///         path.addLine(to: CGPoint(x: 0, y: 10))
    ///
    ///         return path
    ///     }
    /// }
    /// ```
    public init() { }

    /// Creates a path from a CGPath.
    ///
    /// Use this initializer when you have already constructed a
    /// `CGPath` and would like to turn it into a `Path`.
    ///
    /// `CGPath` objects are from the Core Graphics library. More
    /// info can be found [here](https://developer.apple.com/documentation/coregraphics/cgpath).
    ///
    /// ```
    /// struct CustomShapeView: View {
    ///     var body: some View {
    ///         CustomShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CustomShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         let cgPath = CGPath(rect: rect, transform: .none)
    ///         return Path(cgPath)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter path: A CGPath to define the path.
    public init(_ path: CGPath) { }

    /// Creates a path from a CGMutablePath.
    ///
    /// Use this initializer when you have already constructed a
    /// `CGMutablePath` andn would like to turn it into a `Path`.
    ///
    /// - Note: `CGMutablePath` objects can be mutated after they are
    /// initialized. `CGPath` objects cannot.
    ///
    /// `CGMutablePath` objects are from the CoreGraphics library. More
    /// info can be found [here](https://developer.apple.com/documentation/coregraphics/cgmutablepath).
    ///
    /// ```
    /// struct CustomShapeView: View {
    ///     var body: some View {
    ///         CustomShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CustomShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         let cgMutablePath = CGPath(rect: rect, transform: .none).mutableCopy()!
    ///
    ///         cgMutablePath.move(to: .zero)
    ///         cgMutablePath.addLine(to: CGPoint(x: 100, y: 100))
    ///
    ///         return Path(cgMutablePath)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter path: A CGMutablePath to define the path.
    public init(_ path: CGMutablePath) { }

    /// Creates a path from a CGRect.
    ///
    /// `CGRect` objects are from the Core Graphics library. More
    /// info can be found [here](https://developer.apple.com/documentation/coregraphics/cgrect).
    ///
    /// ```
    /// struct CustomShapeView: View {
    ///     var body: some View {
    ///         CustomShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CustomShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         return Path(rect)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter path: A CGRect to define the path.
    public init(_ rect: CGRect) { }

    /// Creates a path as a rounded rectangle from a CGRect and a corner size.
    ///
    /// See ``RoundedCornerStyle`` for more info on the different corner
    /// options of a rounded rectangle.
    ///
    /// ```
    /// struct CustomShapeView: View {
    ///     var body: some View {
    ///         CustomShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CustomShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         return Path(roundedRect: rect,
    ///                     cornerSize: CGSize(width: 5, height: 10),
    ///                     style: .continuous)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - rect: A CGRect to define the sides of the path.
    ///   - cornerSize: A CGSize to define the size of the path's corners.
    ///   - style: A RoundedCornerStyle to define the type of corners for the path.
    public init(roundedRect rect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle = .circular) { }

    /// Creates a path as a rounded rectangle from a CGRect and a corner radius.
    ///
    /// See ``RoundedCornerStyle`` for more info on the different corner
    /// options of a rounded rectangle.
    ///
    /// ```
    /// struct CustomShapeView: View {
    ///     var body: some View {
    ///         CustomShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CustomShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         return Path(roundedRect: rect,
    ///                     cornerSize: 10,
    ///                     style: .continuous)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - rect: A CGRect to define the sides of the path.
    ///   - cornerRadius: A CGFloat to define the radius of the path's corners.
    ///   - style: A RoundedCornerStyle to define the type of corners for the path.
    public init(roundedRect rect: CGRect, cornerRadius: CGFloat, style: RoundedCornerStyle = .circular) { }

    /// Creates a path as an ellipse defined by a given rectangle.
    ///
    /// ```
    /// struct CustomShapeView: View {
    ///     var body: some View {
    ///         CustomShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CustomShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         return Path(ellipseIn: rect)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter ellipseIn: The rectangle defining the outside of the ellipse.
    public init(ellipseIn rect: CGRect) { }

    /// Creates a path from a closure.
    ///
    /// - Note: You do not need to return the mutated path. It will be
    /// mutated automatically.
    ///
    /// ```
    /// struct PathFromClosureView: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(CGPoint(x: 100, y: 100))
    ///         }
    ///         .stroke()
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter callback: A closure that takes in an empty path which
    /// can be mutated.
    public init(_ callback: (inout Path) -> ()) { }

    /// Creates a path from a string.
    ///
    /// Use this initializer to creat a path from the result of a previous call to
    /// `Path.stringRepresentation`. Fails if the `string` does not
    /// describe a valid path.
    ///
    /// ```
    /// struct PathFromStringView: View {
    ///     var pathString: String {
    ///         return Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(to: CGPoint(x: 100, y: 100))
    ///         }
    ///         .description
    ///     }
    ///
    ///     var body: some View {
    ///         Path(pathString)!
    ///             .stroke()
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter string: The string description of the path, obtained from `description`.
    public init?(_ string: String) { }

    /// A property that holds a string description of the path.
    ///
    /// Use this property to recreate the path via the
    /// ``Path/init?(_:)`` initializer.
    ///
    /// ```
    /// struct PathFromStringView: View {
    ///     var pathString: String {
    ///         let p = Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(to: CGPoint(x: 100, y: 100))
    ///         }
    ///         .description
    ///
    ///         print(p) //"0 0 m 100 100 l"
    ///
    ///         return p
    ///     }
    ///
    ///     var body: some View {
    ///         Path(pathString)!
    ///             .stroke()
    ///     }
    /// }
    /// ```
    public var description: String { get }

    /// A property that holds the path as a Core Graphics Path (CGPath).
    ///
    /// ```
    /// struct PathFromCGPathView: View {
    ///     var cgPath: CGPath {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(to: CGPoint(x: 100, y: 100))
    ///         }
    ///         .cgPath
    ///     }
    ///     var body: some View {
    ///         Path(cgPath)
    ///             .stroke()
    ///     }
    /// }
    /// ```
    public var cgPath: CGPath { get }

    /// A Boolean property that cointains whether the path is empty.
    ///
    /// ```
    /// struct EmptyPathView: View {
    ///     let path = Path()
    ///
    ///     var body: some View {
    ///         path
    ///             .stroke()
    ///             .onAppear { print(path.isEmpty) } //true
    ///     }
    /// }
    /// ```
    public var isEmpty: Bool { get }

    /// A property that contains the outter bounding rectangle of the path.
    ///
    /// ```
    /// struct OddShapeView: View {
    ///     var body: some View {
    ///         BoxedOval()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct BoxedOval: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addEllipse(in: rect)
    ///             path.addRect(path.boundingRect)
    ///      }
    /// }
    /// ```
    public var boundingRect: CGRect { get }

    /// Returns true if the path contains a specified point.
    ///
    /// If `eoFill` is true, this method uses the even-odd rule to define which
    /// points are inside the path. Otherwise, it uses the non-zero rule.
    ///
    /// ```
    /// struct LineView: View {
    ///     var body: some View {
    ///         let line = Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(to: CGPoint(x: 100, y: 100))
    ///         }
    ///
    ///         print(line.cointains(CGPoint(x: 50, y: 50))) //true
    ///
    ///         return line.stroke()
    ///     }
    /// }
    /// ```
    public func contains(_ p: CGPoint, eoFill: Bool = false) -> Bool { }

    /// An element of a path.
    ///
    /// These elements are passed in as parameters in the function parameter of
    /// ``Path/forEach(_:)``. Other than that, these elements are not really
    /// used.
    ///
    /// A path is made up of elements defined in this enumeration.
    ///
    /// The following example shows a function that loops through
    /// the elements in a path:
    ///
    /// ```
    /// struct OvalView: View {
    ///     var body: some View {
    ///         LoudPrintingOval() // Loud and printing 📢
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct LoudPrintingOval: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         let ovalPath = Path(ellipseIn: rect)
    ///         ovalPath.forEach { element in
    ///             switch element {
    ///             case .move(let point):
    ///                 print("I moved to \(point).")
    ///             case .line(let point):
    ///                 print("I drew a line to \(point.)")
    ///             case .quadCurve(let point, let control):
    ///                 print("I drew a quad curve to \(point).")
    ///             case .curve(let point, let control1, let control2):
    ///                 print("I drew a curve to \(point).")
    ///             case .closeSubpath:
    ///                 print("I am finished being loud.")
    ///             }
    ///         }
    ///         return ovalPath
    ///     }
    /// }
    /// ```
    @frozen public enum Element : Equatable {

        /// A path element that terminates the current subpath (without closing
        /// it) and defines a new current point.
        ///
        /// To add this enumeration case to your path, use the
        /// ``Path/move(to:)`` mutating function:
        ///
        /// ```
        /// struct OneHundredPointLine: View {
        ///     var body: some View {
        ///         Path { path in
        ///             path.move(to: .zero)
        ///             path.addLine(to: CGPoint(x: 100, y: 0))
        ///         }
        ///         .stroke()
        ///     }
        /// }
        /// ```
        case move(to: CGPoint)

        /// A line from the previous current point to the given point, which
        /// becomes the new current point.
        ///
        /// To add this enumeration case to your path, use the
        /// ``Path.addLine(to:)`` mutating function:
        ///
        /// ```
        /// struct OneHundredPointLine: View {
        ///     var body: some View {
        ///         Path { path in
        ///             path.move(to: .zero)
        ///             path.addLine(to: CGPoint(x: 100, y: 0))
        ///         }
        ///         .stroke()
        ///     }
        /// }
        /// ```
        case line(to: CGPoint)

        /// A quadratic Bézier curve from the previous current point to the
        /// given end-point, using the single control point to define the curve.
        ///
        /// The end-point of the curve becomes the new current point.
        ///
        /// To add this enumeration case to your path, use the
        /// ``Path.addQuadCurve(to:control:)`` mutating function:
        ///
        /// ```
        /// struct CurvedLineView: View {
        ///     var body: some View {
        ///         Path { path in
        ///             path.move(to: .zero)
        ///             path.addQuadCurve(to: CGPoint(x: 100, y: 100),
        ///                               control: CGPoint(x: x: 200, y: 0))
        ///         }
        ///         .stroke()
        ///     }
        /// }
        /// ```
        case quadCurve(to: CGPoint, control: CGPoint)

        /// A cubic Bézier curve from the previous current point to the given
        /// end-point, using the two control points to define the curve.
        ///
        /// The end-point of the curve becomes the new current point.
        ///
        /// To add this enumeration case to your path, use the
        /// ``Path.addCurve(to:control1:control2:)`` mutating function:
        ///
        /// ```
        /// struct FunkySView: View {
        ///     var body: some View {
        ///         Path { path in
        ///             path.move(to: .zero)
        ///             path.addCurve(to: CGPoint(x: 100, y: 100),
        ///                           control1: CGPoint(x: 100, y: 0),
        ///                           control2: CGPoint(x: 0, y: 100))
        ///         }
        ///         .stroke()
        ///     }
        /// }
        /// ```
        case curve(to: CGPoint, control1: CGPoint, control2: CGPoint)

        /// A line from the start point of the current subpath (if any) to the
        /// current point, which terminates the subpath.
        ///
        /// After closing the subpath, the current point becomes undefined.
        ///
        /// To add this enumeration case to your path, use the
        /// ``Path.closeSubpath()`` mutating function:
        ///
        /// ```
        /// struct LazyTriangleView: View {
        ///     var body: some View {
        ///         Path { path in
        ///             path.move(to: .zero)
        ///             path.addLine(to: CGPoint(x: 100, y: 0))
        ///             path.addLine(to: CGPoint(x: 100, y: 100))
        ///             // Getting lazy 😴
        ///             path.closeSubpath()
        ///         }
        ///         .stroke()
        ///     }
        /// }
        /// ```
        case closeSubpath

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Path.Element, b: Path.Element) -> Bool { }
    }

    /// Calls a function for every element in the path.
    ///
    /// Use this function to loop over every element in a path.
    ///
    /// A path is made up of elements defined in
    /// ``Path.Element``.
    ///
    /// ```
    /// struct OvalView: View {
    ///     var body: some View {
    ///         LoudPrintingOval() // Loud and printing 📢
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct LoudPrintingOval: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         let ovalPath = Path(ellipseIn: rect)
    ///         ovalPath.forEach { element in
    ///             switch element {
    ///             case .move(let point):
    ///                 print("I moved to \(point).")
    ///             case .line(let point):
    ///                 print("I drew a line to \(point.)")
    ///             case .quadCurve(let point, let control):
    ///                 print("I drew a quad curve to \(point).")
    ///             case .curve(let point, let control1, let control2):
    ///                 print("I drew a curve to \(point).")
    ///             case .closeSubpath:
    ///                 print("I am finished being loud.")
    ///             }
    ///         }
    ///         return ovalPath
    ///     }
    /// }
    /// ```
    public func forEach(_ body: (Path.Element) -> Void) { }

    /// Sets the style for a path's stroke.
    ///
    /// Use this method to set a path's strole style. When the path
    /// is eventually stroked, it will have the declared style.
    ///
    /// See ``StrokeStyle`` for info on how to create a style.
    ///
    /// ```
    /// struct PaperCutoutView: View {
    ///     var body: some View {
    ///         CutHereLines()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct CutHereLines: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         let style = StrokeStyle(lineWidth: 3.0,
    ///                                 lineCap: .butt,
    ///                                 lineJoin: .bevel,
    ///                                 miterLimit: 3.0,
    ///                                 dash: [9.0, 9.0, 0.0, 9.0, 9.0, 9.0],
    ///                                 dashPhase: 0.0)
    ///         return Path(rect)
    ///             .strokedPath(style)
    ///     }
    /// }
    /// ```
    public func strokedPath(_ style: StrokeStyle) -> Path { }

    /// Trims a path along a given 0 to 1 percentage range.
    ///
    /// The returned path contains the region between `from` and `to`, both of
    /// which must be fractions between zero and one defining points
    /// linearly-interpolated along the path.
    ///
    /// ```
    /// struct TrimmedPathView: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addQuadCurve(to: CGPoint(x: 100, y: 100),
    ///                               control: CGPoint(x: x: 200, y: 0))
    ///         }
    ///         .trimmedPath(from: 0.25, to: 0.75)
    ///         .stroke()
    ///     }
    /// }
    /// ```
    public func trimmedPath(from: CGFloat, to: CGFloat) -> Path { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Path, b: Path) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Path : Shape {

    /// Describes the path as a path within a rectangular frame of reference.
    ///
    /// This method is rarely used directly. For path, it just returns the
    /// same path.
    ///
    /// This method makes ``Path`` a ``Shape`` itself!
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    public func path(in _: CGRect) -> Path { }

    /// The type defining the data to animate.
    public typealias AnimatableData = EmptyAnimatableData

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Path {

    /// Begins a new subpath at the specified point.
    ///
    /// ```
    /// struct OneHundredPointLine: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(to: CGPoint(x: 100, y: 0))
    ///         }
    ///         .stroke()
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter p: The point to move the path to.
    public mutating func move(to p: CGPoint) { }

    /// Appends a straight line segment from the current point to the specified
    /// point.
    ///
    /// ```
    /// struct OneHundredPointLine: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(to: CGPoint(x: 100, y: 0))
    ///         }
    ///         .stroke()
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter p: The point to draw a line to.
    public mutating func addLine(to p: CGPoint) { }

    /// Adds a quadratic Bézier curve to the path, with the specified end point
    /// and control point.
    ///
    /// ```
    /// struct CurvedLineView: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addQuadCurve(to: CGPoint(x: 100, y: 100),
    ///                               control: CGPoint(x: x: 200, y: 0))
    ///         }
    ///         .stroke()
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - p: The point to end the quad curve at.
    ///   - cp: The control point to use for drawing the quad curve.
    public mutating func addQuadCurve(to p: CGPoint, control cp: CGPoint) { }

    /// Adds a cubic Bézier curve to the path, with the specified end point and
    /// control points.
    ///
    /// ```
    /// struct FunkySView: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addCurve(to: CGPoint(x: 100, y: 100),
    ///                           control1: CGPoint(x: 100, y: 0),
    ///                           control2: CGPoint(x: 0, y: 100))
    ///         }
    ///         .stroke()
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - p: The point to end the curve at.
    ///   - cp1: The first control point to use for drawing the curve.
    ///   - cp2: The second control point to use for drawing the curve.
    public mutating func addCurve(to p: CGPoint, control1 cp1: CGPoint, control2 cp2: CGPoint) { }

    /// Closes and completes the current subpath.
    ///
    /// ```
    /// struct LazyTriangleView: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addLine(to: CGPoint(x: 100, y: 0))
    ///             path.addLine(to: CGPoint(x: 100, y: 100))
    ///             // Getting lazy 😴
    ///             path.closeSubpath()
    ///         }
    ///         .stroke()
    ///     }
    /// }
    /// ```
    public mutating func closeSubpath() { }

    /// Adds a rectangular subpath to the path.
    ///
    /// Use this method to add a rectangular subpath to an existing path.
    /// See `CGRect` for info on how to make a rectangle.
    /// See `CGAffineTransform` for info on how to make an affine transform.
    ///
    /// ```
    /// struct RectangularPathView: View {
    ///     var body: some View {
    ///         RectangularShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct RectangularShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addRect(rect, transform: .init(scaleX: 0.5, scaleY: 0.25))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - rect: The rectangle to use for adding the rectangular path.
    ///   - transform: The CGAffineTransform to apply to the rectangular path.
    public mutating func addRect(_ rect: CGRect, transform: CGAffineTransform = .identity) { }

    /// Adds a rounded rectangle to the path.
    ///
    /// Use this method to add a rounded rectangular subpath to an existing
    /// path. See `CGRect` for info on how to make an rectangle.
    /// See `CGSize` for info on how to create a corner size.
    /// See `RoundedCornerStyle` for info on the available corner
    /// styles.
    /// See `CGAffineTransform` for info on how to make an affine
    /// transform.
    ///
    /// ```
    /// struct RoundedRectangularPathView: View {
    ///     var body: some View {
    ///         RoundedRectangularShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct RoundedRectangularShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addRect(in: rect,
    ///                          cornerSize: .init(width: 10, height: 10),
    ///                          style: .continuous,
    ///                          transform: .init(scaleX: 0.5, scaleY: 0.25))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - rect: The rectangular bounds for the rounded rectangle subpath.
    ///   - cornerSize: The CGSize for the rounded corners.
    ///   - style: The rounded corner style.
    ///   - transform: The affine transform to apply to the rounded
    ///   rectangle subpath.
    public mutating func addRoundedRect(in rect: CGRect, cornerSize: CGSize, style: RoundedCornerStyle = .circular, transform: CGAffineTransform = .identity) { }

    /// Adds an ellipse to the path.
    ///
    /// Use this method to add an oval subpath to an existing path.
    /// See `CGRect` for info on how to make a rectangle.
    /// See `CGAffineTransform` for info on how to make an affine transform.
    ///
    /// ```
    /// struct OvalPathView: View {
    ///     var body: some View {
    ///         OvalShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct OvalShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addRect(in: rect, transform: .init(scaleX: 0.5, scaleY: 0.25))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - rect: The bounding rectangle for the oval subpath.
    ///   - transform: The transform to apply to the oval subpath.
    public mutating func addEllipse(in rect: CGRect, transform: CGAffineTransform = .identity) { }

    /// Adds a sequence of rectangular subpaths to the path.
    ///
    /// Use this method to add an oval subpath to an existing path.
    /// See `CGRect` for info on how to make a rectangle.
    /// See `CGAffineTransform` for info on how to make an affine transform.
    ///
    /// ```
    /// struct RectanglesPathView: View {
    ///     var body: some View {
    ///         RectanglesShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct RectanglesShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         let rects = [
    ///             rect,
    ///             rect.insetBy(dx: 30, dy: 10)
    ///         ]
    ///         return Path { path in
    ///             path.addRects(rects, transform: .init(scaleX: 0.5, scaleY: 0.25))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - rects: The rectangles for the rectangular subpaths.
    ///   - transform: The transform to apply to the rectangular subpaths.
    public mutating func addRects(_ rects: [CGRect], transform: CGAffineTransform = .identity) { }

    /// Adds a sequence of connected straight-line segments to the path.
    ///
    /// Use this method to add connected lines to a path by specifying
    /// their connecting points. See `CGPoint`
    /// for info on how to create a point.
    ///
    /// ```
    /// struct LinesPathView: View {
    ///     var body: some View {
    ///         LinesShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct LinesShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         let points = [
    ///             CGPoint(x: 0, y: 0),
    ///             CGPoint(x: 20, y: 200),
    ///             CGPoint(x: 100, y: 30)
    ///         ]
    ///         return Path { path in
    ///             path.addLines(points, transform: .init(scaleX: 2, scaleY: 0.8))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter lines: The ordered points specifying the connecting places
    /// for the new subpath to be added.
    public mutating func addLines(_ lines: [CGPoint]) { }

    /// Adds an arc of a circle to the path, specified with a radius and a
    /// difference in angle.
    ///
    /// Use this method to add a relative arc to an existing path.
    /// See `CGPoint` for how to create a relative center point.
    /// See `Angle` for info on how to create an angle.
    /// See `CGAffineTransform` for info on how to create a transform.
    ///
    /// ```
    /// struct RelativeArcPathView: View {
    ///     var body: some View {
    ///         RelativeArcShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct RelativeArcShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addRelativeArc(center: .init(x: 200, y: 200),
    ///                                 radius: 100,
    ///                                 startAngle: .degrees(180),
    ///                                 endAngle: .degrees(90),
    ///                                 transform: .init(scaleX: 0.5, scaleY: 0.25))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - center: The center point of the relative arc.
    ///   - radius: The radius of the relative arc.
    ///   - startAngle: The starting angle of the relative arc, measured
    ///   clockwise from the 3 o'clock position.
    ///   - delta: The angle to draw the relative arc, beginning with the
    ///   start angle and sweeping clockwise.
    ///   - trasnform: The affine transform to apply to the arc.
    public mutating func addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: Angle, delta: Angle, transform: CGAffineTransform = .identity) { }

    /// Adds an arc of a circle to the path, specified with a radius and angles.
    ///
    /// Use this method to add an arc by specifying a start angle and an
    /// end angle.
    ///
    /// To instead add an arc subpath via a relative angle to a starting point,
    /// use ``Path/addRelativeArc(center:radius:startAngle:delta:transform:)``.
    ///
    /// ```
    /// struct ArcPathView: View {
    ///     var body: some View {
    ///         ArcShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct ArcShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addArc(center: .init(x: 200, y: 200),
    ///                         radius: 100,
    ///                         startAngle: .degrees(180),
    ///                         endAngle: .degrees(90),
    ///                         clockwise: true,
    ///                         transform: .init(scaleX: 0.5, scaleY: 0.25))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - center: The center point of the relative arc.
    ///   - radius: The radius of the relative arc.
    ///   - startAngle: The starting angle of the arc, measured
    ///   clockwise from the 3 o'clock position.
    ///   - endAngle: The ending angle of the arc, measured clockwise
    ///   from the 3 o'clock position.
    ///   clockwise: Whether to draw the arc clockwise (false means counter-clockwise).
    ///   transform: The affine transform to apply to the arc.
    public mutating func addArc(center: CGPoint, radius: CGFloat, startAngle: Angle, endAngle: Angle, clockwise: Bool, transform: CGAffineTransform = .identity) { }

    /// Adds an arc of a circle to the path, specified with a radius and two
    /// tangent lines.
    ///
    /// Use this method to add an arc subpath to the path by specifying
    /// a radius along with the two tangent lines.
    ///
    /// ```
    /// struct ArcPathView: View {
    ///     var body: some View {
    ///         ArcShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct ArcShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.move(to: .zero)
    ///             path.addArc(tangent1End: .init(x: 100, y: 150),
    ///                         tangent2End: .init(x: 300, y: 50),
    ///                         radius: 100,
    ///                         transform: .init(scaleX: 0.9, scaleY: 1.1))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - p1: The first point that defines the tangent line of the arc.
    ///   - p2: The second point that defines the tangent line of the arc.
    ///   - radius: The radius of the arc.
    ///   - transform: The affine transform to apply to the subpath.
    public mutating func addArc(tangent1End p1: CGPoint, tangent2End p2: CGPoint, radius: CGFloat, transform: CGAffineTransform = .identity) { }

    /// Appends a copy of the given path to this path.
    ///
    /// Use this method if your subpath has already been created, and
    /// you would like to append it to this path.
    ///
    /// ```
    /// struct LongWindedRectangleView: View {
    ///     var body: some View {
    ///         LongWindedRectangle()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct LongWindedRectangle: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addPath(Path(rect))
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - path: The path to add as a subpath to this path.
    ///   - transform: The affine transform to apply to the subpath.
    public mutating func addPath(_ path: Path, transform: CGAffineTransform = .identity) { }

    /// Returns the last point in the path, or nil if the path contains
    /// no points.
    ///
    /// ```
    /// struct ShapeView: View {
    ///     var body: some View {
    ///         AnotherShape()
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct AnotherShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path { path in
    ///             path.addArc(center: .zero, radius: 100,
    ///                         startAngle: .zero, endAngle: .degrees(60), clockwise: false)
    ///             path.addArc(center: path.currentPoint!, radius: 100,
    ///                         startAngle: .zero, endAngle: .degrees(60), clockwise: false)
    ///             path.addArc(center: path.currentPoint!, radius: 100,
    ///                         startAngle: .zero, endAngle: .degrees(60), clockwise: false)
    ///         }
    ///     }
    /// }
    /// ```
    public var currentPoint: CGPoint? { get }

    /// Returns a path constructed by applying the transform to all points of
    /// the path.
    ///
    /// ```
    /// struct SlightlyDistortedShapeView: View {
    ///     var body: some View {
    ///         NormalShape()
    ///             .applying(.init(scaleX: 0.9, scaleY: 1.1))
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct NormalShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path(rect)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter transform: The affine transform to apply to this path.
    public func applying(_ transform: CGAffineTransform) -> Path { }

    /// Returns a path constructed by translating `self` by `(dx, dy)`.
    ///
    /// ```
    /// struct SlightlyOffsetShapeView: View {
    ///     var body: some View {
    ///         NormalShape()
    ///             .offsetBy(dx: 10, dy: 10)
    ///             .stroke()
    ///     }
    /// }
    ///
    /// struct NormalShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         Path(ellipseIn: rect)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - dx: The number of points of horizontal offset to the right.
    ///   - dy: The number of points of vertical offset down.
    public func offsetBy(dx: CGFloat, dy: CGFloat) -> Path { }
}

/// A control that lets you select an item.
///
/// You create a picker by providing 3 things:
/// 1. a selection binding
/// 2. a label
/// 3. content for the picker to display.
///
/// Set the `selection` parameter to a "current selection" binding.
///
/// Set the label to a view that describes the purpose of selecting content
/// in the picker.
///
/// The content is what the picker displays.
///
/// For example, consider the following enumeration of ice cream flavors:
///
///     enum Flavor: String, CaseIterable, Identifiable {
///         case chocolate
///         case vanilla
///         case strawberry
///
///         var id: String { self.rawValue }
///     }
///
/// You can create a picker to select among these values by providing `Text`
/// views in the picker initializer's content:
///
/// ![Picker Ice Cream](/picker-ice-cream.png)
///
/// ```
/// struct IceCreamView: View {
///     @State private var selectedFlavor = Flavor.chocolate
///
///     var body: some View {
///         Picker("Flavor", selection: $selectedFlavor) {
///             Text("Chocolate 🍫").tag(Flavor.chocolate)
///             Text("Vanilla 🍦").tag(Flavor.vanilla)
///             Text("Strawberry 🍓").tag(Flavor.strawberry)
///         }
///         Text("Selected flavor: \(selectedFlavor.rawValue)")
///     }
/// }
/// ```
///
/// You append a tag to each text view so that the type of each selection
/// matches the type of the bound state variable.
///
/// ### Iterating Over a Picker’s Options
///
/// To provide selection values for the `Picker` without explicitly listing
/// each option, you can create the picker with a `ForEach` construct, like
/// this:
///
/// ```
/// struct IceCreamView: View {
///     @State private var selectedFlavor = Flavor.chocolate
///
///     var body: some View {
///         Picker("Flavor", selection: $selectedFlavor) {
///             ForEach(Flavor.allCases) { flavor in
///                 Text(flavor.rawValue.capitalized)
///             }
///         }
///     }
/// }
/// ```
///
/// In this case, `ForEach` automatically assigns a tag to the selection
/// views, using each option's `id`, which it can do because `Flavor` conforms
/// to the [Identifiable](https://developer.apple.com/documentation/swift/identifiable)
/// protocol.
///
/// However, if the selection type doesn't match the input to the
/// `ForEach`, you need to provide an explicit tag. The following example
/// shows a picker that has a binding to a `Topping` type, even though the options
/// are all `Flavor` instances. Each option uses `View/tag(_:)` to associate
/// a topping with the flavor it displays.
///
/// ![Picker Toppings](/picker-toppings.png)
///
/// ```
/// enum Flavor: String, CaseIterable, Identifiable {
///     case chocolate
///     case vanilla
///     case strawberry
///
///     var id: String { self.rawValue }
///     var suggestedTopping: Topping {
///         switch self {
///         case .chocolate:
///             return .nuts
///         case .vanilla:
///             return .cookies
///         case .strawberry:
///             return .blueberries
///         }
///     }
/// }
/// enum Topping: String, CaseIterable, Identifiable {
///     case nuts
///     case cookies
///     case blueberries
///
///     var id: String { self.rawValue }
/// }
///
/// struct ContentView: View {
///     @State private var suggestedTopping: Topping = .cookies
///     var body: some View {
///         Picker("Suggest a topping for:", selection: $suggestedTopping) {
///             ForEach(Flavor.allCases) { flavor in
///                 Text(flavor.rawValue.capitalized)
///                     .tag(flavor.suggestedTopping)
///             }
///         }
///         Text("suggestedTopping: \(suggestedTopping.rawValue)")
///     }
/// }
/// ```
///
/// ### Styling Pickers
///
/// You can customize the appearance and interaction of pickers by creating
/// styles that conform to the `PickerStyle` protocol. You create your own style
/// or use one of the styles provided by SwiftUI, like `SegmentedPickerStyle`
/// or `PopUpButtonPickerStyle`.
///
/// To set a specific style for all picker instances within a view, use the
/// `View/pickerStyle(_:)` modifier.
///
/// ![Picker Segmented with Ice Cream](picker-segmented-ice-cream.png)
///
/// ```
/// struct ContentView: View {
///     @State private var selectedFlavor = Flavor.chocolate
///     var body: some View {
///         Picker("Flavor", selection: $selectedFlavor) {
///             Text("chocolate").tag(Flavor.chocolate)
///             Text("vanilla").tag(Flavor.vanilla)
///         }
///         .pickerStyle(SegmentedPickerStyle())
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Picker<Label, SelectionValue, Content> : View where Label : View, SelectionValue : Hashable, Content : View {

    /// Creates a picker with a custom label.
    ///
    /// ```
    /// struct PickerView: View {
    ///     @State private var selection: Int = 0
    ///
    ///     var body: some View {
    ///         Picker(selection: $selection, label: Label("Pick emoji", systemImage: "face.smiling") {
    ///             Text("🍑").tag(1)
    ///             Text("🗿").tag(2)
    ///             Text("🍌").tag(3)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - selection: A binding to the currently selected option.
    ///     - label: A view used for the picker's label.
    ///     - content: A closure that returns the picker's options.
    public init(selection: Binding<SelectionValue>, label: Label, @ViewBuilder content: () -> Content) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Picker where Label == Text {

    /// Creates a picker with a localized string key label.
    ///
    /// ```
    /// struct PickerView: View {
    ///     @State private var selection: Int = 0
    ///
    ///     var body: some View {
    ///         Picker(LocalizedStringKey("Pick emoji"), selection: $selection) {
    ///             Text("🍑").tag(1)
    ///             Text("🗿").tag(2)
    ///             Text("🍌").tag(3)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - titleKey: A localized string key used for the picker's label.
    ///     - selection: A binding to the currently selected option.
    ///     - content: A closure that returns the picker's options.
    public init(_ titleKey: LocalizedStringKey, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content) { }

    /// Creates a picker with a string label.
    ///
    /// ```
    /// struct PickerView: View {
    ///     @State private var selection: Int = 0
    ///
    ///     var body: some View {
    ///         Picker("Pick emoji 🤑", selection: $selection) {
    ///             Text("🍑").tag(1)
    ///             Text("🗿").tag(2)
    ///             Text("🍌").tag(3)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - title: A string used for the pikcer's label.
    ///     - selection: A binding to the currently selected option.
    ///     - content: A closure that returns the picker's options.
    public init<S>(_ title: S, selection: Binding<SelectionValue>, @ViewBuilder content: () -> Content) where S : StringProtocol { }
}

/// Specifies the appearance and interaction of all pickers within a view hierarchy.
///
/// `PickerStyle` does not have a public interface - and therefore your app is limited to their default styles.
///
/// There are 7 different styles:
/// * `DefaultPickerStyle`
/// * `InlinePickerStyle`
/// * `MenuPickerStyle`
/// * `PopUpButtonPickerStyle` (not availible on iOS)
/// * `RadioGroupPickerStyle` (not availible on iOS)
/// * `SegmentedPickerStyle`
/// * `WheelPickerStyle`
///
/// ### `DefaultPickerStyle`
/// [[pickerstyle-default]]
///
/// ### `InlinePickerStyle`
/// [[pickerstyle-inline]]
///
/// ### `MenuPickerStyle`
/// [[pickerstyle-menu]]
///
/// ### `SegmentedPickerStyle`
/// [[pickerstyle-segmented]]
///
/// ### `WheelPickerStyle`
/// [[pickerstyle-wheel]]
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol PickerStyle{ }
extension PickerStyle {
}

/// A set of view types that may be pinned to the bounds of a scroll view.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct PinnedScrollableViews : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: UInt32

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: UInt32) { }

    /// The header view of each `Section` will be pinned.
    public static let sectionHeaders: PinnedScrollableViews

    /// The footer view of each `Section` will be pinned.
    public static let sectionFooters: PinnedScrollableViews

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = PinnedScrollableViews

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = PinnedScrollableViews

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = UInt32
}

/// A button effect that only modifies the label on interaction.
///
/// > A button style that doesn't style or decorate its content while idle, but may apply a visual effect to indicate the pressed, focused, or enabled state of the button.
///
/// ![DefaultButtonStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/buttonstyle-plain-border-default-example-1.png)
///
///
///     struct ExampleView: View {
///         var body: some View {
///              VStack {
///                  Button("Plain Banana🍌🍌") { tap() }
///                       .buttonStyle(PlainButtonStyle())
///                  Button("Borderless Banana 🍌🍌") { tap() }
///                       .buttonStyle(BorderlessButtonStyle())
///                  Button("Default Banana🍌🍌") { tap() }
///                       .buttonStyle(PlainButtonStyle())
///              }
///              .font(.title2)
///          }
///
///          func tap() {}
///      }
///
///
/// > To apply this style to a button, or to a view that contains buttons, use the `View/buttonStyle(_:)-66fbx` modifier.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PlainButtonStyle : PrimitiveButtonStyle {

    /// Creates a plain button style.
    public init() { }

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each `Button` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// - Parameter configuration : The properties of the button.
    public func makeBody(configuration: PlainButtonStyle.Configuration) -> some View { }


    /// A view that represents the body of a button.
    public typealias Body = some View
}

/// The instance that describes the behavior and appearance of a plain list.
///
/// ![PlainListStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/liststyle-plain-example-1.png)
///
///
///      struct ExampleView: View {
///          var body: some View {
///             List {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍎🍎")
///                 Text("Peaches 🍑🍑")
///             }
///             .listStyle(PlainListStyle())
///          }
///      }
///
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PlainListStyle : ListStyle {

    /// Creates a plain list style.
    public init() { }
}

/// A text field style with no decoration.
///
/// ![TextField Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TextField-example-1.gif)
///
///
///     struct ExampleView: View {
///         @State var myFruit: String = ""
///
///         var body: some View {
///             Text(myFruit)
///             TextField("Fruit", text: $myFruit)
///                 .textFieldStyle(PlainTextFieldStyle())
///                 .padding()
///         }
///     }
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PlainTextFieldStyle : TextFieldStyle {

	/// Creates a plain text field style.
    ///
    /// ![TextField Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TextField-example-1.gif)
    ///
    ///     struct ExampleView: View {
    ///         @State var myFruit: String = ""
    ///
    ///         var body: some View {
    ///             Text(myFruit)
    ///             TextField("Fruit", text: $myFruit)
    ///                 .textFieldStyle(PlainTextFieldStyle())
    ///                 .padding()
    ///         }
    ///     }
    public init() { }
}

/// An attachment anchor for a popover.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum PopoverAttachmentAnchor {

	/// A rectangular anchor point for the popover attachment.
    case rect(Anchor<CGRect>.Source)

    /// A unit point anchor for the popover attachment.
    case point(UnitPoint)
}

/// The ``PreferenceKey`` protocol enables a way to send data _up_ the view hierarchy.
///
/// ``PreferenceKey`` allows for a child view to communicate with a parent, similar to how an
/// ``Environment`` allows for data to be sent down the view hierarchy. An excellent
/// example of view preferences in action is Apple's ``NavigationView`` and ``View/navigationTitle(_:)``.
/// The ``View/navigationTitle(_:)`` does not modify the navigation view directly, but rather it
/// uses view preferences and the navigation view has a closure that is called when the title is updated.
///
/// While it is possible to achieve basic communication up the view hierarchy using a ``@Binding``,
/// this can produce unintended effects as a result of modifying state during a view update. In
/// these scenarios, it may be better to use view preferences.
///
/// For example, to set a preference key from a view and use it to change a state:
///
/// ```
/// struct ExampleView: View {
///    @State private var customPreferenceKey: String = ""
///
///    var body: some View {
///        VStack {
///            Text("View that sets a preference key when loaded")
///                .preference(key: CustomPreferenceKey.self, value: "New value! 🤓")
///        }
///        .onPreferenceChange(CustomPreferenceKey.self) { (value: CustomPreferenceKey.Value) in
///            customPreferenceKey = value
///            print(customPreferenceKey) // Prints: "New value! 🤓"
///        }
///    }
/// }
///
/// struct CustomPreferenceKey: PreferenceKey {
///    static var defaultValue: String = ""
///
///    static func reduce(value: inout String, nextValue: () -> String) {
///        value = nextValue()
///    }
/// }
/// ```
///
/// It is also possible to use more complicated data structures as a preference key
/// by changing the type of the defaultValue. For example:
///
/// ```
/// struct ExampleView: View {
///    @State private var customPreferenceKey: CustomPreferenceKeyData? = nil
///
///    var body: some View {
///        VStack {
///            Text("View that sets a preference key when loaded")
///                .preference(key: CustomPreferenceKey.self, value: CustomPreferenceKeyData(bananaBunch: "🍌🍌🍌", numberOfBananas: 3))
///        }
///        .onPreferenceChange(CustomPreferenceKey.self) { (value: CustomPreferenceKey.Value) in
///            customPreferenceKey = value
///            print(customPreferenceKey!) // Prints: "CustomPreferenceKeyData(bananaBunch: "🍌🍌🍌", numberOfBananas: 3)"
///        }
///    }
/// }
///
/// struct CustomPreferenceKey: PreferenceKey {
///    static var defaultValue: CustomPreferenceKeyData? = nil
///
///    static func reduce(value: inout CustomPreferenceKeyData?, nextValue: () -> CustomPreferenceKeyData?) {
///        value = nextValue()
///    }
/// }
///
/// struct CustomPreferenceKeyData: Equatable {
///    let bananaBunch: String
///    let numberOfBananas: Int
/// }
/// ```
///
/// For a detailed explanation of how view preferences work, check out this article:
/// [https://medium.com/@crystalminds/introducing-view-preferences-in-swiftui-e193c346b68d](https://medium.com/@crystalminds/introducing-view-preferences-in-swiftui-e193c346b68d)
///
/// Note:
///  - A view with multiple children automatically combines its values for a given
///  preference into a single value visible to its ancestors. This functionality
/// can be changed with the ``PreferenceKey/reduce(_:_:)`` function.
///  - When using view preferences, keep in mind that it can be easy to create
///  an infinite loop by having the preference value dependent on the state that it is changing.
///  A few signs this may be happening is a spike in CPU usage, a flickering screen, or a crashing app.
///  - In order to pass information _down_ the View hierarchy, see ``Environment``.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol PreferenceKey{ }
extension PreferenceKey {

    /// The type of value produced by this preference.
    associatedtype Value

    /// The default value of the preference if none is explicitly set.
    ///
    /// Views that have no explicit value for the key produce this default
    /// value. Combining child views may remove an implicit value produced by
    /// using the default. This means that `reduce(value: &x, nextValue:
    /// {defaultValue})` shouldn't change the meaning of `x`.
    static var defaultValue: Self.Value { get }

    /// Combines a sequence of values by modifying the previously-accumulated
    /// value with the result of a closure that provides the next value.
    ///
    /// If multiple values are outputted by multiple different views, all using the same
    /// ``PreferenceKey``, this function allows for logic to reduce all those
    /// preferences to a single value.
    ///
    /// For example, if there are two views at the same level that both output a preference:
    ///
    /// ```
    /// struct ExampleView: View {
    ///    @State private var customPreferenceKey: String = ""
    ///
    ///    var body: some View {
    ///        VStack {
    ///            Text("First view that sets a preference")
    ///                .preference(key: CustomPreferenceKey.self, value: "The first preference value")
    ///
    ///            Text("Second view that sets a preference")
    ///                .preference(key: CustomPreferenceKey.self, value: "The second preference value")
    ///        }
    ///        .onPreferenceChange(CustomPreferenceKey.self) { (value: CustomPreferenceKey.Value) in
    ///            customPreferenceKey = value
    ///            print(customPreferenceKey) // Prints: "The first preference value & The second preference value"
    ///        }
    ///    }
    /// }
    ///
    /// struct CustomPreferenceKey: PreferenceKey {
    ///    static var defaultValue: String = ""
    ///
    ///    static func reduce(value: inout String, nextValue: () -> String) {
    ///        value = "\(value) & \(nextValue())"
    ///    }
    /// }
    /// ```
    ///
    /// For additional details on how the reduce function works, see:
    /// [https://medium.com/swlh/dissecting-the-reduce-method-on-preferencekey-8a3571cfbc2b](https://medium.com/swlh/dissecting-the-reduce-method-on-preferencekey-8a3571cfbc2b)
    ///
    /// - Parameters:
    ///   - value: The value accumulated through previous calls to this method.
    ///     The implementation should modify this value.
    ///   - nextValue: A closure that returns the next value in the sequence.
    static func reduce(value: inout Self.Value, nextValue: () -> Self.Value) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PreferenceKey where Self.Value : ExpressibleByNilLiteral {

    /// Let nil-expressible values default-initialize to nil.
    public static var defaultValue: Self.Value { get }
}

/// A key for specifying the preferred color scheme.
@available(iOS 13.0, macOS 11.0, tvOS 13.0, watchOS 6.0, *)
public struct PreferredColorSchemeKey : PreferenceKey {

    /// The type of value produced by this preference.
    public typealias Value = ColorScheme?

    /// Combines a sequence of values by modifying the previously-accumulated
    /// value with the result of a closure that provides the next value.
    ///
    /// This method receives its values in view-tree order. Conceptually, this
    /// combines the preference value from one tree with that of its next
    /// sibling.
    ///
    /// - Parameters:
    ///   - value: The value accumulated through previous calls to this method.
    ///     The implementation should modify this value.
    ///   - nextValue: A closure that returns the next value in the sequence.
    public static func reduce(value: inout PreferredColorSchemeKey.Value, nextValue: () -> PreferredColorSchemeKey.Value) { }
}

/// An indication whether a view is currently presented by another view.
///
/// This is the type of the environment value used to programmatically
/// interact with the view currently presented.
///
/// This is useful for 4 types of views:
/// 1. ``NavigationView``
/// 2. ``View/sheet(isPresented:onDismiss:)``
/// 3. ``View/popover(isPresented:onDismiss:)``
/// 4. ``View/fullScreenCover(isPresented:onDismiss)``
///
/// See ``Environment`` for more on environment values and how to use
/// the property wrapper.
///
/// While this is a ``Binding`` environment value, most often
/// the wrapped value will be accessed. The wrapped value
/// is of type ``PresentatinMode``. See that structure for more info
/// on its properties.
///
/// Below is a simple example of programmatically dismissing a
/// sheet using this environment value.
///
///     struct ExampleView: View {
///         @State private var showSheet = false
///
///         var body: some View {
///             Button("Open sesame 📬") {
///                 showSheet = true
///             }
///             .sheet(isPresented: $showCover,
///                    onDismiss: { print("dismissed!") },
///                    content: { ExampleSheet() })
///         }
///     }
///
///     struct ExampleSheet: View {
///         @Environment(\.presentationMode) var presentationMode
///
///         var body: some View {
///             Button("CLOSE 📪") {
///                 presentationMode.wrappedValue.dismiss()
///             }
///         }
///     }
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PresentationMode {

    /// Indicates whether a view is currently presented.
    ///
    /// Use this property of the presentation mode environment value to
    /// programmatically read the presentation status of the current view.
    ///
    /// This is useful for 4 types of views:
    /// 1. ``NavigationView``
    /// 2. ``View/sheet(isPresented:onDismiss:)``
    /// 3. ``View/popover(isPresented:onDismiss:)``
    /// 4. ``View/fullScreenCover(isPresented:onDismiss)``
    ///
    /// See ``Environment`` for more on environment values and how to use
    /// the property wrapper.
    ///
    /// Below is a simple example of programmatically dismissing a
    /// sheet using this environment value.
    ///
    ///     struct ExampleView: View {
    ///         @State private var showSheet = false
    ///
    ///         var body: some View {
    ///             Button("Open sesame 📬") {
    ///                 showSheet = true
    ///             }
    ///             .sheet(isPresented: $showCover,
    ///                    onDismiss: { print("dismissed!") },
    ///                    content: { ExampleSheet() })
    ///         }
    ///     }
    ///
    ///     struct ExampleSheet: View {
    ///         @Environment(\.presentationMode) var presentationMode
    ///
    ///         var body: some View {
    ///             Text("hello!")
    ///                 .onAppear {
    ///                     print(presentationMode.wrappedValue.isPresented) //true
    ///                 }
    ///         }
    ///     }
    ///
    public var isPresented: Bool { get }

    /// Dismisses the view if it is currently presented.
    ///
    /// Use this function on the presentation mode environment value to
    /// programmatically dismiss the view currently presented.
    ///
    /// This is useful for 4 types of views:
    /// 1. ``NavigationView``
    /// 2. ``View/sheet(isPresented:onDismiss:)``
    /// 3. ``View/popover(isPresented:onDismiss:)``
    /// 4. ``View/fullScreenCover(isPresented:onDismiss)``
    ///
    /// Below is a simple example of programmatically dismissing a
    /// sheet using this environment value.
    ///
    ///     struct ExampleView: View {
    ///         @State private var showSheet = false
    ///
    ///         var body: some View {
    ///             Button("Open sesame 📬") {
    ///                 showSheet = true
    ///             }
    ///             .sheet(isPresented: $showCover,
    ///                    onDismiss: { print("dismissed!") },
    ///                    content: { ExampleSheet() })
    ///         }
    ///     }
    ///
    ///     struct ExampleSheet: View {
    ///         @Environment(\.presentationMode) var presentationMode
    ///
    ///         var body: some View {
    ///             Button("CLOSE 📪") {
    ///                 presentationMode.wrappedValue.dismiss()
    ///             }
    ///         }
    ///     }
    ///
    public mutating func dismiss() { }
}

/// A specification for the context of a `PreviewContext`
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol PreviewContext { }
extension PreviewContext {

    /// Returns the context's value of `Key`, or `Key.defaultValue`
    /// if the context does not define a value for the key.
    subscript<Key>(key: Key.Type) -> Key.Value where Key : PreviewContextKey { get }
}

/// The key for a preview context.
///
/// The default value is nil.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol PreviewContextKey{ }
extension PreviewContextKey {

    /// The type of the value returned by the key.
    associatedtype Value

    /// The default value of the key.
    static var defaultValue: Self.Value { get }
}

/// The simulator device that runs a preview.
///
/// Refer to a preview device by its name as shown Xcode's run destination menu,
/// like "iPhone X", or using a model number, like "iPad8,1".
///
/// The full list of device names is here:
/// - iPhone 4s
/// - iPhone 5
/// - iPhone 5s
/// - iPhone 6 Plus
/// - iPhone 6
/// - iPhone 6s
/// - iPhone 6s Plus
/// - iPhone SE (1st generation)
/// - iPhone 7
/// - iPhone 7 Plus
/// - iPhone 8
/// - iPhone 8 Plus
/// - iPhone X
/// - iPhone Xs
/// - iPhone Xs Max
/// - iPhone Xʀ
/// - iPhone 11
/// - iPhone 11 Pro
/// - iPhone 11 Pro Max
/// - iPhone SE (2nd generation)
/// - iPhone 12 mini
/// - iPhone 12
/// - iPhone 12 Pro
/// - iPhone 12 Pro Max
/// - iPod touch (7th generation)
/// - iPad 2
/// - iPad Retina
/// - iPad Air
/// - iPad mini 2
/// - iPad mini 3
/// - iPad mini 4
/// - iPad Air 2
/// - iPad Pro (9.7-inch)
/// - iPad Pro (12.9-inch) (1st generation)
/// - iPad (5th generation)
/// - iPad Pro (12.9-inch) (2nd generation)
/// - iPad Pro (10.5-inch)
/// - iPad (6th generation)
/// - iPad (7th generation)
/// - iPad Pro (11-inch) (1st generation)
/// - iPad Pro (12.9-inch) (3rd generation)
/// - iPad Pro (11-inch) (2nd generation)
/// - iPad Pro (12.9-inch) (4th generation)
/// - iPad mini (5th generation)
/// - iPad Air (3rd generation)
/// - iPad (8th generation)
/// - iPad Air (4th generation)
/// - Apple TV
/// - Apple TV 4K
/// - Apple TV 4K (at 1080p)
/// - Apple Watch - 38mm
/// - Apple Watch - 42mm
/// - Apple Watch Series 2 - 38mm
/// - Apple Watch Series 2 - 42mm
/// - Apple Watch Series 3 - 38mm
/// - Apple Watch Series 3 - 42mm
/// - Apple Watch Series 4 - 40mm
/// - Apple Watch Series 4 - 44mm
/// - Apple Watch Series 5 - 40mm
/// - Apple Watch Series 5 - 44mm
/// - Apple Watch SE - 40mm
/// - Apple Watch SE - 44mm
/// - Apple Watch Series 6 - 40mm
/// - Apple Watch Series 6 - 44mm
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PreviewDevice : RawRepresentable, ExpressibleByStringLiteral {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: String

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init(rawValue: String) { }

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral: String) { }

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = String

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    public typealias StringLiteralType = String

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    public typealias UnicodeScalarLiteralType = String
}

/// The size constraint for a preview.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum PreviewLayout {

    /// Center the preview in a container the size of the device on which the
    /// preview is running.
    case device

    /// Fit the container to the size of the preview when offered the size of
    /// the device on which the preview is running.
    case sizeThatFits

    /// Center the preview in a fixed size container.
    case fixed(width: CGFloat, height: CGFloat)
}

/// The operating system on which to run the preview.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum PreviewPlatform {

	/// The iOS preview platform.
    case iOS

    /// The macOS preview platform.
    case macOS

    /// The tvOS preview platform.
    case tvOS

    /// The watchOS preview platform.
    case watchOS

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PreviewPlatform, b: PreviewPlatform) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PreviewPlatform : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PreviewPlatform : Hashable {
}

/// A protocol that generates previews on the right-hand side of Xcode.
///
/// Xcode statically discovers types that conform to the `PreviewProvider`
/// protocol in your app, and generates previews for each provider it discovers.
///
/// For example, to have Xcode render a preview of a simple view:
///
/// ![Preview provider example 1](previewprovider-example-1.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        Circle().fill(Color.green)
///    }
/// }
///
/// struct ExampleViewPreview: PreviewProvider {
///    static var previews: some View {
///        ExampleView()
///    }
///
///    static var platform: PreviewPlatform? {
///        .iOS
///    }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol PreviewProvider : _PreviewProvider{ }
extension PreviewProvider : _PreviewProvider {

    /// The type to preview.
    associatedtype Previews : View

    /// Generates a collection of previews.
    ///
    /// The following code shows how to create a preview provider that previews
    /// a view called `MyView` for iPhone X:
    ///
    ///     struct MyPreviews : PreviewProvider {
    ///         static var previews: some View {
    ///             MyView()
    ///                 .previewDevice("iPhone X")
    ///         }
    ///     }
    @ViewBuilder static var previews: Self.Previews { get }

    /// The platform on which to run the provider.
    ///
    /// If the preview provider returns `nil` for this property, Xcode infers
    /// the platform based on the file in which the `PreviewProvider` is
    /// defined. Return `nil` only when the file is in a target that supports
    /// multiple platforms.
    static var platform: PreviewPlatform? { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension PreviewProvider {

    /// The platform on which to run the provider.
    ///
    /// If the preview provider returns `nil` for this property, Xcode infers
    /// the platform based on the file in which the `PreviewProvider` is
    /// defined. Return `nil` only when the file is in a target that supports
    /// multiple platforms.
    public static var platform: PreviewPlatform? { get }
}

/// This protocol is used to define custom button styles.
///
/// `PrimitiveButtonStyle` is a modifier used to define custom styling and interaction behavior for buttons. The primitive style will override the default action trigger of the button, and allows interactions to be customized. SwiftUI provides a number of these styles including`BorderlessButtonStyle` and `PlainButtonStyle`.
///
/// Your structure only needs to implement one method: `makeBody(configuration:)`. The desired button view is output by this method.
///
/// To build a custom `PrimitiveButtonStyle`, create a struct that conforms to the protocol.
///
/// `makeBody(configuration:)` accepts a `PrimitiveButtonStyleConfiguration`, which passes the original label to display the button view and a `trigger()` to execute its action. A gesture is commonly added to the label in order to trigger the button action.
///
/// Use `View/buttonStyle(_:)` to apply a primitive button style.
///
/// ![PrimitiveButtonStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/PrimitiveButtonStyle-example-1.png)
///
/// ```
///  struct ExampleView: View {
///      var body: some View {
///         Button("Banana 🍌🍌", action: { tap() })
///             .buttonStyle(MyPrimitiveButtonStyle())
///      }
///
///      func tap() {}
///  }
///
///  struct MyPrimitiveButtonStyle: PrimitiveButtonStyle {
///    func makeBody(configuration: Configuration) -> some View {
///      configuration.label
///         .foregroundColor(.yellow)
///         .onTapGesture { configuration.trigger() }
///    }
///  }
/// ```
///
/// `PrimitiveButtonStyle` applies to all buttons within a view hierarchy. For example, you could apply `BananaButtonStyle` to a `VStack`.
///
/// ![PrimitiveButtonStyle Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/PrimitiveButtonStyle-example-2.png)
///
/// ```
///  struct BananaView: View {
///      var body: some View {
///          VStack {
///              Button("Banana 🍌🍌", action: { tap() })
///              Button("Apple 🍏🍏", action: { tap() })
///              Button("Peach 🍑🍑", action: { tap() })
///          }
///          .buttonStyle(BananaButtonStyle(color: .yellow))
///      }
///
///      func tap() {}
///  }
///
///  struct BananaButtonStyle: PrimitiveButtonStyle {
///    let color: Color
///
///    func makeBody(configuration: Configuration) -> some View {
///        configuration.label
///            .padding()
///            .background(RoundedRectangle(cornerRadius: 10).fill(color))
///            .onTapGesture { configuration.trigger() }
///    }
///  }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol PrimitiveButtonStyle{ }
extension PrimitiveButtonStyle {

    /// A view that represents the body of a button.
    associatedtype Body : View

    /// Creates a view that represents the body of a button.
    ///
    /// The system calls this method for each `Button` instance in a view
    /// hierarchy where this style is the current button style.
    ///
    /// ![PrimitiveButtonStyle Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/PrimitiveButtonStyle-example-2.png)
    ///
    /// ```
    ///  struct BananaView: View {
    ///      var body: some View {
    ///          VStack {
    ///              Button("Banana 🍌🍌", action: { tap() })
    ///              Button("Apple 🍏🍏", action: { tap() })
    ///              Button("Peach 🍑🍑", action: { tap() })
    ///          }
    ///          .buttonStyle(BananaButtonStyle(color: .yellow))
    ///      }
    ///
    ///      func tap() {}
    ///  }
    ///
    ///  struct BananaButtonStyle: PrimitiveButtonStyle {
    ///    let color: Color
    ///
    ///    func makeBody(configuration: Configuration) -> some View {
    ///        configuration.label
    ///            .padding()
    ///            .background(RoundedRectangle(cornerRadius: 10).fill(color))
    ///            .onTapGesture { configuration.trigger() }
    ///    }
    ///  }
    /// ```
    ///
    /// - Parameter configuration : The properties of the button.
    func makeBody(configuration: Self.Configuration) -> Self.Body { }

    /// The properties of a button.
    typealias Configuration = PrimitiveButtonStyleConfiguration
}

/// The properties of a button.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct PrimitiveButtonStyleConfiguration {

    /// A type-erased label of a button.
    public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A view that describes the effect of calling the button's action.
    public let label: PrimitiveButtonStyleConfiguration.Label

    /// Performs the button's action.
    public func trigger() { }
}

/// An animated loading bar or "spinner" shown when an ongoing task has started but is not yet complete
///
/// A progress view is a combination of `UIProgressView` and `UIActivityIndicatorView` from UIKit. When initialized without arguments, it resembles `UIActivityIndicatorView`, an indeterminate progress indicator or “spinner”.
///
///     struct IndeterminateProgressViews: View {
///         var body: some View {
///            VStack {
///               ProgressView()
///               ProgressView(value: Double?(nil))
///               ProgressView(value: -1)
///            }
///         }
///     }
///
/// When initialized with a value `ProgressView` looks like `UIProgressView`, a loading bar that fills up from left to right. There are notable exceptions featured in the example above. For example, a value of nil or less than 0.0 shows an indeterminate progress indicator or “spinner”."
/// The value can be any generic type that conforms to the `BinaryFloatingPoint` protocol, which includes     `CGFloat`, `Double`, `Float`, `Float16` and `Float80`.
///
///     struct DeteriminateProgressViews: View {
///         @State var value = Double()
///         var body: some View {
///             VStack {
///                 Slider(value: $value, in: 0...1)
///                 ProgressView(value: value)
///                 ProgressView(value: value, total: 1)
///                 ProgressView(value: value, total: 2)
///                 ProgressView(value: value) {
///                     Text("Label")
///                 }
///                 ProgressView("Title", value: value)
///             }
///         }
///     }
///
/// ### Styling Progress Views
///
/// Structures that conform to the `ProgressViewStyle` protocol can be used to modify the appearance of `ProgressView`. The structure passed to the
/// `progressViewStyle(_:)` modifier applies to all `ProgressView` instances in the children of that `View`.
///
/// In this example, the same style is applied to two `ProgressView` instances that are children of a `VStack`:
///
///     struct DefaultProgressViews: View {
///         var body: some View {
///             VStack {
///                 ProgressView(value: 0.25)
///                   .accentColor(.red)
///                 ProgressView(value: 0.75)
///                   .background(.black)
///             }
///             .progressViewStyle(DefaultProgressViewStyle())
///         }
///     }
///
/// Although a custom `accentColor` and `background` were set in the example above, these modifiers were overridden by the `DefaultProgressViewStyle`. This style sets `accentColor` to `Color.blue` and `background` to `Color.gray.opacity(0.1)`. As the default opacity of the background is `0.1`, any content behind the `ProgressView` will be visible in the unfilled portion of the loading bar.
///
/// To swap the colors, you can approximate how `Color.gray.opacity(0.1)` would look on a given background. Swapping the default colors will cause the blue background to show through the translucent gray, so it won't look right.
///
///      struct ExampleView: View {
///         var body: some View {
///             ProgressView()
///                 .progressViewStyle(InvertedColorProgressViewStyle())
///         }
///      }
///
///     struct InvertedColorProgressViewStyle: ProgressViewStyle {
///         func makeBody(configuration: Configuration) -> some View {
///           ProgressView(configuration)
///            .background(Color.blue)
///            .accentColor(Color(red: 0.894, green: 0.894, blue: 0.902))
///         }
///     }
///
/// [rotation-effect ->]
/// To create a `ProgressViewStyle` that inverts the direction of the animation, use a `rotation3DEffect(_:axis:anchor:anchorZ:perspective:)` modifier.
///
///      struct ExampleView: View {
///         var body: some View {
///             ProgressView()
///                 .progressViewStyle(InvertedDirectionProgressViewStyle())
///         }
///      }
///
///     struct InvertedDirectionProgressViewStyle: ProgressViewStyle {
///         func makeBody(configuration: Configuration) -> some View {
///             GeometryReader { geometry in
///                 ProgressView(configuration)
///                     .frame(height: geometry.size.height)
///                     .rotation3DEffect(.degrees(180), axis: (x: 0, y: 0, z: 1))
///             }
///         }
///     }
///
/// [<-]
///   A vertical `ProgressView` can be achieved by rotating 90 degrees, but this will not make enough vertical space for it to display within the available space. Instead make use of `GeometryReader` in order to allow the view to scale accordingly. One method to keep your `ProgressView` centered after a rotation is to use the offset modifier. Without this modifier the rotation could cause the `ProgressView` to move out of bounds.
///
/// [progressview-style ->]
///
///      struct ExampleView: View {
///         var body: some View {
///             ProgressView()
///                 .progressViewStyle(VerticalProgressViewStyle())
///         }
///      }
///
///     struct VerticalProgressViewStyle: ProgressViewStyle {
///         func makeBody(configuration: Configuration) -> some View {
///           GeometryReader { geometry in
///             ProgressView(configuration)
///                 .frame(width: geometry.size.height)
///                 .offset(x: geometry.size.height / 2, y: geometry.size.height / 2)
///                 .rotationEffect(.degrees(90))
///             }
///         }
///      }
///
///  To invert the direction of progress in the vertical style, merely apply the `rotation3DEffect(_:axis:anchor:anchorZ:perspective:)` modifier as before.
///
///
///      struct ExampleView: View {
///         var body: some View {
///             ProgressView()
///                 .progressViewStyle(InvertedVerticalProgressViewStyle())
///         }
///      }
///
///     struct InvertedVerticalProgressViewStyle: ProgressViewStyle {
///          func makeBody(configuration: Configuration) -> some View {
///              GeometryReader { geometry in
///                  ProgressView(configuration)
///                     .frame(width: geometry.size.height)
///                     .rotationEffect(.degrees(90))
///                     .rotation3DEffect(.degrees(180), axis: (x: 0, y: 0, z: 1))
///                     .offset(x: -(geometry.size.height / 2), y: geometry.size.height / 2)
///              }
///          }
///     }
///
/// [<-]
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ProgressView<Label, CurrentValueLabel> : View where Label : View, CurrentValueLabel : View {

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView where CurrentValueLabel == EmptyView {

    /// Creates a progress view for showing indeterminate progress, without a
    /// label.
    public init() where Label == EmptyView { }

    /// Creates a progress view for showing indeterminate progress that displays
    /// a custom label.
    ///
    /// - Parameters:
    ///     - label: A view builder that creates a view that describes the task
    ///       in progress.
    public init(@ViewBuilder label: () -> Label) { }

    /// Creates a progress view for showing indeterminate progress that
    /// generates its label from a localized string.
    ///
    /// This initializer creates a `Text` view on your behalf, and treats the
    /// localized key similar to `Text/init(_:tableName:bundle:comment:)`. See
    /// `Text` for more information about localizing strings. To initialize a
    /// indeterminate progress view with a string variable, use
    /// the corresponding initializer that takes a `StringProtocol` instance.
    ///
    /// - Parameters:
    ///     - titleKey: The key for the progress view's localized title that
    ///       describes the task in progress.
    public init(_ titleKey: LocalizedStringKey) where Label == Text { }

    /// Creates a progress view for showing indeterminate progress that
    /// generates its label from a string.
    ///
    /// - Parameters:
    ///     - title: A string that describes the task in progress.
    ///
    /// This initializer creates a `Text` view on your behalf, and treats the
    /// title similar to `Text/init(verbatim:)`. See `Text` for more
    /// information about localizing strings. To initialize a progress view with
    /// a localized string key, use the corresponding initializer that takes a
    /// `LocalizedStringKey` instance.
    public init<S>(_ title: S) where Label == Text, S : StringProtocol { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView {

    /// Creates a progress view for showing determinate progress.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// - Parameters:
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    public init<V>(value: V?, total: V = 1.0) where Label == EmptyView, CurrentValueLabel == EmptyView, V : BinaryFloatingPoint { }

    /// Creates a progress view for showing determinate progress, with a
    /// custom label.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// - Parameters:
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    ///     - label: A view builder that creates a view that describes the task
    ///       in progress.
    public init<V>(value: V?, total: V = 1.0, @ViewBuilder label: () -> Label) where CurrentValueLabel == EmptyView, V : BinaryFloatingPoint { }

    /// Creates a progress view for showing determinate progress, with a
    /// custom label.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// - Parameters:
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    ///     - label: A view builder that creates a view that describes the task
    ///       in progress.
    ///     - currentValueLabel: A view builder that creates a view that
    ///       describes the level of completed progress of the task.
    public init<V>(value: V?, total: V = 1.0, @ViewBuilder label: () -> Label, @ViewBuilder currentValueLabel: () -> CurrentValueLabel) where V : BinaryFloatingPoint { }

    /// Creates a progress view for showing determinate progress that generates
    /// its label from a localized string.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// This initializer creates a `Text` view on your behalf, and treats the
    /// localized key similar to `Text/init(_:tableName:bundle:comment:)`. See
    /// `Text` for more information about localizing strings. To initialize a
    ///  determinate progress view with a string variable, use
    ///  the corresponding initializer that takes a `StringProtocol` instance.
    ///
    /// - Parameters:
    ///     - titleKey: The key for the progress view's localized title that
    ///       describes the task in progress.
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is
    ///       indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    public init<V>(_ titleKey: LocalizedStringKey, value: V?, total: V = 1.0) where Label == Text, CurrentValueLabel == EmptyView, V : BinaryFloatingPoint { }

    /// Creates a progress view for showing determinate progress that generates
    /// its label from a string.
    ///
    /// If the value is non-`nil`, but outside the range of `0.0` through
    /// `total`, the progress view pins the value to those limits, rounding to
    /// the nearest possible bound. A value of `nil` represents indeterminate
    /// progress, in which case the progress view ignores `total`.
    ///
    /// This initializer creates a `Text` view on your behalf, and treats the
    /// title similar to `Text/init(verbatim:)`. See `Text` for more
    /// information about localizing strings. To initialize a determinate
    /// progress view with a localized string key, use the corresponding
    /// initializer that takes a `LocalizedStringKey` instance.
    ///
    /// - Parameters:
    ///     - title: The string that describes the task in progress.
    ///     - value: The completed amount of the task to this point, in a range
    ///       of `0.0` to `total`, or `nil` if the progress is
    ///       indeterminate.
    ///     - total: The full amount representing the complete scope of the
    ///       task, meaning the task is complete if `value` equals `total`. The
    ///       default value is `1.0`.
    public init<S, V>(_ title: S, value: V?, total: V = 1.0) where Label == Text, CurrentValueLabel == EmptyView, S : StringProtocol, V : BinaryFloatingPoint { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView {

    /// Creates a progress view for visualizing the given progress instance.
    ///
    /// The progress view synthesizes a default label using the
    /// `localizedDescription` of the given progress instance.
    public init(_ progress: Progress) where Label == EmptyView, CurrentValueLabel == EmptyView { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ProgressView {

    /// Creates a progress view based on a style configuration.
    ///
    /// You can use this initializer within the
    /// `ProgressViewStyle/makeBody(configuration:)` method of a
    /// `ProgressViewStyle` to create an instance of the styled progress view.
    /// This is useful for custom progress view styles that only modify the
    /// current progress view style, as opposed to implementing a brand new
    /// style.
    ///
    /// For example, the following style adds a dark blue shadow to the progress
    /// view, but otherwise preserves the progress view's current style:
    ///
    ///     struct DarkBlueShadowProgressViewStyle: ProgressViewStyle {
    ///         func makeBody(configuration: Configuration) -> some View {{}
    ///             ProgressView(configuration)
    ///                 .shadow(color: Color(red: 0, green: 0, blue: 0.6),
    ///                         radius: 4.0, x: 1.0, y: 2.0)
    ///         }
    ///     }
    ///
    public init(_ configuration: ProgressViewStyleConfiguration) where Label == ProgressViewStyleConfiguration.Label, CurrentValueLabel == ProgressViewStyleConfiguration.CurrentValueLabel { }
}

/// A type that applies standard interaction behavior to all progress views
/// within a view hierarchy.
///
/// To configure the current progress view style for a view hiearchy, use the
/// `View/progressViewStyle(_:)` modifier.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol ProgressViewStyle{ }
extension ProgressViewStyle {

    /// A view representing the body of a progress view.
    associatedtype Body : View

    /// Creates a view representing the body of a progress view.
    ///
    /// - Parameter configuration: The properties of the progress view being
    ///   created.
    ///
    /// The view hierarchy calls this method for each progress view where this
    /// style is the current progress view style.
    ///
    /// - Parameter configuration: The properties of the progress view, such as
    ///  its preferred progress type.
    func makeBody(configuration: Self.Configuration) -> Self.Body { }

    /// A type alias for the properties of a progress view instance.
    typealias Configuration = ProgressViewStyleConfiguration
}

/// The properties of a progress view instance.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ProgressViewStyleConfiguration {

    /// A type-erased label describing the task represented by the progress
    /// view.
    public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A type-erased label that describes the current value of a progress view.
    public struct CurrentValueLabel : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// The completed fraction of the task represented by the progress view,
    /// from `0.0` (not yet started) to `1.0` (fully complete), or `nil` if the
    /// progress is indeterminate.
    public let fractionCompleted: Double?

    /// A view that describes the task represented by the progress view.
    ///
    /// If `nil`, then the task is self-evident from the surrounding context,
    /// and the style does not need to provide any additional description.
    ///
    /// If the progress view is defined using a `Progress` instance, then this
    /// label is equivalent to its `localizedDescription`.
    public var label: ProgressViewStyleConfiguration.Label?

    /// A view that describes the current value of a progress view.
    ///
    /// If `nil`, then the value of the progress view is either self-evident
    /// from the surrounding context or unknown, and the style does not need to
    /// provide any additional description.
    ///
    /// If the progress view is defined using a `Progress` instance, then this
    /// label is equivalent to its `localizedAdditionalDescription`.
    public var currentValueLabel: ProgressViewStyleConfiguration.CurrentValueLabel?
}

/// A projection transform is a type of spacial transformation of an object
/// that can be represented as a 3x3 matrix.
///
/// Use this structure to apply a 3D transformation to a view.
///
/// Conceptually, this structure represents a 3D transformation matrix.
/// Each column of the matrix represents where the unit vector
/// of the original view lands in the transformed view. The **x** unit
/// vector is represented by the left column, the **y** unit vector
/// is represented by the middle column, and the **z** unit vector
/// is represented by the right column.
///
/// - Note: In the majority of circumstances, it is not necessary to use
/// a `ProjectionTransform` or the ``View/projectionEffect(_:)``
/// modifier. This is only necessary when maximum control is required.
/// For most normal use cases, use the following modifiers instead:
///
/// - **Rotation**: ``View/rotationEffect(_:)``
/// - **Scaling**: ``View/scaleEffect(_:anchor:)``
/// - **Translation**: ``View/offset(_:)``
///
/// ### Making a `ProjectionTransform`
///
/// Constructing a `ProjectionTransform` is most commonly done in
/// one of three ways:
/// - Using a [CGAffineTransform](https://developer.apple.com/documentation/coregraphics/cgaffinetransform)
/// - Using a [CATransform3D](https://developer.apple.com/documentation/quartzcore/catransform3d)
/// - Using ``GeometryEfect/effectValue(size:)``
///
/// See below for an example.
///
/// ### Using a `ProjectionTransform`
///
/// The primary way to use a `ProjectionTransform` is by using the
/// ``View/projectionEffect(_:)`` modifier.
///
/// ```
/// struct UpsideDownTrashCanView: View {
///     var body: some View {
///         Text("🗑")
///             .font(.title)
///             .projectionEffect(
///                 ProjectionTransform(
///                     CGAffineTransform(rotationAngle: .pi)))
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ProjectionTransform {

	/// The top left value in the projection transform matrix.
    ///
    /// This property can be written to or read directly, but it's usually
    /// calculated using one of the initializers instead.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m11 = 4
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m11: CGFloat

    /// The top middle value in the projection transform matrix.
    ///
    /// This property can be written to or read directly, but it's usually
    /// calculated using one of the initializers instead.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m12 = 1
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m12: CGFloat

    /// The top right value in the projection transform matrix.
    ///
    /// This property can be written to or read directly, but it's usually
    /// calculated using one of the initializers instead.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m13 = 0.01
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m13: CGFloat

    /// The center left value in the projection transform matrix.
    ///
    /// This property can be written to or read directly, but it's usually
    /// calculated using one of the initializers instead.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m21 = 1
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m21: CGFloat

    /// The center value in the projection transform matrix.
    ///
    /// This property can be written to or read directly, but it's usually
    /// calculated using one of the initializers instead.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m11 = 4
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m22: CGFloat

    /// The center right value in the projection transform matrix.
    ///
    /// This property can be written to or read directly, but it's usually
    /// calculated using one of the initializers instead.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m23 = 0.01
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m23: CGFloat

    /// The bottom left value in the projection transform matrix.
    ///
    /// This property can be written to or read directly, but it's usually
    /// calculated using one of the initializers instead.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m31 = 100
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m31: CGFloat

    /// The bottom center value in the projection transform matrix.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m32 = 100
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m32: CGFloat

    /// The bottom right value in the projection transform matrix.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m33 = 0.1
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    public var m33: CGFloat

    /// Creates a projection transform equal to the identity matrix.
    ///
    /// Use this initilizer to create a matrix that does nothing so that
    /// you can modify it afterwards.
    ///
    /// ```
    /// struct WarpedTrashCanView: View {
    ///     var body: some View {
    ///         var effect = ProjectionTransform()
    ///         effect.m11 = 4
    ///
    ///         return Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    @inlinable public init() { }

    /// Creates a projection transform from a `CGAffineTransform`.
    ///
    /// See [CGAffineTransform](https://developer.apple.com/documentation/coregraphics/cgaffinetransform)
    /// for more info on how to create an affine transform.
    ///
    /// ```
    /// struct UpsideDownTrashCanView: View {
    ///     var body: some View {
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(
    ///                 ProjectionTransform(
    ///                     CGAffineTransform(rotationAngle: .pi)))
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter m: The Core Graphics affine transform matrix.
    @inlinable public init(_ m: CGAffineTransform) { }

    /// Creates a projection transform from a `CATransform3D`.
    ///
    /// See [CATransform3D](https://developer.apple.com/documentation/quartzcore/catransform3d)
    /// for more info on how to create a 3D transform.
    ///
    /// ```
    /// struct UpsideDownTrashCanView: View {
    ///     var body: some View {
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(
    ///                 ProjectionTransform(
    ///                     CGAffineTransform(rotationAngle: .pi)))
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter m: The Core Animation 3D transform matrix.
    @inlinable public init(_ m: CATransform3D) { }

    /// Whether the projection transform matrix is an identity matrix.
    ///
    /// ```
    /// struct JustATrashCanView: View {
    ///     let effect = ProjectionTransform()
    ///     var body: some View {
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///             .onAppear { print(effect.isIdentity) } //true
    ///     }
    /// }
    /// ```
    @inlinable public var isIdentity: Bool { get }

    /// Whether the projection transform matrix is an affine transform.
    ///
    /// An affine transformation is one that preserves lines and parallelism
    /// (but not necessarily distances and angles).
    ///
    /// See this [Wikipedia](https://en.wikipedia.org/wiki/Affine_transformation)
    /// article for more info.
    ///
    /// ```
    /// struct AffineTransformedTrashCanView: View {
    ///     let effect = ProjectionTransform(CGAffineTransform(rotationAngle: .pi))
    ///     var body: some View {
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///             .onAppear { print(effect.isAffine) } //true
    ///     }
    /// }
    /// ```
    @inlinable public var isAffine: Bool { get }

    /// Inverts the projection transform matrix if it's invertible.
    ///
    /// Use this function to mutate the effect to its inverse.
    /// If instead you would like to return a new inverted matrix,
    /// use ``ProjectionTransform/inverted()`` instead.
    ///
    /// ```
    /// struct RotatedTrashCanView: View {
    ///     var effect = ProjectionTransform(CGAffineTransform(rotationAngle: 2))
    ///     effect.invert() //rotates the other way!
    ///     var body: some View {
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
    ///
    /// - Returns: A Boolean of whether the matrix was successfully inverted.
    public mutating func invert() -> Bool { }

    /// Modifies the projection transform to its inverse if invertable.
    ///
    /// Use this function to return a new inverted matrix. If instead
    /// you would like to mutate the projection transform itself,
    /// use the ``ProjectionTransform/invert()`` method instead.
    ///
    /// ```
    /// struct MirroredTrashCanView: View {
    ///     let clockwise = ProjectionTransform(CGAffineTransform(rotationAngle: 2))
    ///     let counterclockwise = clockwise.inverted()
    ///     var body: some View {
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(clockwise)
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(counterclockwise)
    ///     }
    /// }
    /// ```
    ///
    /// - Returns: An inverted projection transform matrix.
    public func inverted() -> ProjectionTransform { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ProjectionTransform : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ProjectionTransform, b: ProjectionTransform) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ProjectionTransform {

	/// Concatenates two projection transform matrices together to make a new one.
    ///
    /// Projection matrix concatenation is mathematically equivalent to
    /// multiplication. Matrix multiplicaiton is *not* commutative.
    ///
    /// ```
    /// struct RotatedTrashCanView: View {
    ///     let effect1 = ProjectionTransform(CGAffineTransform(rotationAngle: 2))
    ///     let effect2 = ProjectionTransform(CGAffineTransform(rotationAngle: 1))
    ///     let effect = effect1.concatenating(effect2) //rotates 3 radians!
    ///
    ///     var body: some View {
    ///         Text("🗑")
    ///             .font(.title)
    ///             .projectionEffect(effect)
    ///     }
    /// }
    /// ```
	///
	/// - Parameter rhs: The projection transform matrix to concatenate.
	/// - Returns: A new concatenated projection transform matrix.
    @inlinable public func concatenating(_ rhs: ProjectionTransform) -> ProjectionTransform { }
}

/// A radial gradient that applies the color function as the distance from a center point,
/// scaled to fit within the defined start and end radii.
///
/// A Radial Gradient is very similar to a ``LinearGradient``, but instead of defining starting and ending points,
/// it is necessary to define a start radius, an end radius and the center of the gradeint.
///
/// The gradient is drawn as circular around the center, moving outwards to the end radius.
/// ``RadialGradient`` accepts a ``Unitpoint`` for the center of the gradeint and ``CGFloat`` for radius in points.
///
/// For example,
///
/// ![RadialGradient Example 1](radial-gradient-example.png)
///
/// ```
/// struct RadialView: View {
///     let gradient = Gradient(colors: [.red,.yellow])
///
///     var body: some View {
///         Rectangle()
///             .fill( RadialGradient(gradient: gradient, center: .center, startRadius: 1, endRadius: 100))
///             .frame(width: 200, height: 200)
///     }
/// }
/// ```
///
/// The gradient applies the color function as the distance from a center point,
/// scaled to fit within the defined start and end radii. The gradient maps the
/// unit-space center point into the bounding rectangle of each shape filled
/// with the gradient.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct RadialGradient : ShapeStyle, View {

	/// Creates a new radial gradient from a start and end point.
	///
    /// ![RadialGradient Example 1](radial-gradient-example.png)
    ///
    /// ```
    /// struct RadialView: View {
    ///    let gradient = Gradient(colors: [.red,.yellow])
    ///
    ///    var body: some View {
    ///        Rectangle()
    ///            .fill( RadialGradient(gradient: gradient, center: .center, startRadius: 1, endRadius: 100))
    ///            .frame(width: 200, height: 200)
    ///     }
    /// }
    /// ```
    ///
	/// - Parameters:
	///   - gradient: The gradient containing the colors to transition through.
	///   - center: The center of the radial gradient.
	///   - startRadius: How far from the center to start the gradient.
	///   - endRadius:
    public init(gradient: Gradient, center: UnitPoint, startRadius: CGFloat, endRadius: CGFloat) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

/// A rectangle shape.
///
/// A Rectangle is a rectangular `Shape` that by default, aligns itself inside
/// of the view containing it. To define a Rectangle with a specific color and
/// frame, use the `Shape/fill()` and `View/frame(width:height:)` modifiers:
///
/// ![Rectangle fill and frame example](rectangle-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Rectangle()
///             .fill(Color.blue)
///             .frame(width: 250, height: 150)
///     }
/// }
/// ```
///
/// To add a border, use the `Shape/stroke(:lineWidth:)` modifier, and use
/// the `Rectangle/inset(by:)` modifier to inset the rectangle by half of the
/// border width to keep the rectangle at its original size:
///
/// ![Rectangle inset and stroke example](rectangle-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Rectangle()
///             .inset(by: 10)
///             .stroke(Color.blue, lineWidth: 20)
///             .frame(width: 250, height: 150)
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Rectangle : Shape {

    /// Used to describe a Rectangle as a path in a `CGRect`.
    ///
    /// A Rectangle can be described as a path within a specific `CGRect` using
    /// the `Rectangle/path(in:)` modifier:
    ///
    /// ![Rectangle path example](rectangle-example-3.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Rectangle()
    ///             .path(in: CGRect(x: 0, y: 0, width: 100, height: 100))
    ///     }
    /// }
    /// ```
    public func path(in rect: CGRect) -> Path { }

    /// Creates a Rectangle that aligns itself inside of the view containing it
    /// by default.
    ///
    /// ![Rectangle init example](rectangle-example-4.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Rectangle()
    ///     }
    /// }
    /// ```
    @inlinable public init() { }

    /// > The type defining the data to animate.
    public typealias AnimatableData = EmptyAnimatableData

    /// > The type of view representing the body of this view.
    ///
    /// > When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Rectangle : InsettableShape {

    /// Returns a Rectangle insetted by the amount specified.
    ///
    /// For example, insetting by 10 points returns a Rectangle that fills its
    /// container, with 10 points inset on all four side.
    ///
    /// ![Rectangle inset example](rectangle-example-5.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Rectangle()
    ///             .inset(by: 10)
    ///     }
    /// }
    /// ```
    @inlinable public func inset(by amount: CGFloat) -> some InsettableShape { }


    /// > The type of the inset shape.
    public typealias InsetShape = some InsettableShape
}

/// The reasons to apply a redaction to data displayed on screen.
///
/// Use this type with the ``View/redacted(reason:)`` view modifier to
/// "redact" a view's contents. For now, that simply means to reaplace
/// the view with a placeholder.
///
/// In the future, this type may get more optionality, but as of now,
/// the only redaction reason is ``RedactionReasons/placeholder``
///
/// See the following example for adding redaction to a view.
///
/// ```
/// struct RedactedView: View {
///     var body: some View {
///         Label("Taylor Swift", systemImage: "person.fill")
///         Label("Kanye West", systemImage: "person.fill")
///             .redacted(reason: .placeholder)
///     }
/// }
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct RedactionReasons : OptionSet {

    /// The raw value.
    public let rawValue: Int

    /// Creates a new set from a raw value.
    ///
    /// Do not use this initializer directly. Rather, use one of the
    /// static constants of the strucutre:
    /// - ``RedactionReasons/placeholder``
    ///
    /// - Parameter rawValue: The raw value with which to create the
    ///   reasons for redaction.
    public init(rawValue: Int) { }

    /// Displayed data should appear as generic placeholders.
    ///
    /// Text and images will be automatically masked to appear as
    /// generic placeholders, though maintaining their original size and shape.
    /// Use this to create a placeholder UI without directly exposing
    /// placeholder data to users.
    ///
    /// In the future, this type may get more optionality, but as of now,
    /// this is the only property in ``RedactionReasons``.
    ///
    /// ```
    /// struct RedactedView: View {
    ///     var body: some View {
    ///         Label("Taylor Swift", systemImage: "person.fill")
    ///         Label("Kanye West", systemImage: "person.fill")
    ///             .redacted(reason: .placeholder)
    ///     }
    /// }
    public static let placeholder: RedactionReasons

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = RedactionReasons

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = RedactionReasons

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int
}

/// The protocol used to serialize a reference type document to and from a file.
///
/// Conform to this protocol to move a document between its file representation and its "swift-usable"
/// representation.
///
/// This protocol is very similar to ``FileDocument``, with the difference being whether the data
/// is stored as a `class` (reference type) or a `struct` (value type). Use the two protocols like this:
/// - `struct` --> ``FileDocument``
/// - `class` --> `ReferenceFileDocument`
///
/// While the two protocols are similar, `ReferenceFileDocument` has the unique challenge
/// of the user editing a document while it is being written to a file. For this reason,
/// ``ReferenceFileDocument/snapshot`` must be used. See the example for more details.
///
/// Don't worry about thread safety when using `ReferenceFileDocument`, since
/// deserialization and serialization are done on a background thread.
///
/// - Note: If your app will have documents, it very likely will be easiest to begin from Apple's own
/// Document app template. To do this, go to *File > New > Project*, and then use *Document App*.
///
/// ### Example
///
/// #### App structure
///
/// To begin, update the scene definition to use ``DocumentGroup``.
///
///     import SwiftUI
///
///     @main
///     struct ExampleApp: App {
///         var body: some Scene {
///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
///                 ContentView(document: file.document)
///             }
///         }
///     }
///
/// #### ReferenceFileDocument conformance
///
/// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
/// - A: ``ReferenceFileDocument/readableContentTypes``
/// - B: ``ReferenceFileDocument/init(configuration:)``
/// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
/// - D: ``ReferenceFileDocument/snapshot(contentType:)``
///
///     import SwiftUI
///     import UniformTypeIdentifiers
///
///     class ExampleDocument: ReferenceFileDocument {
///         @Published var text: String
///
///         init(text: String = "This is a brand new document! 📃") {
///             self.text = text
///         }
///
///         // A
///         static var readableContentTypes: [UTType] { [.exampleText] }
///
///         // B
///         required init(configuration: ReadConfiguration) throws {
///             guard let data = configuration.file.regularFileContents,
///                 let string = String(data: data, encoding: .utf8)
///             else {
///                 throw CocoaError(.fileReadCorruptFile)
///             }
///             text = string
///         }
///
///         // C
///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
///             let data = snapshot.data(using: .utf8)!
///             return .init(regularFileWithContents: data)
///         }
///
///         // D
///         func snapshot(contentType: UTType) throws -> String {
///             return text
///         }
///     }
///
/// #### View implementation
///
/// Finally, use the ``TextEditor`` view to edit the document file.
///
///     import SwiftUI
///
///     struct ExampleView: View {
///         @ObservedObject var document: ExampleDocument
///         var body: some View {
///             TextEditor(text: $document.text)
///         }
///     }
///
/// #### UTType settings
///
/// In order for any of this to work, your Xcode project will have to define a document type. To do this,
/// follow these steps:
/// 1. Go to the Xcode project settings.
/// 2. Click on your target to the left.
/// 3. Expand the "Document Types" tab.
/// 4. Click *"Click here to add additional document type properties"*
/// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
/// 6. Ensure the **Type** is *String*.
/// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
/// 8. Change the **Types** (top right) to *com.example.plain-text*.
///
///
/// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
///
///     import SwiftUI
///     import UniformTypeIdentifiers
///
///     extension UTType {
///         static var exampleText: UTType {
///             UTType(importedAs: "com.example.plain-text")
///         }
///     }
///
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol ReferenceFileDocument : ObservableObject{ }
extension ReferenceFileDocument : ObservableObject {

    /// The type of the the document snapshot used for serialization
    /// in parallel to the main document being editable.
    ///
    /// This associated type is resolved when a class conforming to the ``ReferenceFileDocument``
    /// protocol implements the required
    /// ``ReferenceFileDocument/snapshot(contentType:)`` method.
    /// It is the return type of this function.
    ///
    /// In the following example, the `snapshot(contentType:)` method returns a `String`,
    /// so the associated type `Snapshot` would resolve to `String`.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### ReferenceFileDocument conformance
    ///
    /// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
    /// - A: ``ReferenceFileDocument/readableContentTypes``
    /// - B: ``ReferenceFileDocument/init(configuration:)``
    /// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
    /// - D: ``ReferenceFileDocument/snapshot(contentType:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     class ExampleDocument: ReferenceFileDocument {
    ///         @Published var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         required init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = snapshot.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///
    ///         // D
    ///         func snapshot(contentType: UTType) throws -> String {
    ///             return text
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject var document: ExampleDocument
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    associatedtype Snapshot

    /// The types the ``ReferenceFileDocument`` document is able to open.
    ///
    /// The readable types of a document should be specified in its declaration. Very often,
    /// the process of creating a document-based app requires a custom UTType object.
    ///
    /// In the following example, we create a custom readable content type called `exampleText`.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### ReferenceFileDocument conformance
    ///
    /// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
    /// - A: ``ReferenceFileDocument/readableContentTypes``
    /// - B: ``ReferenceFileDocument/init(configuration:)``
    /// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
    /// - D: ``ReferenceFileDocument/snapshot(contentType:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     class ExampleDocument: ReferenceFileDocument {
    ///         @Published var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         required init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = snapshot.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///
    ///         // D
    ///         func snapshot(contentType: UTType) throws -> String {
    ///             return text
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject var document: ExampleDocument
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    static var readableContentTypes: [UTType] { get }

    /// The types that a reference file document is able to save or export to.
    ///
    /// SwiftUI defaults the value of this to `readableContentTypes`, and it usually doesn't need
    /// to change. In the following example, `writableContentTypes` defaults to
    /// `UTType.exampleText`.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### ReferenceFileDocument conformance
    ///
    /// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
    /// - A: ``ReferenceFileDocument/readableContentTypes``
    /// - B: ``ReferenceFileDocument/init(configuration:)``
    /// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
    /// - D: ``ReferenceFileDocument/snapshot(contentType:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     class ExampleDocument: ReferenceFileDocument {
    ///         @Published var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         required init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = snapshot.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///
    ///         // D
    ///         func snapshot(contentType: UTType) throws -> String {
    ///             return text
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject var document: ExampleDocument
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    static var writableContentTypes: [UTType] { get }

    /// Initialize the reference file document from the contents of a file.
    ///
    /// See ``FileDocumentReadConfiguration`` to learn how to use the configuration parameter.
    ///
    /// In the following example, the required initializer parses the configuration parameter
    /// to pull out the simple text `String` from the document.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### ReferenceFileDocument conformance
    ///
    /// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
    /// - A: ``ReferenceFileDocument/readableContentTypes``
    /// - B: ``ReferenceFileDocument/init(configuration:)``
    /// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
    /// - D: ``ReferenceFileDocument/snapshot(contentType:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     class ExampleDocument: ReferenceFileDocument {
    ///         @Published var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         required init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = snapshot.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///
    ///         // D
    ///         func snapshot(contentType: UTType) throws -> String {
    ///             return text
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject var document: ExampleDocument
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    /// - Parameter configuration: The read-configuration for creating a reference file document.
    init(configuration: Self.ReadConfiguration) throws { }

    /// A type alias for referring to the configuration for reading document contents.
    ///
    /// See ``FileDocumentReadConfiguration`` to learn everything about what this
    /// type alias refers to within the ``ReferenceFileDocument`` protocol.
    ///
    /// This type alias is primarily used in the protocol's required initializer,
    /// ``ReferenceFileDocument/init(configuration:)``
    /// as the type of its configuration parameter.
    typealias ReadConfiguration = FileDocumentReadConfiguration

    /// Creates a snapshot of the current document, which will be
    /// used for serialization, while `self` becomes editable by the user.
    ///
    /// Taking a snapshot of the document is necessary because the data is stored as a reference
    /// type. This means that if a separate snapshot was not taken, the user could potentially edit
    /// the data while it's in the process of being serialized.
    /// See ``ReferenceFileDocument`` for more information on this.
    ///
    /// A `ReferenceFileDocument` blocks edits to the document while it's being saved
    /// until snapshot can be created
    /// Once the snapshot is created, the document becomes editable in parallel
    /// to the snapshot being serialized.
    ///
    /// The following example shows how to use
    /// ``ReferenceFileDocument/snapshot(contentType:)``
    /// along with the rest of the required methods to create a document-based app.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### ReferenceFileDocument conformance
    ///
    /// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
    /// - A: ``ReferenceFileDocument/readableContentTypes``
    /// - B: ``ReferenceFileDocument/init(configuration:)``
    /// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
    /// - D: ``ReferenceFileDocument/snapshot(contentType:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     class ExampleDocument: ReferenceFileDocument {
    ///         @Published var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         required init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = snapshot.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///
    ///         // D
    ///         func snapshot(contentType: UTType) throws -> String {
    ///             return text
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject var document: ExampleDocument
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    /// - Parameter contentType: The content type being written, for which the
    ///   snapshot should be created.
    func snapshot(contentType: UTType) throws -> Self.Snapshot { }

    /// Serializes the document from a snapshot with the specified configuration.
    ///
    /// This is essentially the "saving" function in a reference file document.
    ///
    /// In the following example, the `fileWrapper(snapshot:configuration:)` function
    /// simply uses the snapshot to save a new ``FileWrapper`` object.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### ReferenceFileDocument conformance
    ///
    /// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
    /// - A: ``ReferenceFileDocument/readableContentTypes``
    /// - B: ``ReferenceFileDocument/init(configuration:)``
    /// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
    /// - D: ``ReferenceFileDocument/snapshot(contentType:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     class ExampleDocument: ReferenceFileDocument {
    ///         @Published var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         required init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = snapshot.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///
    ///         // D
    ///         func snapshot(contentType: UTType) throws -> String {
    ///             return text
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject var document: ExampleDocument
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - snapshot: A snapshot of the document with the data to serialize.
    ///   - configuration: The ``FileDocumentWriteConfiguration`` used to serialize the document.
    ///
    /// - Returns: The destination for the serialized the document. It can be a newly created
    /// ``FileWrapper` or an updated ``FileWrapper` from the one provided by `configuration`.
    func fileWrapper(snapshot: Self.Snapshot, configuration: Self.WriteConfiguration) throws -> FileWrapper { }

    /// A type alias used for the configuration when writing a reference file document.
    ///
    /// Since this is just a type alias, see ``FileDocumentWriteConfiguration`` for
    /// full information on what this type does.
    typealias WriteConfiguration = FileDocumentWriteConfiguration
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ReferenceFileDocument {

    /// The types that a reference file document is able to save or export to.
    ///
    /// SwiftUI defaults the value of this to `readableContentTypes`, and it usually doesn't need
    /// to change. In the following example, `writableContentTypes` defaults to
    /// `UTType.exampleText`.
    ///
    /// ### Example
    ///
    /// #### App structure
    ///
    /// To begin, update the scene definition to use ``DocumentGroup``.
    ///
    ///     import SwiftUI
    ///
    ///     @main
    ///     struct ExampleApp: App {
    ///         var body: some Scene {
    ///             DocumentGroup(newDocument: { ExampleDocument() }) { file in
    ///                 ContentView(document: file.document)
    ///             }
    ///         }
    ///     }
    ///
    /// #### ReferenceFileDocument conformance
    ///
    /// Next, conform to the ReferenceFileDocument protocol by implementing these properties:
    /// - A: ``ReferenceFileDocument/readableContentTypes``
    /// - B: ``ReferenceFileDocument/init(configuration:)``
    /// - C: ``ReferenceFileDocument/fileWrapper(snapshot:configuration:)``
    /// - D: ``ReferenceFileDocument/snapshot(contentType:)``
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     class ExampleDocument: ReferenceFileDocument {
    ///         @Published var text: String
    ///
    ///         init(text: String = "This is a brand new document! 📃") {
    ///             self.text = text
    ///         }
    ///
    ///         // A
    ///         static var readableContentTypes: [UTType] { [.exampleText] }
    ///
    ///         // B
    ///         required init(configuration: ReadConfiguration) throws {
    ///             guard let data = configuration.file.regularFileContents,
    ///                 let string = String(data: data, encoding: .utf8)
    ///             else {
    ///                 throw CocoaError(.fileReadCorruptFile)
    ///             }
    ///             text = string
    ///         }
    ///
    ///         // C
    ///         func fileWrapper(snapshot: String, configuration: WriteConfiguration) throws -> FileWrapper {
    ///             let data = snapshot.data(using: .utf8)!
    ///             return .init(regularFileWithContents: data)
    ///         }
    ///
    ///         // D
    ///         func snapshot(contentType: UTType) throws -> String {
    ///             return text
    ///         }
    ///     }
    ///
    /// #### View implementation
    ///
    /// Finally, use the ``TextEditor`` view to edit the document file.
    ///
    ///     import SwiftUI
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject var document: ExampleDocument
    ///         var body: some View {
    ///             TextEditor(text: $document.text)
    ///         }
    ///     }
    ///
    /// #### UTType settings
    ///
    /// In order for any of this to work, your Xcode project will have to define a document type. To do this,
    /// follow these steps:
    /// 1. Go to the Xcode project settings.
    /// 2. Click on your target to the left.
    /// 3. Expand the "Document Types" tab.
    /// 4. Click *"Click here to add additional document type properties"*
    /// 5. Make the **Key** *NSUbiquitousDocumentUserActivityType*.
    /// 6. Ensure the **Type** is *String*.
    /// 7. Make the Value *$(PRODUCT_BUNDLE_IDENTIFIER).example-document*.
    /// 8. Change the **Types** (top right) to *com.example.plain-text*.
    ///
    ///
    /// Lastly, in your *ExampleDocument.swift* file, extend `UTType`:
    ///
    ///     import SwiftUI
    ///     import UniformTypeIdentifiers
    ///
    ///     extension UTType {
    ///         static var exampleText: UTType {
    ///             UTType(importedAs: "com.example.plain-text")
    ///         }
    ///     }
    ///
    public static var writableContentTypes: [UTType] { get }
}

/// The properties of an open reference file document.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ReferenceFileDocumentConfiguration<Document> where Document : ReferenceFileDocument {

    /// The current document model.
    ///
    /// Changes to the document are observed and on change dirty the document
    /// state for resaving. Undo actions are not automatically registered and
    /// need to be done explicitly.
    public var document: Document

    /// A read-only binding to the current document model.
    public var $document: ObservedObject<Document>.Wrapper { get }

    /// The url of the open file document.
    public var fileURL: URL?

    /// Whether the document is able to be edited.
    ///
    /// This can return `false` if the document is in viewing mode or if the
    /// file is unable to be written to.
    public var isEditable: Bool
}

/// A shape with a rotation transform applied to it.
///
/// A rotated shape has two use cases:
/// 1. Used directly via its initializer ``RotatedShape/init(shape:angle:anchor:)``.
/// 2. The return value of ``Shape/rotation(_:anchor:)``.
///
/// Having a rotated shape is helpful because it allows you to rotate a shape
/// and then continue to use its shape properties, instead of turning into ``View``.
///
/// A simple example of constructing a `RotatedShape`:
///
/// ```
/// struct RotatedShapeView: View {
///     var body: some View {
///         RotatedShape(shape: Rectangle(),
///                      angle: .degrees(30))
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct RotatedShape<Content> : Shape where Content : Shape {

	/// The original shape to be rotated.
    ///
    /// ```
    /// struct RotatedShapeView: View {
    ///     let rotatedShape = RotatedShape(shape: Rectangle(),
    ///                                     angle: .degrees(30))
    ///     var body: some View {
    ///         ZStack {
    ///             rotatedShape
    ///             rotatedShape.shape
    ///                 .opacity(0.2)
    ///         }
    ///     }
    /// }
    /// ```
    public var shape: Content

    /// The amount to rotate the original shape.
    ///
    /// ```
    /// struct RotatedShapeView: View {
    ///     let rotatedShape = RotatedShape(shape: Rectangle(),
    ///                                     angle: .degrees(30))
    ///     var body: some View {
    ///         rotatedShape
    ///             .onAppear { print("\(rotatedShape.angle.degrees)º")} //29.999999999999996º
    ///     }
    /// }
    /// ```
    public var angle: Angle

    /// The anchor point to rotate the shape around.
    ///
    /// ```
    /// struct RotatedShapeView: View {
    ///     let rotatedShape = RotatedShape(shape: Rectangle(),
    ///                                     angle: .degrees(30))
    ///     var body: some View {
    ///         rotatedShape
    ///             .onAppear {
    ///                 print(rotatedShape.anchor.x) //0.5
    ///                 print(rotatedShape.anchor.y) //0.5
    ///             }
    ///     }
    /// }
    /// ```
    public var anchor: UnitPoint

    /// Creates a rotated shape from an original shape, an angle, and an anchor point.
    ///
    /// ```
    /// struct RotatedShapeView: View {
    ///     var body: some View {
    ///         RotatedShape(shape: Rectangle(),
    ///                      angle: .degrees(30),
    ///                      anchor: .bottomLeading)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - shape: The original shape to rotate.
    ///   - angle: The angle to rotate the original shape.
    ///   - anchor: The unit point to rotate the shape around.
    @inlinable public init(shape: Content, angle: Angle, anchor: UnitPoint = .center) { }

    /// Describes this shape as a path within a rectangular frame of reference.
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    public func path(in rect: CGRect) -> Path { }

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<Content.AnimatableData, AnimatablePair<Angle.AnimatableData, UnitPoint.AnimatableData>>

    /// The data to animate.
    public var animatableData: RotatedShape<Content>.AnimatableData

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RotatedShape : InsettableShape where Content : InsettableShape {

    /// Returns `self` inset by `amount`.
    @inlinable public func inset(by amount: CGFloat) -> RotatedShape<Content.InsetShape> { }

    /// The type of the inset shape.
    public typealias InsetShape = RotatedShape<Content.InsetShape>
}

/// A gesture that recognizes a rotation motion and tracks the angle of the
/// rotation.
///
/// A rotation gesture tracks how a rotation event sequence changes. To
/// recognize a rotation gesture on a view, create and configure the gesture,
/// and then add it to the view using the `View/gesture(_:including:)`
/// modifier.
///
/// Add a rotation gesture to a `Rectangle` and apply a rotation effect:
///
/// ![RotationGesture Example 1](rotation-gesture-example.gif)
///
///     struct RotationGestureView: View {
///         @State var angle = Angle(degrees: 0.0)
///
///         var rotation: some Gesture {
///             RotationGesture()
///                 .onChanged { angle in
///                     self.angle = angle
///                 }
///         }
///
///         var body: some View {
///             Rectangle()
///                 .frame(width: 200, height: 200, alignment: .center)
///                 .rotationEffect(self.angle)
///                 .gesture(rotation)
///         }
///     }
///
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct RotationGesture : Gesture {

    /// The minimum delta required before the gesture succeeds.
    public var minimumAngleDelta: Angle

    /// Creates a rotation gesture with a minimum delta for the gesture to
    /// start.
    ///
    /// ![RotationGesture Example 2](rotation-gesture-example-2.gif)
    ///
    ///     struct RotationGestureView: View {
    ///         @State var angle = Angle(degrees: 0.0)
    ///
    ///         var rotation: some Gesture {
    ///             RotationGesture(minimumAngleDelta: .degrees(45))
    ///                 .onChanged { angle in
    ///                     self.angle = angle
    ///                 }
    ///         }
    ///
    ///         var body: some View {
    ///             ZStack {
    ///                 Rectangle()
    ///                     .fill(Color.yellow)
    ///                     .frame(width: 200, height: 200, alignment: .center)
    ///                     .rotationEffect(self.angle)
    ///                     .gesture(rotation)
    ///                 Text("Rotate Me")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter minimumAngleDelta: The minimum delta required before the
    ///   gesture starts. The default value is a one-degree angle.
    public init(minimumAngleDelta: Angle = .degrees(1)) { }

    /// The type representing the gesture's value.
    public typealias Value = Angle

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

/// A text field style with a system-defined rounded border.
///
/// `TextField` can be styled with the `View/textFieldStyle(_:)` modifier.
///
/// ![TextField Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TextField-example-2.gif)
///
///     struct ExampleView: View {
///         @State var myFruit: String = ""
///
///         var body: some View {
///             Text(myFruit)
///             TextField("Fruit", text: $myFruit)
///                 .textFieldStyle(RoundedBorderTextFieldStyle())
///                 .padding()
///         }
///     }
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct RoundedBorderTextFieldStyle : TextFieldStyle {

	/// Creates a rounded border text field style.
    public init() { }
}

/// Defines the shape of a rounded rectangle's corners.

/// This style has two options:
/// 1. `roundedcornerstyle/circular`
/// 2. `roundedcornerstyle/circular`
///
/// These styles have subtle but noticeable differences:
///
/// ![RoundedRectangle init example](roundedrectangle-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         VStack(spacing: 20) {
///             RoundedRectangle(cornerRadius: 50, style: .circular)
///                 .frame(width: 250, height: 150)
///
///             RoundedRectangle(cornerRadius: 50, style: .continuous)
///                 .frame(width: 250, height: 150)
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public enum RoundedCornerStyle {

    /// Quarter-circle rounded rect corners.
    case circular

    /// Continuous curvature rounded rect corners.
    case continuous

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: RoundedCornerStyle, b: RoundedCornerStyle) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RoundedCornerStyle : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RoundedCornerStyle : Hashable {
}

/// A rectangle shape with rounded corners.
///
/// A RoundedRectangle is a rectangular `Shape` with rounded corners that by
/// default, aligns itself inside of the view containing it.
///
/// It must be created with a specific corner radius or size.
/// The example below creates a RoundedRectangle with a corner radius of 20,
/// and uses the `Shape/fill()` and `View/frame(width:height:)` modifiers
/// to set the color to blue and the frame to 250 by 150.
///
/// ![RoundedRectangle corner radius, fill, and frame example](roundedrectangle-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         RoundedRectangle(cornerRadius: 20)
///             .fill(Color.blue)
///             .frame(width: 250, height: 150)
///     }
/// }
/// ```
///
/// The example below uses the same modifiers, but defines a corner size
/// rather than a corner radius.
///
/// ![RoundedRectangle corner size, fill, and frame example](roundedrectangle-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         RoundedRectangle(cornerSize: CGSize(width: 30, height: 10))
///             .fill(Color.blue)
///             .frame(width: 250, height: 150)
///     }
/// }
/// ```
///
/// The RoundedRectangle initializer includes an optional parameter for
/// specifying the `style`, a `RoundedCornerStyle` that can either be `circular`
/// or `continuous`. These styles have subtle but noticeable differences:
///
/// ![RoundedRectangle init example](roundedrectangle-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         VStack(spacing: 20) {
///             RoundedRectangle(cornerRadius: 50, style: .circular)
///                 .frame(width: 250, height: 150)
///
///             RoundedRectangle(cornerRadius: 50, style: .continuous)
///                 .frame(width: 250, height: 150)
///         }
///     }
/// }
/// ```
///
/// To add a border, use the `Shape/stroke(:lineWidth:)` modifier, and use
/// the `RoundedRectangle/inset(by:)` modifier to inset the RoundedRectangle by
/// half of the border width to keep the RoundedRectangle at its original size:
///
/// ![RoundedRectangle inset and stroke example](roundedrectangle-example-4.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         RoundedRectangle(cornerRadius: 40)
///             .inset(by: 10)
///             .stroke(Color.blue, lineWidth: 20)
///             .frame(width: 250, height: 150)
///     }
/// }
/// ```
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct RoundedRectangle : Shape {

	/// The rounded corner size of the rounded rectangle shape.
	///
	/// This would be used instead of corner radius when you want your corners
	/// not to be perfect quarter-circles but instead quarter-ellipses.
	/// Basically, this allows you to specify different width and heights of
	/// the corners.
    ///
    /// ![RoundedRectangle cornerSize example](roundedrectangle-example-6.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack(spacing: 20) {
    ///             RoundedRectangle(cornerSize: CGSize(width: 30, height: 20))
    ///                 .frame(width: 250, height: 150)
    ///
    ///             RoundedRectangle(cornerSize: CGSize(width: 20, height: 40))
    ///                 .frame(width: 250, height: 150)
    ///         }
    ///     }
    /// }
    /// ```
    public var cornerSize: CGSize

    /// The rounded corner style of your rounded rectangle's corners.
    ///
    /// These styles have subtle but noticeable differences:
    ///
    /// ![RoundedRectangle init example](roundedrectangle-example-3.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack(spacing: 20) {
    ///             RoundedRectangle(cornerRadius: 50, style: .circular)
    ///                 .frame(width: 250, height: 150)
    ///
    ///             RoundedRectangle(cornerRadius: 50, style: .continuous)
    ///                 .frame(width: 250, height: 150)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// -SeeAlso: RoundedCornerStyle
    public var style: RoundedCornerStyle

    /// Creates a RoundedRectangle with specified rounded corner width and height.
    ///
    /// - Parameters:
    ///   - cornerSize: The size (width and height) of the rectangle's corners.
    ///   - style: The type of rounded corners. Defaults to circular.
    ///
    /// ![RoundedRectangle init with cornerSize example](roundedrectangle-example-3.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack(spacing: 20) {
    ///             RoundedRectangle(
    ///                 cornerSize: CGSize(width: 20, height: 10)
    ///             )
    ///             .frame(width: 250, height: 150)
    ///
    ///             RoundedRectangle(
    ///                 cornerSize: CGSize(width: 20, height: 10),
    ///                 style: .continuous
    ///             )
    ///             .frame(width: 250, height: 150)
    ///         }
    ///     }
    /// }
    /// ```
    @inlinable public init(cornerSize: CGSize, style: RoundedCornerStyle = .circular) { }

    /// Creates a RoundedRectangle with specified rounded corner radius.
    ///
    /// - Parameters:
    ///   - cornerRadius: The radius of the rectangle's corners.
    ///   - style: The type of rounded corners. Defaults to circular.
    ///
    /// ![RoundedRectangle init with cornerRadius example](roundedrectangle-example-3.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack(spacing: 20) {
    ///             RoundedRectangle(cornerRadius: 50) // Style defaults to circular
    ///                 .frame(width: 250, height: 150)
    ///
    ///             RoundedRectangle(cornerRadius: 50, style: .continuous)
    ///                 .frame(width: 250, height: 150)
    ///         }
    ///     }
    /// }
    /// ```
    @inlinable public init(cornerRadius: CGFloat, style: RoundedCornerStyle = .circular) { }

    /// Used to describe a RoundedRectangle as a path in a `CGRect`.
    ///
    /// A RoundedRectangle can be described as a path within a specific `CGRect`
    /// using the `RoundedRectangle/path(in:)` modifier:
    ///
    /// ![RoundedRectangle path example](roundedrectangle-example-7.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         RoundedRectangle()
    ///             .path(in: CGRect(x: 0, y: 0, width: 75, height: 200))
    ///     }
    /// }
    /// ```
    public func path(in rect: CGRect) -> Path { }

    /// > The data to animate.
    public var animatableData: CGSize.AnimatableData

    /// > The type defining the data to animate.
    public typealias AnimatableData = CGSize.AnimatableData

    /// > The type of view representing the body of this view.
    ///
    /// > When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RoundedRectangle : InsettableShape {

    /// Returns a RoundedRectangle insetted by the amount specified. For
    /// example, insetting by 10 points returns a Capsule that fills its
    /// container, with 10 points inset on all four side.
    ///
    /// ![RoundedRectangle inset example](roundedrectangle-example-8.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 20)
    ///             .inset(by: 10)
    ///     }
    /// }
    /// ```
    @inlinable public func inset(by amount: CGFloat) -> some InsettableShape { }


    /// > The type of the inset shape.
    public typealias InsetShape = some InsettableShape
}

/// A set of symbolic safe area regions.
///
/// Use this option set with the ``View/ignoresSafeArea(_:edges:)``
/// view modifier to specify which edges of a view
/// should ignore which safe areas.
///
/// Safe area options:
/// - ``SafeAreaRegions/container``: The top and bottom safe portions of the
/// screen, like the status bar.
/// - ``SafeAreaRegions/keyboard``: The portion of the screen covered by
/// a software keyboard
///
/// ```
/// struct SafeAreaIgnoringView: View {
///     var body: some View {
///         ZStack {
///             Color.pink
///             Text("I am everywhere (except the software keyboard)")
///         }
///         .ignoresSafeArea(SafeAreaRegions.container, edges: [.top, .bottom])
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public struct SafeAreaRegions : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// Don't use this directly. Rather, use the static constants of this type,
    /// ``SafeAreaRegions/keyboard``,
    /// ``SafeAreaRegions/container``,
    /// ``SafeAreaRegions/all``.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: UInt

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    @inlinable public init(rawValue: UInt) { }

    /// The safe area defined by the device and containers within the
    /// user interface, including elements such as top and bottom bars.
    ///
    /// ```
    /// struct SafeAreaIgnoringView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Color.pink
    ///             Text("I am everywhere (except the software keyboard)")
    ///         }
    ///         .ignoresSafeArea(.container, edges: [.top, .bottom])
    ///     }
    /// }
    /// ```
    public static let container: SafeAreaRegions

    /// The safe area matching the current extent of any software
    /// keyboard displayed over the view content.
    ///
    /// ```
    /// struct SafeAreaIgnoringView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Color.pink
    ///             Text("I am over the keyboard!")
    ///         }
    ///         .ignoresSafeArea(.keyboard, edges: [.top, .bottom])
    ///     }
    /// }
    /// ```
    public static let keyboard: SafeAreaRegions

    /// All safe area regions.
    ///
    /// ```
    /// struct SafeAreaIgnoringView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Color.pink
    ///             Text("I am everywhere 🤠")
    ///         }
    ///         .ignoresSafeArea(.all, edges: [.top, .bottom])
    ///     }
    /// }
    /// ```
    public static let all: SafeAreaRegions

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = SafeAreaRegions

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = SafeAreaRegions

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = UInt
}

/// A dynamic property that scales a numeric value.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@propertyWrapper public struct ScaledMetric<Value> : DynamicProperty where Value : BinaryFloatingPoint {

    /// Creates the scaled metric with an unscaled value and a text style to
    /// scale relative to.
    public init(wrappedValue: Value, relativeTo textStyle: Font.TextStyle) { }

    /// Creates the scaled metric with an unscaled value using the default
    /// scaling.
    public init(wrappedValue: Value) { }

    /// The value scaled based on the current environment.
    public var wrappedValue: Value { get }
}

/// A shape with a scale transform applied to it.
///
/// A scaled shape has two use cases:
/// 1. Used directly via its initializer ``ScaledShape/init(shape:scale:anchor:)``.
/// 2. The return value of the ``Shape/scale(x:y:anchor:)`` and
/// ``Shape/scale(_:anchor:)``.
///
/// Having a scaled shape is helpful because it allows you to scale a shape
/// and then continue to use its shape properties, instead of turning into ``View``.
///
/// A simple example of constructing a `ScaledShape`:
///
/// ```
/// struct HugeShapeView: View {
///     var body: some View {
///         ScaledShape(shape: Circle(),
///                     scale: CGSize(width: 2, height: 2))
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ScaledShape<Content> : Shape where Content : Shape {

	/// The original shape, before the scale.
    ///
    /// ```
    /// struct DiskView: View {
    ///     let scaledShape = ScaledShape(shape: Circle(),
    ///                                   size: CGSize(width: 2, height: 2)
    ///     var body: some View {
    ///         ZStack {
    ///             scaledShape
    ///             scaledShape.shape.fill(Color.red)
    ///         }
    ///     }
    /// }
    /// ```
    public var shape: Content

    /// The scale factor.
    ///
    /// ```
    /// struct HugeShapeView: View {
    ///     let scaledShape = ScaledShape(shape: Circle(),
    ///                                   size: CGSize(width: 2, height: 2)
    ///     var body: some View {
    ///         scaledShape
    ///             .onAppear {
    ///                 print("↔️ scaled by \(scaledShape.width)")
    ///                 print("↕️ scaled by \(scaledShape.height)")
    ///             }
    ///     }
    /// }
    /// ```
    public var scale: CGSize

    /// The unit point to scale the view from.
    ///
    /// ```
    /// struct HugeShapeView: View {
    ///     let scaledShape = ScaledShape(shape: Circle(),
    ///                                   size: CGSize(width: 2, height: 2)
    ///     var body: some View {
    ///         scaledShape
    ///             .onAppear {
    ///                 print("Anchored at (\(anchor.x), \(anchor.y))") // "(0.5, 0.5)"
    ///             }
    ///     }
    /// }
    /// ```
    public var anchor: UnitPoint

    /// Creates a scaled shape from an original shape, a scale factor, and an anchor point.
    ///
    /// ```
    /// struct HugeShapeView: View {
    ///     var body: some View {
    ///         ScaledShape(shape: Circle(),
    ///                     scale: CGSize(width: 2, height: 2),
    ///                     anchor: .center)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - shape: The shape to be scaled.
    ///   - scale: The factor to scale the shape.
    ///   - anchor: The unit point to scale the shape from. Defaults to the center.
    @inlinable public init(shape: Content, scale: CGSize, anchor: UnitPoint = .center) { }

    /// Describes this shape as a path within a rectangular frame of reference.
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    public func path(in rect: CGRect) -> Path { }

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<Content.AnimatableData, AnimatablePair<CGSize.AnimatableData, UnitPoint.AnimatableData>>

    /// The data to animate.
    public var animatableData: ScaledShape<Content>.AnimatableData

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

/// This protocol is used to create different content areas on the screen.
///
/// On-screen `Scene`s are the building blocks of any app built entirely in SwiftUI. They can look
/// different depending on the platform the app is running on. For example, in iOS, the screen usually
/// only displays one scene at a time. In macOS, every window in an app might be a different scene.
///
/// Scenes can either be custom, or one of the primitives like `WindowGroup` or
/// `DocumentGroup`.
///
/// ### Creating a Scene
///
/// #### Using primitive Scenes
///
/// Primitive scenes like `WindowGroup` can go directly in the body of your `App`.
///
/// ![Scene Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Scene-example-1.png)
///
///     @main
///     struct SuperSimpleApp: App {
///         var body: some Scene {
///             WindowGroup {
///                 Text("This is an entire app! 🙌")
///             }
///         }
///     }
///
/// #### Using custom Scenes
///
/// Just like how custom `View`s are made out of a `var body` of smaller  `View`s,
/// custom `Scene`s are made out of a `var body` of smaller `Scene`s.
///
/// ![Scene Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Scene-example-2.png)
///
///     @main
///     struct MacCompatibleApp: App {
///         var body: some Scene {
///             CustomScene()
///         }
///
///     struct CustomScene: Scene {
///         var body: some Scene {
///             WindowGroup {
///                 Text("This is a mac-compatible app! 💻")
///             }
///
///             #if os(macOS)
///             Settings {
///                 SettingsView()
///             }
///             #endif
///         }
///     }
///
/// ### Modifiers
///
/// Just like how `Views` have a bunch of custom modifiers that work right out of the box,
/// `Scene` provides default implementations of many useful modifiers. These can be used to do things
/// like adding macOS commands, changing the toolbar, and adding support for app storage.
/// [scene-phase ->]
/// ### Getting Scene Status
///
/// The `EnvironmentValues/scenePhase` environment value can easily be read in a scene
/// to respond to whether the scene is active or in another state. It returns an enumeration of type
/// `ScenePhase`.
///
///     struct StateAdaptingScene: Scene {
///         @Environment(\.scenePhase) private var scenePhase
///         var body: some Scene {
///             WindowGroup {
///                 Text(scenePhase == .active ? "Active!" : "Inactive")
///             }
///         }
///     }
///
/// [<-]
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol Scene{ }
extension Scene {

    /// The type of the body variable in a scene.
    ///
    /// This type is automatically inferred from the `Scene/body-swift.variable` variable
    /// when you make a custom Scene, so you don't have to worry about ever interacting with this
    /// directly.
    ///
    /// If you're using a primitive scene like `WindowGroup`, you might wonder what the body
    /// type would be. If all scenes are built on scenes built on scenes, where does it start?
    ///
    /// Because of exactly that reason, all primitive Scene types set their body type to `Never`.
    ///
    associatedtype Body : Scene

    /// The entry point for building custom Scenes.
    ///
    /// This computed property is the only requirement of conforming to the Scene protocol.
    /// To make a custom Scene, compose `body` with other custom Scenes, or
    /// with primitive Scenes like `WindowGroup` or `Settings`.
    ///
    ///     @main
    ///     struct MacCompatibleApp: App {
    ///         var body: some Scene {
    ///             CustomScene()
    ///         }
    ///
    ///     struct CustomScene: Scene {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 Text("This is a mac-compatible app! 💻")
    ///             }
    ///
    ///             #if os(macOS)
    ///             Settings {
    ///                 SettingsView()
    ///             }
    ///             #endif
    ///         }
    ///     }
    @SceneBuilder var body: Self.Body { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Scene {

    /// Use this method to watch for changes in a variable value.
    ///
    /// This method is most often used to watch for changes in a scene's status (active, inactive, etc.)
    ///
    /// There is a different, but related, method called `View/onChange(of:perform:)` that
    /// can be used on `Views`.
    ///
    ///     struct CustomScene: Scene {
    ///         @Environment(\.scenePhase) private var scenePhase
    ///         @State private var count = 0
    ///
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 Text("If you're seeing this active was printed.")
    ///             }
    ///             .onChange(of: scenePhase) { newScenePhase in
    ///                 if newScenePhase == .active {
    ///                     print("Active!")
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - value: The value to watch for changes.
    ///   - action: A function to run when the value changes.
    ///
    /// - Returns: A scene that calls a function when a value changes.
    @inlinable public func onChange<V>(of value: V, perform action: @escaping (V) -> Void) -> some Scene where V : Equatable { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Use this modifier to add a menu and keyboard shortcuts to your macOS and iPadOS apps.
    ///
    /// This modifier accepts a builder of `Commands` to create a menu bar with shortcuts.
    ///
    /// In macOS, these commands are visible in the menu bar at the top of the screen. On iPadOS,
    /// these commands are visible when you hold down the Command (⌘) key.
    ///
    /// See `Commands` for more info on how to build these commands.
    ///
    ///     @main
    ///     struct CommandApp: App {
    ///         WindowGroup {
    ///             Text("Press ⌘P to print 🍌")
    ///         }
    ///         .commands { PrintCommand() }
    ///     }
    ///
    ///     struct PrintCommand: Commands {
    ///         var body: some Commands {
    ///             CommandMenu("Print") {
    ///                 Button("Print", action: { print("🍌") })
    ///                     .keyboardShortcut(KeyboardShortcut(KeyEquivalent("p"), modifiers: [.command]))
    ///             }
    ///         }
    ///     }
    ///
    /// [[window-commands]]
    ///
    /// - Parameter content: The command menus to add to your scene.
    ///
    /// - Returns: A scene with command menus and shortcuts.
    public func commands<Content>(@CommandsBuilder content: () -> Content) -> some Scene where Content : Commands { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Scene {

    /// Use this modifier to change a scene's default storage for the @AppStorage property wrapper.
    ///
    /// Whenever the @AppStorage property wrapper is used, it defaults its location to
    /// `UserDefaults.standard`. Override this default location for all of your
    /// scene's views by using this modifier.
    ///
    /// There is a similar method for `View` called `View/defaultAppStorage(_:)`
    ///
    /// Check out `UserDefaults` and `AppStorage` for more info on how in-app storage
    /// works.
    ///
    ///     @main
    ///     struct StorageExampleApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 StorageExampleView()
    ///             }
    ///             .defaultAppStorage(UserDefaults(suiteName: "com.yoursite.your-suite")!)
    ///         }
    ///     }
    ///
    ///     struct StorageExampleView: View {
    ///         //Looks for "key" in "com.yoursite.your-suite"
    ///         @AppStorage("key") var name = "Kanye West"
    ///
    ///         var body: some View {
    ///             TextField("Enter your name", text: $name)
    ///         }
    ///     }
    ///
    /// - Parameter store: The default user defaults storage site for `@AppStorage`.
    public func defaultAppStorage(_ store: UserDefaults) -> some Scene { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Scene {

    /// Specifies a modifier to indicate if this Scene can be used
    /// when creating a new Scene for the received External Event.
    ///
    /// This modifier is only supported for WindowGroup Scene types.
    ///
    /// For DocumentGroups, the received External Event must have a URL
    /// for the DocumentGroup to be considered. (Either via openURL, or
    /// the webPageURL property of an NSUserActivity). The UTI for the URL
    /// is implicitly matched against the DocumentGroup's supported types.
    ///
    /// If the modifier evaluates to true, an instance of the
    /// Scene will be used.
    ///
    /// If the modifier evaluates to false, on macOS the Scene
    /// will not be used even if no other Scenes are available.
    /// This case is considered an error. On iOS, the first Scene
    /// specified in the body property for the App will be used.
    ///
    /// If no modifier is set, the Scene will be used if all
    /// other WindowGroups with a modifier evaluate to false.
    ///
    /// On platforms that only allow a single Window/Scene, this method is
    /// ignored.
    ///
    ///     @main
    ///     struct EventHandlingApp: App {
    ///         var body: some Scene {
    ///             WindowGroup {
    ///                 SelectionView()
    ///             }
    ///             .handlesExternalEvents(matching: ["selection"]
    ///         }
    ///     }
    ///
    /// - Parameter matching: A Set of Strings that are checked to see
    /// if they are contained in the targetContentIdenfifier. The empty Set
    /// and empty Strings never match. The String value "*" always matches.
    public func handlesExternalEvents(matching conditions: Set<String>) -> some Scene { }

}

/// A function builder for composing a collection of scenes into a single
/// composite scene.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_functionBuilder public struct SceneBuilder {

    /// Passes a single scene written as a child scene through unmodified.
    public static func buildBlock<Content>(_ content: Content) -> Content where Content : Scene { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes two scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some Scene where C0 : Scene, C1 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes three scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes four scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene, C3 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes five scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene, C3 : Scene, C4 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes six scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene, C3 : Scene, C4 : Scene, C5 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes seven scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene, C3 : Scene, C4 : Scene, C5 : Scene, C6 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes eight scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene, C3 : Scene, C4 : Scene, C5 : Scene, C6 : Scene, C7 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes nine scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene, C3 : Scene, C4 : Scene, C5 : Scene, C6 : Scene, C7 : Scene, C8 : Scene { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneBuilder {

    /// Passes ten scenes written as children scenes through unmodified.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some Scene where C0 : Scene, C1 : Scene, C2 : Scene, C3 : Scene, C4 : Scene, C5 : Scene, C6 : Scene, C7 : Scene, C8 : Scene, C9 : Scene { }

}

/// An indication of a scene's operational state.
///
/// [[scene-phase]]
///
/// ### More
///
/// The system moves your app's `Scene` instances through phases that reflect
/// a scene's operational state. You can trigger actions when the phase changes.
/// Read the current phase by observing the `EnvironmentValues/scenePhase`
/// value in the `Environment`:
///
///     @Environment(\.scenePhase) private var scenePhase
///
/// How you interpret the value depends on where it's read from.
/// If you read the phase from inside a `View` instance, you obtain a value
/// that reflects the phase of the scene that contains the view. The following
/// example uses the `SwiftUI/View/onChange(of:perform:)` method to enable
/// a timer whenever the enclosing scene enters the `ScenePhase/active` phase
/// and disable the timer when entering any other phase:
///
///     struct MyView: View {
///         @ObservedObject var model: DataModel
///         @Environment(\.scenePhase) private var scenePhase
///
///         var body: some View {
///             TimerView()
///                 .onChange(of: scenePhase) { phase in
///                     model.isTimerRunning = (phase == .active)
///                 }
///         }
///     }
///
/// If you read the phase from within an `App` instance, you obtain an
/// aggregate value that reflects the phases of all the scenes in your app. The
/// app reports a value of `ScenePhase/active` if any scene is active, or a
/// value of `ScenePhase/inactive` when no scenes are active. This includes
/// multiple scene instances created from a single scene declaration; for
/// example, from a `WindowGroup`. When an app enters the
/// `ScenePhase/background` phase, expect the app to terminate soon after.
/// You can use that opportunity to free any resources:
///
///     @main
///     struct MyApp: App {
///         @Environment(\.scenePhase) private var scenePhase
///
///         var body: some Scene {
///             WindowGroup {
///                 MyRootView()
///             }
///             .onChange(of: scenePhase) { phase in
///                 if phase == .background {
///                     // Perform cleanup when all scenes within
///                     // MyApp go to the background.
///                 }
///             }
///         }
///     }
///
/// If you read the phase from within a custom `Scene` instance, the value
/// similarly reflects an aggregation of all the scenes that make up the custom
/// scene:
///
///     struct MyScene: Scene {
///         @Environment(\.scenePhase) private var scenePhase
///
///         var body: some Scene {
///             WindowGroup {
///                 MyRootView()
///             }
///             .onChange(of: scenePhase) { phase in
///                 if phase == .background {
///                     // Perform cleanup when all scenes within
///                     // MyScene go to the background.
///                 }
///             }
///         }
///     }
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public enum ScenePhase : Comparable {

    /// The scene isn't currently visible in the UI.
    ///
    /// Do as little as possible in a scene that's in the `background` phase.
    /// The `background` phase can precede termination, so do any cleanup work
    /// immediately upon entering this state. For example, close any open files
    /// and network connections. However, a scene can also return to the
    /// the `ScenePhase/active` phase from the background.
    ///
    /// Expect an app that enters the `background` phase to terminate.
    case background

    /// The scene is in the foreground but should pause its work.
    ///
    /// A scene in this phase doesn't receive events and should pause
    /// timers and free any unnecessary resources. The scene might be completely
    /// hidden in the user interface or otherwise unavailable to the user.
    /// In macOS, scenes only pass through this phase temporarily on their way
    /// to the `ScenePhase/background` phase.
    ///
    /// An app or custom scene in this phase contains no scene instances in the
    /// `ScenePhase/active` phase.
    case inactive

    /// The scene is in the foreground and interactive.
    ///
    /// An active scene isn't necessarily front-most. For example, a macOS
    /// window might be active even if it doesn't currently have focus.
    /// Nevertheless, all scenes should operate normally in this phase.
    ///
    /// An app or custom scene in this phase contains at least one active scene
    /// instance.
    case active

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ScenePhase, b: ScenePhase) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (a: ScenePhase, b: ScenePhase) -> Bool { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ScenePhase : Hashable {
}

/// A property wrapper type that reads and writes to persisted, per-scene
/// storage.
///
/// You use `SceneStorage` when you need automatic state restoration of the
/// value.  `SceneStorage` works very similar to `State`, except its initial
/// value is restored by the system if it was previously saved, and the value is·
/// shared with other `SceneStorage` variables in the same scene.
///
/// The system manages the saving and restoring of `SceneStorage` on your
/// behalf. The underlying data that backs `SceneStorage` is not available to
/// you, so you must access it via the `SceneStorage` property wrapper. The
/// system makes no guarantees as to when and how often the data will be
/// persisted.
///
/// Each `Scene` has its own notion of `SceneStorage`, so data is not shared
/// between scenes.
///
/// Ensure that the data you use with `SceneStorage` is lightweight. Data of a
/// large size, such as model data, should not be stored in `SceneStorage`, as
/// poor performance may result.
///
/// If the `Scene` is explictly destroyed (e.g. the switcher snapshot is
/// destroyed on iPadOS or the window is closed on macOS), the data is also
/// destroyed. Do not use `SceneStorage` with sensitive data.
///
/// If you would like your data to be stored permanently in the device,
/// use ``AppStorage`` instead.
///
/// There are 6 possible scene storage types, and 6 corresponding initializers:
/// 1. `Bool`
/// 2. `Int`
/// 3. `Double`
/// 4. `String`
/// 5. `URL`
/// 6. `Data`
///
/// Here is a simple example using the common property wrapper syntax:
///
///     struct ContentView: View {
/// 		@Scenestorage("name") private var name = "Javier"
///
/// 		var body: some View {
/// 			TextField(name, text: $name)
/// 		}
/// 	}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen @propertyWrapper public struct SceneStorage<Value> : DynamicProperty {

    /// The underlying value referenced by the state variable.
    ///
    /// This works identically to `State.wrappedValue`.
    ///
    /// This is rarely used directly. Instead, you normally use the property wrapper syntax:
	///
	///     struct ContentView: View {
    /// 		@SceneStorage("name") var name: String = "Javier"
    ///
    /// 		var body: some View {
    /// 			TextField(name, text: $name)
    /// 		}
    /// 	}
    ///
    /// - SeeAlso: State.wrappedValue
    public var wrappedValue: Value { get nonmutating set }

    /// A binding to the state value.
    ///
    /// This works identically to `State.projectedValue`.
    ///
    /// You can access this using the $ prefix:
    ///
    /// 	struct ContentView: View {
    /// 		@SceneStorage("name") var name: String = "Javier"
    ///
    /// 		var body: some View {
    /// 			TextField(name, text: $name)
    /// 		}
    /// 	}
    ///
    /// - SeeAlso: State.projectedValue
    public var projectedValue: Binding<Value> { get }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneStorage {

    /// Creates a property that can save and restore a boolean.
    ///
    /// 	struct ContentView: View {
    /// 		@SceneStorage("airplane-mode") var on: Bool = false
    ///
    /// 		var body: some View {
    /// 			Toggle("Airplane Mode", isOn: $on)
    /// 		}
    /// 	}
    ///
    /// - Parameter wrappedValue: The default value if a boolean is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Bool { }

    /// Creates a property that can save and restore an integer.
    ///
    /// 	struct ContentView: View {
    /// 		@SceneStorage("donuts") var count: Int = 0
    ///
    /// 		var body: some View {
    /// 			Stepper("🍩 count: \(count)", value: $count)
    /// 		}
    /// 	}
    ///
    /// - Parameter wrappedValue: The default value if an integer is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Int { }

    /// Creates a property that can save and restore a double.
    ///
    /// 	struct ContentView: View {
    /// 		@AppStorage("brightness") var level: Double = 0
    ///
    /// 		var body: some View {
    /// 			Text("🔆 \(level)")
    ///             Slider(value: $level)
    /// 		}
    /// 	}
    ///
    /// - Parameter wrappedValue: The default value if a double is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Double { }

    /// Creates a property that can save and restore a string.
    ///
    ///     struct ContentView: View {
    /// 		@SceneStorage("name") var name: String = "Javier"
    ///
    /// 		var body: some View {
    /// 			TextField(name, text: $name)
    /// 		}
    /// 	}
    ///
    /// - Parameter wrappedValue: The default value if a string is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == String { }

    /// Creates a property that can save and restore a URL.
    ///
    ///     struct ContentView: View {
    /// 		@SceneStorage("site") var url = URL(string: "bananadocs.org")!
    ///
    /// 		var body: some View {
    /// 			Text("Check out \(url)")
    /// 		}
    /// 	}
    ///
    /// - Parameter wrappedValue: The default value if a URL is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == URL { }

    /// Creates a property that can save and restore data.
    ///
    ///     struct Human: Codable {
    ///         var name: String
    ///         var age: Int
    ///     }
    ///
    //      struct ContentView: View {
    ///         @SceneStorage("goat") var person = Data()
    ///
    ///         var body: some View {
    ///             Button("Make Aaron the 🐐") {
    ///                 let aaron = Human(name: "Aaron", age: 21)
    ///                 let aaronData = try! JSONEncoder().encode(aaron)
    ///
    ///                 person = aaronData
    ///                 print("success.")
    ///             }
    ///         }
    ///     }
    ///
    /// Avoid storing large data blobs, such as image data, as it can negatively
    /// affect performance of your app.
    ///
    /// - Parameter wrappedValue: The default value if data is not available
    ///   for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value == Data { }

    /// Creates a property that can save and restore an integer, transforming it
    /// to a `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///    enum MyEnum: Int {
    ///        case a
    ///        case b
    ///        case c
    ///    }
    ///    struct MyView: View {
    ///        @SceneStorage("MyEnumValue") private var value = MyEnum.a
    ///
    ///        var body: some View {
    ///             Picker("Choose!", selection: $value) {
    ///                 Text("a").tag(MyEnum.a)
    ///                 Text("b").tag(MyEnum.b)
    ///                 Text("c").tag(MyEnum.c)
    ///             }
    ///         }
    ///    }
    ///
    /// - Parameter wrappedValue: The default value if an integer value is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value : RawRepresentable, Value.RawValue == Int { }

    /// Creates a property that can save and restore a string, transforming it
    /// to a `RawRepresentable` data type.
    ///
    /// A common usage is with enumerations:
    ///
    ///    enum MyEnum: String {
    ///        case a
    ///        case b
    ///        case c
    ///    }
    ///    struct MyView: View {
    ///        @AppStorage("MyEnumValue") private var value = MyEnum.a
    ///
    ///        var body: some View {
    ///             Picker("Choose!", selection: $value) {
    ///                 Text("a").tag(MyEnum.a)
    ///                 Text("b").tag(MyEnum.b)
    ///                 Text("c").tag(MyEnum.c)
    ///             }
    ///         }
    ///    }
    ///
    /// - Parameter wrappedValue: The default value if a String value is not
    ///   available for the given key.
    /// - Parameter key: a key used to save and restore the value.
    public init(wrappedValue: Value, _ key: String) where Value : RawRepresentable, Value.RawValue == String { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SceneStorage where Value : ExpressibleByNilLiteral {

    /// Creates a property that can save and restore an Optional boolean.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// 	struct ContentView: View {
    /// 		@SceneStorage("airplane-mode") var on: Bool?
    ///
    /// 		var body: some View {
    /// 			Button("on") { on = true }
    ///             Button("off") { on = false }
    /// 		}
    /// 	}
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Bool? { }

    /// Creates a property that can save and restore an Optional integer.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// 	struct ContentView: View {
    /// 		@SceneStorage("donuts") var count: Int?
    ///
    /// 		var body: some View {
    /// 			Button("none ☹️") { count = 0 }
    ///             Button("LOTS 🍩") { count = 100 }
    /// 		}
    /// 	}
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Int? { }

    /// Creates a property that can save and restore an Optional double.
    ///
    /// Defaults to nil if there is no restored value
    ///
    /// 	struct ContentView: View {
    /// 		@SceneStorage("brightness") var level: Double?
    ///
    /// 		var body: some View {
    /// 			Button("MAX 🔆") { level = 1.0 }
    ///             Button("min 🔅") { level = 0.0 }
    /// 		}
    /// 	}
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Double? { }

    /// Creates a property that can save and restore an Optional string.
    ///
    /// Defaults to nil if there is no restored value
    ///
    ///     struct ContentView: View {
    /// 		@SceneStorage("name") var name: String?
    ///
    /// 		var body: some View {
    /// 			Button("Save 🐐") { name = "Javier" }
    /// 		}
    /// 	}
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == String? { }

    /// Creates a property that can save and restore an Optional URL.
    ///
    /// Defaults to nil if there is no restored value
    ///
    ///     struct ContentView: View {
    /// 		@SceneStorage("site") var url: URL?
    ///
    /// 		var body: some View {
    /// 			Text("Save the 🍌") { url = URL(string: "bananadocs.org" }
    /// 		}
    /// 	}
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == URL? { }

    /// Creates a property that can save and restore an Optional data.
    ///
    /// Defaults to nil if there is no restored value
    ///
    ///     struct Human: Codable {
    ///         var name: String
    ///         var age: Int
    ///     }
    ///
    //      struct ContentView: View {
    ///         @SceneStorage("goat") var person: Data?
    ///
    ///         var body: some View {
    ///             Button("Make Aaron the 🐐") {
    ///                 let aaron = Human(name: "Aaron", age: 21)
    ///                 let aaronData = try! JSONEncoder().encode(aaron)
    ///
    ///                 person = aaronData
    ///                 print("success.")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter key: a key used to save and restore the value.
    public init(_ key: String) where Value == Data? { }
}


/// A view that scrolls.
///
/// A view that allows the scrolling of its contained views.
///
/// ### Making a view scrollable
///
/// `ScrollView` is a container view that makes its content scrollable. For example:
///
///  ![ScrollView Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ScrollView {
///             VStack {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍏🍏")
///                 Text("Peaches 🍑🍑")
///             }
///         }
///     }
/// }
/// ```
///
/// In this example, the `VStack` containing the text is made scrollable by wrapping it in a `ScrollView`.
///
/// Note:
///
/// - The content of a `ScrollView` is scrollable regardless of whether all of it fits on screen or not.
/// - It is not possible to selectively disable the scrolling of a `ScrollView`, while allowing its content to remain interactive. A `View/disabled(_:)` attached to a `ScrollView` will disable both the scrolling and all the interaction with the content visible.
/// - A `ScrollView`'s scrollable region is sized to fit the content view passed to the `ScrollView`.
/// - `ScrollView` fits to occupy as much space as possible. It is important to distinguish between the actual bounds of the scroll view, and the bounds of the *content* of the `ScrollView`.
/// [scrollview-axis ->]
/// ### Setting the direction of scrolling
///
/// The default scrolling direction of a `ScrollView` is **vertical**. `ScrollView` supports 3 types of scrolling:
///
/// - vertical
/// - horizontal
/// - both vertical and horizontal
///
/// To set a single allowed direction for a `ScrollView`, specify the axis of direction in the initializer. For example:
///
///  ![ScrollView Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-2.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ScrollView(.horizontal) {
///             VStack {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍏🍏")
///                 Text("Peaches 🍑🍑")
///             }
///         }
///     }
/// }
/// ```
/// [<-]
/// This example takes the previous example, and modifies it so that the `ScrollView` scrolls horizontally. This `ScrollView` will **not** scroll vertically, as an explict axis, `.horizontal`, has been specified.
///
/// To allow *both* directions of scrolling, pass the set of axes that you want to permit. For example:
///
///  ![ScrollView Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-3.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ScrollView([.horizontal, .vertical]) {
///             VStack {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍏🍏")
///                 Text("Peaches 🍑🍑")
///             }
///         }
///     }
/// }
/// ```
///
/// In this example, `ScrollView` can scroll both horizontally *and* vertically, because both axes have been specified explicitly.
/// [scrollview-hide-indicators ->]
/// ### Hiding the scroll view indicator
///
/// By default, a `ScrollView`'s scroll indicator is visible upon user interaction.
///
/// Pass `false` to `showsIndicators` in `ScrollView/init(_:showsIndicators:content)` to hide the scroll indicator(s). For example:
///
///  ![ScrollView Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-4.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ScrollView(.horizontal, showsIndicators: false) {
///             VStack {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍏🍏")
///                 Text("Peaches 🍑🍑")
///             }
///         }
///     }
/// }
/// ```
///
/// This `ScrollView` will never show a scroll indicator.
///
/// You do not need to specify an axis to use `showsIndicators`. For example:
///
///  ![ScrollView Example 5](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-5.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ScrollView(showsIndicators: false) {
///             VStack {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍏🍏")
///                 Text("Peaches 🍑🍑")
///             }
///         }
///     }
/// }
/// ```
///
/// This `ScrollView`  hides its scroll indicator, with a default `.vertical` scroll direction.
/// [<-]
/// [scrollview-proxy ->]
/// ### Scrolling to an item
///
/// To programmatically scroll to a particular item in your `ScrollView`, use `ScrollViewProxy/scrollTo(_:anchor:)`. `ScrollViewProxy` is a type that allows you to control a `ScrollView`, and can be obtained using a `ScrollViewReader`.
///
/// For example:
///
///  ![ScrollView Example 6](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-6.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ScrollView {
///             ScrollViewReader { (proxy: ScrollViewProxy) in
///                 Button("Jump to #32") {
///                     proxy.scrollTo(32)
///                 }
///
///                 ForEach(1..<101) { number in
///                     Text("Item #\(number)")
///                         .id(number)
///                 }
///             }
///         }
///     }
/// }
/// ```
///
/// In this example, clicking the button reading "Jump to #32", will cause the `ScrollView` to scroll to the item with the ID of the value `32`. To assign an ID to a view, use `View/id(_:)` as is done inside the `ForEach`, for each element.
///
/// The call of `proxy.scrollTo(32)` causes the `ScrollView` to scroll to the text reading "Item #32", with that text centered vertically in the `ScrollView`'s bounds. To change the anchor of the finalled scrolled-to destination, specify an anchor via `ScrollViewProxy/scrollTo(_:anchor:)`. For example:
///
///  ![ScrollView Example 7](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-7.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         ScrollView {
///             ScrollViewReader { (proxy: ScrollViewProxy) in
///                 Button("Jump to #32") {
///                     proxy.scrollTo(32, anchor: .top)
///                 }
///
///                 ForEach(1..<101) { number in
///                     Text("Item #\(number)")
///                         .id(number)
///                 }
///             }
///         }
///     }
/// }
/// ```
///
/// In this example, the `ScrollView` still scrolls to "Item #32", but this `Text` is seen at the top of the `ScrollView`, rather than it's vertical center. The `anchor` parameter uses a type, `UnitPoint`, to determine the relative alignment (relative to the scroll view's bounds) of the scrolled-to item.
///
/// [<-]
/// [scrollview-scrollto ->]
///
///  Add a transition to your `ScrollViewProxy/scrollTo(_:anchor:)` with `View/withAnimation(_:_:)`.  For example:
///
///  ![ScrollView Example 8](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ScrollView-example-8.gif)
///
///  ```
///  struct ExampleView: View {
///      var body: some View {
///          ScrollView {
///              ScrollViewReader { (proxy: ScrollViewProxy) in
///                  Button("Jump to #32") {
///                     withAnimation(.easeInOut(duration: 60)) {
///                         proxy.scrollTo(32, anchor: .top)
///                     }
///                  }
///
///                  ForEach(1..<101) { number in
///                      Text("Item #\(number)")
///                          .id(number)
///                  }
///              }
///          }
///      }
///  }
/// ```
/// [<-]
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ScrollView<Content> : View where Content : View {

    /// The scroll view's content.
    public var content: Content

    /// The scrollable axes of the scroll view.
    ///
    /// The default value is `Axis/vertical`. Change the `Axis` to modify the scroll direction.
    ///
    /// [[scrollview-axis]]
    public var axes: Axis.Set

    /// A value that indicates whether the scroll view displays the scrollable
    /// component of the content offset, in a way that's suitable for the
    /// platform.
    ///
    /// The default is `true`.
    public var showsIndicators: Bool

    /// Creates a new instance that's scrollable in the direction of the given
    /// axis and can show indicators while scrolling.
    ///
    /// [[scrollview-hide-indicators]]
    ///
    /// - Parameters:
    ///   - axes: The scroll view's scrollable axis. The default axis is the
    ///     vertical axis.
    ///   - showsIndicators: A Boolean value that indicates whether the scroll
    ///     view displays the scrollable component of the content offset, in a way
    ///     suitable for the platform. The default value for this parameter is
    ///     `true`.
    ///   - content: The view builder that creates the scrollable view.
    public init(_ axes: Axis.Set = .vertical, showsIndicators: Bool = true, @ViewBuilder content: () -> Content) { }

    /// The content and behavior of the scroll view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

/// A proxy value allowing the scrollable views within a view hierarchy
/// to be scrolled programmatically.
///
/// [[scrollview-proxy]]
///
/// [[scrollview-scrollto]]
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ScrollViewProxy {

    /// Scroll to a section given a specific identifier.
    ///
    /// Scans all scroll views contained by the proxy for the first
    /// with a child view with identifier `id`, and then scrolls to
    /// that view.
    ///
    /// [[scrollview-scrollto]]
    ///
    /// If `anchor` is nil the container of the identified view will be
    /// scrolled the minimum amount to make the identified view wholly
    /// visible.
    ///
    /// If `anchor` is non-nil it defines the points in the identified
    /// view and the scroll view that will be aligned, e.g. `.top`
    /// aligns the top of the identified view to the top of the scroll
    /// view, `.bottom` aligns the bottom of the identified view to the
    /// bottom of the scroll view, and so on.
    ///
    public func scrollTo<ID>(_ id: ID, anchor: UnitPoint? = nil) where ID : Hashable { }
}

/// Creates programatic scrolling by ascribing a child defined as a function of a `ScrollViewProxy`.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen public struct ScrollViewReader<Content> : View where Content : View {

    /// A ViewBuilder closure that receives the ScrollViewProxy as a parameter
    public var content: (ScrollViewProxy) -> Content

    /// Initializes with the closure `content`. The proxy passed to the
    /// closure may NOT be messaged while `content` is executing (this
    /// will cause a runtime error) but only from actions created
    /// within `content` such as gesture handlers or the `onChange()`
    /// function.
    @inlinable public init(@ViewBuilder content: @escaping (ScrollViewProxy) -> Content) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

/// A container that groups views.
///
/// Often used in Lists and Forms to set Parent, Content, and Footer information.
///
/// [[list-sections]]
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Section<Parent, Content, Footer> {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section : View where Parent : View, Content : View, Footer : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never

    /// Initialize a `Section` with an explicit header, footer, and content.
    ///
    /// - Parameters:
    ///   - header: A view placed on top
    ///   - footer: A view placed on bottom
    ///   - content: The section contents
    public init(header: Parent, footer: Footer, @ViewBuilder content: () -> Content) { }

    /// The child view displayed in the `Section`.
    public var internalBody: some View { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent == EmptyView, Content : View, Footer : View {

    /// Initialize a `Section` with an explicit footer and content.
    ///
    /// - Parameters:
    ///   - footer: A view placed on bottom
    ///   - content: The section contents
    public init(footer: Footer, @ViewBuilder content: () -> Content) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent : View, Content : View, Footer == EmptyView {

    /// Initialize a `Section` with an explicit header and content.
    ///
    /// - Parameters:
    ///   - header: A view placed on top
    ///   - content: The section contents
    public init(header: Parent, @ViewBuilder content: () -> Content) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Section where Parent == EmptyView, Content : View, Footer == EmptyView {

    /// Initialize a `Section` with specified content.
    ///
    /// - Parameters content: The section contents
    public init(@ViewBuilder content: () -> Content) { }
}

/// A text field for entering private text, usually a password.
///
/// A secure field is just like a ``TextField``, except the entered text is shown as dots instead of
/// as the actual text.
///
/// ```
/// struct PasswordView: View {
///     @State private var password = ""
///     var body: some View {
///         SecureField("Password", text: $password)
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct SecureField<Label> : View where Label : View {

    /// The body of a secure field, which is the underlying TextField.
    ///
    /// ```
    /// struct PasswordView: View {
    ///     @State private var password = ""
    ///     var body: some View {
    ///         let field = SecureField("Password", text: $password)
    ///         return field.onAppear { print(field.body) } //"TextField<Text>(..."
    ///     }
    /// }
    /// ```
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    ///
    /// In this instance, the type evaluates to ``TextField``, since the body of a ``SecureField``
    /// is a text field.
    ///
    /// ```
    /// struct PasswordView: View {
    ///     @State private var password = ""
    ///     var body: some View {
    ///         SecureField("Password", text: $password, onCommit: {
    ///             print("Password has been entered ✅")
    ///         })
    ///     }
    /// }
    /// ```
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SecureField where Label == Text {

    /// Creates a text field for entering private text, usually a password, with a LocalizedStringKey placeholder.
    ///
    /// ```
    /// struct PasswordView: View {
    ///     @State private var password = ""
    ///     var body: some View {
    ///         SecureField(LocalizedStringKey("Password"), text: $password, onCommit: {
    ///             print("Password has been entered ✅")
    ///         })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: The localized string key placeholder, which is visible when the field is empty.
    ///   - text: A binding variable to the displayed and edited text.
    ///   - onCommit: The function called when the user hits the return key.
    public init(_ titleKey: LocalizedStringKey, text: Binding<String>, onCommit: @escaping () -> Void = {}) { }

    /// Creates a text field for entering private text, usually a password, with a String placeholder.
    ///
    /// - Parameters:
    ///   - title: The string placeholder, which is visible when the field is empty.
    ///   - text: A binding variable to the displayed and edited text.
    ///   - onCommit: The function called when the user hits the return key.
    public init<S>(_ title: S, text: Binding<String>, onCommit: @escaping () -> Void = {}) where S : StringProtocol { }
}

/// A picker style that presents the options in a segmented control.
///
/// ![SegmentedPickerStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/pickerstyle-segmented-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var fruits = ["Banana🍌🍌","Apple🍎🍎", "Peach🍑🍑", "Watermelon🍉🍉", "Grapes🍇🍇" ]
///     @State private var selectedFruit = 0
///
///      var body: some View {
///           VStack {
///               Picker(selection: $selectedFruit, label: Text("Select Favorite Fruit")) {
///                   ForEach(0..<fruits.count) {
///                       Text(self.fruits[$0])
///                   }
///               }
///               Text("Your Favorite Fruit: \(self.fruits[selectedFruit])")
///           }
///           .pickerStyle(SegmentedPickerStyle())
///       }
///  }
/// ```
///
/// [pickerstyle-segmented ->]
/// Your app can also use explicit tags to identify picker content.
///
/// ![Segmented Example 1](/picker-style-6.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var favoriteFruit: MyFruit = MyFruit.banana
///
///     var fruitName: String {
///         switch favoriteFruit{
///         case .apple:
///             return "Apple 🍎🍎"
///         case .banana:
///             return "Banana 🍌🍌"
///         case .peach:
///             return "Peach 🍑🍑"
///         }
///     }
///
///     var body: some View {
///         Text("My Favorite Fruit: \(fruitName)")
///
///         Picker("My Picker", selection: $favoriteFruit) {
///             Text("Banana 🍌🍌")
///                 .tag(MyFruit.banana)
///             Text("Apple 🍎🍎")
///                 .tag(MyFruit.apple)
///             Text("Peach 🍑🍑")
///                 .tag(MyFruit.peach)
///         }.pickerStyle(SegmentedPickerStyle())
///     }
/// }
/// ```
///
/// [<-]
///
///
/// > To apply this style to a picker, or to a view that contains pickers, use the
/// `View/pickerStyle(_:)` modifier.
///
/// > Note: The segmented picker style supports `Text` and `Image` segments only.
/// Any other view results in a visible, but empty, segment.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
@available(watchOS, unavailable)
public struct SegmentedPickerStyle : PickerStyle {

    /// Creates a segmented picker style.
    public init() { }
}

/// A gesture that's a sequence of two gestures.
///
/// Read <doc:Composing-SwiftUI-Gestures> to learn how you can create a sequence
/// of two gestures.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct SequenceGesture<First, Second> : Gesture where First : Gesture, Second : Gesture {

    /// The value of a sequence gesture that helps to detect whether the first
    /// gesture succeeded, so the second gesture can start.
    @frozen public enum Value {

        /// The first gesture hasn't ended.
        case first(First.Value)

        /// The first gesture has ended.
        case second(First.Value, Second.Value?)
    }

    /// The first gesture in a sequence of two gestures.
    public var first: First

    /// The second gesture in a sequence of two gestures.
    public var second: Second

    /// Creates a sequence gesture with two gestures.
    ///
    /// - Parameters:
    ///   - first: The first gesture of the sequence.
    ///   - second: The second gesture of the sequence.
    @inlinable public init(_ first: First, _ second: Second) { }

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SequenceGesture.Value : Equatable where First.Value : Equatable, Second.Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SequenceGesture<First, Second>.Value, b: SequenceGesture<First, Second>.Value) -> Bool { }
}

/// A 2D shape that you can use when drawing a view.
///
/// This procol inherits from the ``View`` protocol, so all shapes can be
/// used just like any other view. However, there are many default methods
/// that shapes have which views do not.
///
/// ### Creating your own shape
///
/// The only requirement of conforming to the shape protocol is implementing
/// the ``Shape/path(in:)`` method. This method passes in the shape's
/// bounding rectangle, and expects a ``Path`` object in return.
///
/// The most simple example of creating your own shape is a rectangle
/// that looks like this:
///
/// ```
/// struct SimplestShapeView: View {
///     var body: some View {
///         RectangleShape()
///     }
/// }
///
/// struct RectangleShape: Shape {
///     func path(in rect: CGRect) -> Path {
///         return Path(rect)
///     }
/// }
/// ```
///
/// For more info on how to create a path from a bounding rectangle,
/// check out the ``Path`` structure.
///
/// ### Using a pre-defined shape
///
/// In addition to the ability to create your own shape, there are also
/// many pre-defined shapes for you to use:
/// 1. ``Capsule``
/// 2. ``Circle``
/// 3. ``ContainerRelativeShape``
/// 4. ``Ellipse``
/// 5. ``OffsetShape``
/// 6. ``Path``
/// 7. ``Rectangle``
/// 8. ``RoundedRectangle``
///
/// Example usage would look like this:
///
/// ```
/// struct PillView: View {
///     var body: some View {
///         Capsule()
///     }
/// }
/// ```
///
/// Check out these shapes directly for more info on how to use them.
///
/// In general, while view modifiers can be applied to shapes, note that
/// applying a view modifier will return a ``View`` rather than a shape.
/// Whenever possible, try to use shape modifiers instead of
/// view modifiers to accomplish the same tasks with your shapes.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol Shape : Animatable, View { }
extension Shape : Animatable, View {

    /// Describes this shape as a path within a rectangular frame of reference.
    ///
    /// This is the only requirement of conforming to the ``Shape`` protocol.
    /// Implement this method to create your own shapes.
    ///
    /// Check out ``Path`` more more info on how to create a path from
    /// the rectangle parameter.
    ///
    /// ```
    /// struct SimplestShapeView: View {
    ///     var body: some View {
    ///         RectangleShape()
    ///     }
    /// }
    ///
    /// struct RectangleShape: Shape {
    ///     func path(in rect: CGRect) -> Path {
    ///         return Path(rect)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    func path(in rect: CGRect) -> Path { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Shape {

    /// Trims this shape by a fractional amount based on its representation as a
    /// path.
    ///
    /// To create a `Shape` instance, you define the shape's path using lines and
    /// curves. Use the `trim(from:to:)` method to draw a portion of a shape by
    /// ignoring portions of the beginning and ending of the shape's path.
    ///
    /// For example, if you're drawing a figure eight or infinity symbol (∞)
    /// starting from its center, setting the `startFraction` and `endFraction`
    /// to different values determines the parts of the overall shape.
    ///
    /// The following example shows a simplified infinity symbol that draws
    /// only three quarters of the full shape. That is, of the two lobes of the
    /// symbol, one lobe is complete and the other is half complete.
    ///
    /// ```
    /// struct TrimmedPathView: View {
    ///     var body: some View {
    ///         Path { path in
    ///             path.addLines([
    ///                 .init(x: 2, y: 1),
    ///                 .init(x: 1, y: 0),
    ///                 .init(x: 0, y: 1),
    ///                 .init(x: 1, y: 2),
    ///                 .init(x: 3, y: 0),
    ///                 .init(x: 4, y: 1),
    ///                 .init(x: 3, y: 2),
    ///                 .init(x: 2, y: 1)
    ///             ])
    ///         }
    ///         .trim(from: 0.25, to: 1.0)
    ///         .scale(50, anchor: .topLeading)
    ///         .stroke(Color.black, lineWidth: 3)
    ///     }
    /// }
    /// ```
    ///
    /// Changing the parameters of `trim(from:to:)` to
    /// `.trim(from: 0, to: 1)` draws the full infinity symbol, while
    /// `.trim(from: 0, to: 0.5)` draws only the left lobe of the symbol.
    ///
    /// - Parameters:
    ///   - startFraction: The fraction of the way through drawing this shape
    ///     where drawing starts.
    ///   - endFraction: The fraction of the way through drawing this shape
    ///     where drawing ends.
    /// - Returns: A shape built by capturing a portion of this shape's path.
    @inlinable public func trim(from startFraction: CGFloat = 0, to endFraction: CGFloat = 1) -> some Shape { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Shape {

    /// Changes the relative position of this shape using the specified size.
    ///
    /// The following example renders two circles. It places one circle at its
    /// default position. The second circle is outlined with a stroke,
    /// positioned on top of the first circle and offset by 100 points to the
    /// left and 50 points below.
    ///
    /// ```
    /// struct OffsetCircleView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .overlay(Circle()
    ///                 .offset(CGSize(width: -100, height: 50))
    ///                 .stroke())
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter offset: The amount, in points, by which you offset the
    ///   shape. Negative numbers are to the left and up; positive numbers are
    ///   to the right and down.
    ///
    /// - Returns: A shape offset by the specified amount.
    @inlinable public func offset(_ offset: CGSize) -> OffsetShape<Self> { }

    /// Changes the relative position of this shape using the specified point.
    ///
    /// The following example renders two circles. It places one circle at its
    /// default position. The second circle is outlined with a stroke,
    /// positioned on top of the first circle and offset by 100 points to the
    /// left and 50 points below.
    ///
    /// ```
    /// struct OffsetCircleView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .overlay(Circle()
    ///                 .offset(CGPoint(x: -100, y: 50))
    ///                 .stroke())
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter offset: The amount, in points, by which you offset the
    ///   shape. Negative numbers are to the left and up; positive numbers are
    ///   to the right and down.
    ///
    /// - Returns: A shape offset by the specified amount.
    @inlinable public func offset(_ offset: CGPoint) -> OffsetShape<Self> { }

    /// Changes the relative position of this shape using the specified point.
    ///
    /// The following example renders two circles. It places one circle at its
    /// default position. The second circle is outlined with a stroke,
    /// positioned on top of the first circle and offset by 100 points to the
    /// left and 50 points below.
    ///
    /// ```
    /// struct OffsetCircleView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .overlay(Circle()
    ///                 .offset(x: -100, y: 50)
    ///                 .stroke())
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - x: The horizontal amount, in points, by which you offset the shape.
    ///     Negative numbers are to the left and positive numbers are to the
    ///     right.
    ///   - y: The vertical amount, in points, by which you offset the shape.
    ///     Negative numbers are up and positive numbers are down.
    ///
    /// - Returns: A shape offset by the specified amount.
    @inlinable public func offset(x: CGFloat = 0, y: CGFloat = 0) -> OffsetShape<Self> { }

    /// Scales this shape without changing its bounding frame.
    ///
    /// Both the `x` and `y` multiplication factors halve their respective
    /// dimension's size when set to `0.5`, maintain their existing size when
    /// set to `1`, double their size when set to `2`, and so forth.
    ///
    /// ```
    /// struct ScaledCircleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Circle()
    ///             Circle()
    //                  .scale(x: 1.3, y: 1.2, anchor: .center)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - x: The multiplication factor used to resize this shape along its
    ///     x-axis.
    ///   - y: The multiplication factor used to resize this shape along its
    ///     y-axis.
    ///
    /// - Returns: A scaled form of this shape.
    @inlinable public func scale(x: CGFloat = 1, y: CGFloat = 1, anchor: UnitPoint = .center) -> ScaledShape<Self> { }

    /// Scales this shape without changing its bounding frame.
    ///
    /// ```
    /// struct ScaledCircleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Circle()
    ///             Circle()
    //                  .scale(1.2, anchor: .center)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter scale: The multiplication factor used to resize this shape.
    ///   A value of `0` scales the shape to have no size, `0.5` scales to half
    ///   size in both dimensions, `2` scales to twice the regular size, and so
    ///   on.
    ///
    /// - Returns: A scaled form of this shape.
    @inlinable public func scale(_ scale: CGFloat, anchor: UnitPoint = .center) -> ScaledShape<Self> { }

    /// Rotates this shape around an anchor point at the angle you specify.
    ///
    /// The following example rotates a square by 45 degrees to the right to
    /// create a diamond shape:
    ///
    /// ```
    /// struct RotatedRectView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 10)
    ///             .rotation(Angle(degrees: 45))
    ///             .aspectRatio(1.0, contentMode: .fit)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - angle: The angle of rotation to apply. Positive angles rotate
    ///     clockwise; negative angles rotate counterclockwise.
    ///   - anchor: The point to rotate the shape around.
    ///
    /// - Returns: A rotated shape.
    @inlinable public func rotation(_ angle: Angle, anchor: UnitPoint = .center) -> RotatedShape<Self> { }

    /// Applies an affine transform to this shape.
    ///
    /// Affine transforms present a mathematical approach to applying
    /// combinations of rotation, scaling, translation, and skew to shapes.
    ///
    /// Check out Apple's [docs](https://developer.apple.com/documentation/coregraphics/cgaffinetransform)
    /// on `CGAffineTransform` to learn more about
    /// the parameter.
    ///
    /// ```
    /// struct TransformedRectView: View {
    ///     var body: some View {
    ///         Rectangle()
    ///             .transform(CGAffineTransform(a: 1, b: 0, c: 0.5, d: 1, tx: 0, ty: 0))
    ///             .frarme(width: 100, height: 100)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter transform: The affine transformation matrix to apply to this
    ///   shape.
    ///
    /// - Returns: A transformed shape, based on its matrix values.
    @inlinable public func transform(_ transform: CGAffineTransform) -> TransformedShape<Self> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Shape {

    /// Changes the shape's size from a CGSize.
    ///
    /// This method will pass the required
    /// ``Shape/path(in:)`` function an updated rectangle.
    /// If you would prefer not to change the passed in rectangle,
    /// use ``Shape/scale(x:y:anchor:)`` function instead.
    ///
    /// This is similar the ``View/frame(width:height:)`` modifier
    /// from ``View``, except this returns a ``Shape``.
    ///
    /// ```
    /// struct SquareView: View {
    ///     var body: some View {
    ///         Rectangle()
    ///             .size(CGSize(width: 100, height: 100))
    ///     }
    /// }
    // ```
    ///
    /// - Parameter size: The new rectangle size.
    @inlinable public func size(_ size: CGSize) -> some Shape { }


    /// Changes the shape's size from a width and height.
    ///
    /// This method will pass the required
    /// ``Shape/path(in:)`` function an updated rectangle.
    /// If you would prefer not to change the passed in rectangle,
    /// use ``Shape/scale(x:y:anchor:)`` function instead.
    ///
    /// This is similar the ``View/frame(width:height:)`` modifier
    /// from ``View``, except this returns a ``Shape``.
    ///
    /// ```
    /// struct SquareView: View {
    ///     var body: some View {
    ///         Rectangle()
    ///             .size(width: 100, height: 100)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - width: The shape's new bounding rectangle width.
    ///   - height: The shape's new bounding rectangle height.
    @inlinable public func size(width: CGFloat, height: CGFloat) -> some Shape { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Shape {

    /// Fills this shape with a color or gradient.
    ///
    /// Use this method to fill a shape with any ``ShapeStyle``.
    ///
    /// See ``FillStyle`` for more info on the `style` parameter of this
    /// method.
    ///
    /// ```
    /// struct TwoCirclesView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .fill(Color.pink, style: FillStyle(eoFill: true, antialiased: true))
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - content: The color or gradient to use when filling this shape.
    ///   - style: The style options that determine how the fill renders.
    ///
    /// - Returns: A shape filled with the color or gradient you supply.
    @inlinable public func fill<S>(_ content: S, style: FillStyle = FillStyle()) -> some View where S : ShapeStyle { }


    /// Fills this shape with the foreground color.
    ///
    /// Use this method to fill a shape with the foreground color
    /// of the view.
    ///
    /// See ``FillStyle for more info on the `style` parameter of this
    /// method.
    ///
    /// ```
    /// struct TwoCirclesView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .fill(style: FillStyle(eoFill: true, antialiased: true))
    ///             .foregroundColor(.pink)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter style: The style options that determine how the fill
    ///   renders.
    /// - Returns: A shape filled with the foreground color.
    @inlinable public func fill(style: FillStyle = FillStyle()) -> some View { }


    /// Traces the outline of this shape with a color or gradient.
    ///
    /// Use this method to add a border to a shape.
    ///
    /// See ``ShapeStyle`` for more info on the stroke content parameter.
    ///
    /// See ``StrokeStyle`` for more info on how to customize the stroke.
    ///
    /// The following example adds a dashed purple stroke to a `Capsule`:
    ///
    /// ```
    /// struct StrokedCapsuleView: View {
    ///     let style = StrokeStyle(lineWidth: 5,
    ///                             lineCap: .round,
    ///                             lineJoine: .miter,
    ///                             miterLimit: 0,
    ///                             dash: [5, 10],
    ///                             dashPhase: 0)
    ///     var body: some View {
    ///         Capsule()
    ///             .stroke(Color.purple, style: style)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - content: The color or gradient with which to stroke this shape.
    ///   - style: The stroke characteristics --- such as the line's width and
    ///     whether the stroke is dashed --- that determine how to render this
    ///     shape.
    ///
    /// - Returns: A stroked shape.
    @inlinable public func stroke<S>(_ content: S, style: StrokeStyle) -> some View where S : ShapeStyle { }


    /// Traces the outline of this shape with a color or gradient.
    ///
    /// See ``ShapeStyle`` for more info on the stroke content parameter.
    ///
    /// To customize the stroke style, use
    /// ``Shape/stroke(_:style:)`` instead.
    ///
    /// The following example draws a circle with a purple stroke:
    ///
    /// ```
    /// struct StrokedCircleView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .stroke(Color.purple, lineWidth: 5)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters style: The stroke characteristics --- such as the line's width and
    /// whether the stroke is dashed --- that determine how to render this
    /// shape.
    ///
    /// - Returns: A stroked shape.
    @inlinable public func stroke<S>(_ content: S, lineWidth: CGFloat = 1) -> some View where S : ShapeStyle { }

}

/// A shape acts as view by filling itself with the foreground color and
/// default fill style.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Shape {

    /// The content and behavior of the view.
    public var body: _ShapeView<Self, ForegroundStyle> { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Shape {

    /// Traces the outline of this shape with the view's foreground color.
    ///
    /// Use this method to stroke a shape with the foreground color specified
    /// in the view.
    ///
    /// To customize the stroke style, use
    /// ``Shape/stroke(_:style:)`` instead.
    ///
    /// The following example draws a capsule with a purple stroke:
    ///
    /// ```
    /// struct StrokedCapsuleView: View {
    ///     let style = StrokeStyle(lineWidth: 5,
    ///                             lineCap: .round,
    ///                             lineJoine: .miter,
    ///                             miterLimit: 0,
    ///                             dash: [5, 10],
    ///                             dashPhase: 0)
    ///     var body: some View {
    ///         Capsule()
    ///             .stroke(style: style)
    ///             .foregroundColor(.purple)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - content: The color or gradient with which to stroke this shape.
    ///   - lineWidth: The width of the stroke that outlines this shape.
    ///
    /// - Returns: A stroked shape.
    @inlinable public func stroke(style: StrokeStyle) -> some Shape { }


    /// Traces the outline of this shape with the view's foreground color.
    ///
    /// Use this method to stroke a shape with the foreground color specified
    /// in the view.
    ///
    /// The following example draws a capsule with a purple stroke:
    ///
    /// ```
    /// struct StrokedCapsuleView: View {
    ///     var body: some View {
    ///         Capsule()
    ///             .stroke(lineWidth: 5)
    ///             .foregroundColor(.purple)
    ///     }
    /// }
    /// ```
    @inlinable public func stroke(lineWidth: CGFloat = 1) -> some Shape { }

}

/// A way to turn a shape into a view.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol ShapeStyle{ }
extension ShapeStyle {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ShapeStyle {

    /// Return a new paint value matching `self` except using `rect` to
    /// map unit-space coordinates to absolute coordinates.
    @inlinable public func `in`(_ rect: CGRect) -> some ShapeStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ShapeStyle where Self : View, Self.Body == _ShapeView<Rectangle, Self> {

	/// Default `View.body` implementation to fill a Rectangle with `self`.
    public var body: _ShapeView<Rectangle, Self> { get }
}

/// A built-in set of commands for manipulating window sidebars.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the `Scene.commands(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct SidebarCommands : Commands {

    /// A new value describing the built-in sidebar-related commands.
    public init() { }

    /// The composition of commands that comprise the command group.
    public var body: some Commands { get }

    /// The type of command group representing the body of this command group.
    public typealias Body = some Commands
}

/// The behavior and appearance of a sidebar or source list.
///
/// ![SidebarListStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/liststyle-sidebar-example-1.png)
///
/// ```
///      struct ExampleView: View {
///          var body: some View {
///             List {
///                 Text("Bananas 🍌🍌")
///                 Text("Apples 🍎🍎")
///                 Text("Peaches 🍑🍑")
///             }
///             .listStyle(SidebarListStyle())
///          }
///      }
/// ```
///
@available(iOS 14.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct SidebarListStyle : ListStyle {

    /// Creates a sidebar list style.
    public init() { }
}

/// A gesture containing two gestures that can happen at the same time with
/// neither of them preceeding the other.
///
/// A simultaneous gesture is a container-event handler that evaluates its two
/// child gestures at the same time. Its value is a struct with two optional
/// values, each representing the phases of one of the two gestures.
///
/// ![SimultaneousGesture Example 1](simultaneous-gesture-example.gif)
///
/// See ``Gesture/simultaneously(with:)`` for more of an explanation and an example.
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct SimultaneousGesture<First, Second> : Gesture where First : Gesture, Second : Gesture {

    /// The value of a simultaneous gesture that indicates which of its two
    /// gestures receives events.
    @frozen public struct Value {

        /// The value of the first gesture.
        public var first: First.Value?

        /// The value of the second gesture.
        public var second: Second.Value?
    }

    /// The first of two gestures that can happen simultaneously.
    public var first: First

    /// The second of two gestures that can happen simultaneously.
    public var second: Second

    /// Creates a gesture with two gestures that can receive updates or succeed
    /// independently of each other.
    ///
    /// - Parameters:
    ///   - first: The first of two gestures that can happen simultaneously.
    ///   - second: The second of two gestures that can happen simultaneously.
    @inlinable public init(_ first: First, _ second: Second) { }

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SimultaneousGesture.Value : Equatable where First.Value : Equatable, Second.Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SimultaneousGesture<First, Second>.Value, b: SimultaneousGesture<First, Second>.Value) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SimultaneousGesture.Value : Hashable where First.Value : Hashable, Second.Value : Hashable {

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

/// A control for selecting a value from a bounded range.
///
/// A slider is a circle on a track. The user can move the circle from left to right to pick between
/// values. The slider takes a binding that the user updates.
///
/// The most basic example looks like this:
///
/// ```
/// struct SliderView: View {
///     @State private var value: Double = 0
///
///     var body: some View {
///         Slider(value: $value)
///     }
/// }
/// ```
///
/// In general, a slider has these four options:
/// 1. Add a label
/// 2. Change maximum and minimum values
/// 3. Create a step size
/// 4. Call a function when slider editing chances.
///
/// The slider's different initializers use different combinations of these options.
@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
public struct Slider<Label, ValueLabel> : View where Label : View, ValueLabel : View {

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider {

    /// Creates a slider with a label and max/min labels.
    ///
    /// ```
    /// struct LabeledSliderView: View {
    ///     @State private var value: Double = 0
    ///
    ///     var body: some View {
    ///         Slider(value: $value,
    ///                in: 0...100,
    ///                onEditingChanged: { began in print("began? \(began)") },
    ///                minimumValueLabel: Text("🐢"),
    ///                maximumValueLabel: Text("🐇"),
    ///                label: { Text("Speed") })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - value: A binding connected to the slider value.
    ///   - bounds: A range of possible values. Defaults to `0...1`.
    ///   - onEditingChanged: A function called when editing begins and ends, which takes a boolean
    ///   parameter equal to true when editing begins, and false when it ends.
    ///   - minimumValueLabel: A view used as a label on the minimum value side of the slider.
    ///   - maximumValueLabel: A view used as a label on the maximum value side of the slider.
    ///   - label: A view used as a label for the slider. Mainly used for accessibility on iOS.
    @available(tvOS, unavailable)
    public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, minimumValueLabel: ValueLabel, maximumValueLabel: ValueLabel, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint { }

    /// Creates a slider with a label, max/min labels, and a step size.
    ///
    /// ```
    /// struct LabeledSliderView: View {
    ///     @State private var value: Double = 0
    ///
    ///     var body: some View {
    ///         Slider(value: $value,
    ///                in: 0...100,
    ///                step: 10,
    ///                onEditingChanged: { began in print("began? \(began)") },
    ///                minimumValueLabel: Text("🐢"),
    ///                maximumValueLabel: Text("🐇"),
    ///                label: { Text("Speed") })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - value: A binding connected to the slider value.
    ///   - bounds: A range of possible values. Defaults to `0...1`.
    ///   - step: The distance between values on the slider. Defaults to 1.
    ///   - onEditingChanged: A function called when editing begins and ends, which takes a boolean
    ///   parameter equal to true when editing begins, and false when it ends.
    ///   - minimumValueLabel: A view used as a label on the minimum value side of the slider.
    ///   - maximumValueLabel: A view used as a label on the maximum value side of the slider.
    ///   - label: A view used as a label for the slider. Mainly used for accessibility on iOS.
    public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, minimumValueLabel: ValueLabel, maximumValueLabel: ValueLabel, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint { }
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider where ValueLabel == EmptyView {

    /// Creates a slider with a label.
    ///
    /// ```
    /// struct LabeledSliderView: View {
    ///     @State private var value: Double = 0
    ///
    ///     var body: some View {
    ///         Slider(value: $value,
    ///                in: 0...100,
    ///                onEditingChanged: { began in print("began? \(began)") },
    ///                label: { Text("Speed") })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - value: A binding connected to the slider value.
    ///   - bounds: A range of possible values. Defaults to `0...1`.
    ///   - onEditingChanged: A function called when editing begins and ends, which takes a boolean
    ///   parameter equal to true when editing begins, and false when it ends.
    ///   - label: A view used as a label for the slider. Mainly used for accessibility on iOS.
    @available(tvOS, unavailable)
    public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint { }

    /// Creates a slider with a label and a step size.
    ///
    /// ```
    /// struct LabeledSliderView: View {
    ///     @State private var value: Double = 0
    ///
    ///     var body: some View {
    ///         Slider(value: $value,
    ///                in: 0...100,
    ///                step: 10,
    ///                onEditingChanged: { began in print("began? \(began)") },
    ///                label: { Text("Speed") })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - value: A binding connected to the slider value.
    ///   - bounds: A range of possible values. Defaults to `0...1`.
    ///   - step: The distance between values on the slider. Defaults to 1.
    ///   - onEditingChanged: A function called when editing begins and ends, which takes a boolean
    ///   parameter equal to true when editing begins, and false when it ends.
    ///   - label: A view used as a label for the slider. Mainly used for accessibility on iOS.
    @available(tvOS, unavailable)
    public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint { }
}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension Slider where Label == EmptyView, ValueLabel == EmptyView {

    /// Creates a slider.
    ///
    /// ```
    /// struct LabeledSliderView: View {
    ///     @State private var value: Double = 0
    ///
    ///     var body: some View {
    ///         Slider(value: $value,
    ///                in: 0...100,
    ///                onEditingChanged: { began in print("began? \(began)") })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - value: A binding connected to the slider value.
    ///   - bounds: A range of possible values. Defaults to `0...1`.
    ///   - onEditingChanged: A function called when editing begins and ends, which takes a boolean
    ///   parameter equal to true when editing begins, and false when it ends.
    public init<V>(value: Binding<V>, in bounds: ClosedRange<V> = 0...1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint { }

    /// Creates a a slider with a step size.
    ///
    /// ```
    /// struct LabeledSliderView: View {
    ///     @State private var value: Double = 0
    ///
    ///     var body: some View {
    ///         Slider(value: $value,
    ///                in: 0...100,
    ///                step: 10,
    ///                onEditingChanged: { began in print("began? \(began)") })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - value: A binding connected to the slider value.
    ///   - bounds: A range of possible values. Defaults to `0...1`.
    ///   - step: The distance between values on the slider. Defaults to 1.
    ///   - onEditingChanged: A function called when editing begins and ends, which takes a boolean
    ///   parameter equal to true when editing begins, and false when it ends.
    @available(tvOS, unavailable)
    public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint { }
}

/// A flexible empty view that expands to take up as much space as possible.
///
/// Spacers are commonly used inside of stacks, like ``VStack``, ``HStack``, and ``ZStack``.
/// In a stack, they take up as much space as possible, so push everything else to the side.
///
/// In the following ``HStack``, a spacer is used to align the text to the right:
///
/// ```
/// struct SpacerView: View {
///     var body: some View {
///         HStack {
///             Spacer()
///             Text("Ouch I'm crammed ➡️🤕")
///         }
///     }
/// }
/// ```
///
/// A spacer can also be framed to take a specific amount of space:
///
/// ```
/// struct SpacerView: View {
///     var body: some View {
///         VStack {
///             Spacer()
///             Text("I'm 15 points off the ground 😇")
///             Spacer()
///                 .frame(height: 15)
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Spacer {

    /// The minimum length the spacer will take up.
    ///
    /// If `nil`, the spacer will take up no space or the whole space, and its layout will be
    /// the last priority.
    ///
    /// This property is usually specified using ``Spacer/init(minLength:)``,
    /// but it can also be specified directly:
    ///
    /// ```
    /// struct SpacerMinLengthView: View {
    ///     @State private var spacer = Spacer()
    ///     var body: some View {
    ///         HStack {
    ///             spacer
    ///             Button("Cram!") { spacer.minLength = 300 }
    ///             Text("Ouch I'm crammed ➡️🤕")
    ///         }
    ///     }
    /// }
    /// ```
    public var minLength: CGFloat?

    /// Creates a spacer view.
    ///
    /// A spacer is a flexible empty view that expands to take up as much space as possible.
    /// Spacers are commonly used inside of stacks, like ``VStack``, ``HStack``, and ``ZStack``.
    /// In a stack, they take up as much space as possible, so push everything else to the side.
    ///
    /// In the following ``HStack``, a spacer is used to align the text to the right:
    ///
    /// ```
    /// struct SpacerView: View {
    ///     var body: some View {
    ///         HStack {
    ///             Spacer()
    ///             Text("Ouch I'm crammed ➡️🤕")
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// Spacers ordinarily take up only as much space is left by other views. However,
    /// your spacer can also specify a minimum length:
    ///
    /// ```
    /// struct BigSpacerView: View {
    ///     var body: some View {
    ///         HStack {
    ///             Spacer(minLength: 300)
    ///             Text("I'm REALLY crammed 😵")
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter minLength: The minimum amount of space the spacer will take up.
    @inlinable public init(minLength: CGFloat? = nil) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Spacer : View {
}

/// A navigation view style represented by a view stack that only shows a
/// single top view at a time.
///
/// ![NavigationView Example 8](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/NavigationView-example-8.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello Bananas🍌🍌")
///         }
///         .navigationViewStyle(StackNavigationViewStyle())
///     }
/// }
/// ```
@available(iOS 13.0, tvOS 13.0, watchOS 7.0, *)
@available(macOS, unavailable)
public struct StackNavigationViewStyle : NavigationViewStyle {

	/// Creates a stack navigation view style.
    public init() { }
}

/// A SwiftUI property wrapper that holds a state value.
///
/// ### Usage
///
/// Modifying a `@State` variable causes the `body` of the view to be recomputed. For example:
///
/// ```
/// struct ExampleView: View {
///     @State var foo: String = "Apple"
///
///     var body: some View {
///         VStack {
///             Text(foo)
///
///             Button("Change Text") {
///                 foo = "Banana"
///             }
///         }
///     }
/// }
/// ```
///
/// In this example, pressing the button labeled "Change Text" modifies the `foo` state variable. This causes `ExampleView`'s `body` to be recomputed by the SwiftUI runtime. This  new `body` is then queued for the next render cycle, upon which the view's display is updated on the screen.
///
/// Note:
///
/// - Recomputing the `body` is also frequently referred to as "invalidating the view".
/// - While all SwiftUI views are value types, the `@State` property wrapper creates a reference based storage managed by the SwiftUI runtime. This is why mutating a state variable does not require a mutating function.
///
/// ### Passing state down to a child view
///
/// Pass a state variable just as you would pass any other variable to a struct. For example:
///
/// ```
/// struct ExampleView: View {
///     struct ChildView: View {
///         let text: String
///
///         var body: some View {
///             Text(text)
///         }
///     }
///
///     @State var foo: String = "Apple"
///
///     var body: some View {
///         VStack {
///             ChildView(text: foo)
///
///             Button("Change Text") {
///                 foo = "Banana"
///             }
///         }
///     }
/// }
/// ```
///
/// In this example, `foo` is passed to `ChildView` by initializer.
///
/// And exactly as in the previous example, when `foo` updates, so will the `body` of `ExampleView`. When the `body` of `ExampleView` is recomputed, a new instance of `ChildView` is created with the latest value of `foo` (which is now "Banana"). `ChildView` in turn computes its own `body`, which creates a `Text("Banana")`.
///
/// Everytime a `View` is invalidated, its `body` is recomputed. Everytime the body is recomputed, all the view's childrens' bodies are also recursively recomputed. Since SwiftUI views are value types, creating and destroying them repeatedly (even hundreds of times a second) does not impact the app's performance.
///
/// ### Passing a reference to the state
///
/// The previous example demonstrated how a state value could be passed from a view to its child. However, for the child to be able to actually modify the parent's state, the parent must pass a **binding** to its child. A binding is a read/write reference to the `@State` variable, and is represented via `SwiftUI/Binding`.
///
/// To create a binding to a state variable, prefix it with a dollar sign `$`. For example:
///
/// ```
/// struct ExampleView: View {
///     @State var text: String = "🍌🍌"
///
///     var body: some View {
///         Text(text)
///         TextField("Placeholder", text: $text)
///     }
/// }
/// ```
///
/// In this example, `TextField` requires a binding in order to read and write to a given value. The `text` state variable is converted to a `Binding<String>` using the dollar sign prefix (`$text`), and then passed to `Textfield` via its initializer.
///
/// Note: The `Binding` type can also be used to create references to `@ObservedObject`, `@EnvironmentObject` and `@StateObject`. It is not unique to `@State`, but rather a general structure that represents a reference to some source of truth.
///
/// ### Modifying a state variable outside of `body`
///
/// It's possible to modify a state variable outside of a view's `body`. For example:
///
/// ```
/// struct ContentView: View {
///     @State var foo: String = "Apple"
///
///     var body: some View {
///         VStack {
///             Text(foo)
///
///             Button("Change Text", action: changeText)
///         }
///     }
///
///     func changeText() {
///         foo = "Banana"
///     }
/// }
/// ```
///
/// In this example, the button labeled "Change text" calls the function `changeText`, which modifies `foo`.
///
/// Note:
///
/// - `changeText` is not a `mutating ` function. This is because the `@State` property wrapper internally uses a reference based storage managed by the SwiftUI runtime.
/// - All modifications to a state variable **must** happen on the main thread. Modifying a state variable on a background thread may lead to undefined behavior.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen @propertyWrapper public struct State<Value> : DynamicProperty {

    /// Creates the state with an initial wrapped value.
    ///
    /// You don't call this initializer directly. Instead, declare a property
    /// with the `@State` attribute, and provide an initial value; for example,
    /// `@State private var isPlaying: Bool = false`.
    ///
    /// - Parameter wrappedValue: An initial wrappedValue for a state.
    public init(wrappedValue value: Value) { }

    /// Creates the state with an initial value.
    ///
    /// - Parameter value: An initial value of the state.
    public init(initialValue value: Value) { }

    /// The underlying value referenced by the state variable.
    ///
    /// This property provides primary access to the value's data. However, you
    /// don't access `wrappedValue` directly. Instead, you use the property
    /// variable created with the `@State` attribute. For example, in the
    /// following code example the button's actions toggles the value of
    /// `showingProfile`, which toggles `wrappedValue`:
    ///
    ///     @State private var showingProfile = false
    ///
    ///     var profileButton: some View {
    ///         Button(action: { self.showingProfile.toggle() }) {
    ///             Image(systemName: "person.crop.circle")
    ///                 .imageScale(.large)
    ///                 .accessibilityLabel(Text("User Profile"))
    ///                 .padding()
    ///         }
    ///     }
    ///
    /// When a mutable binding value changes, the new value is immediately
    /// available. However, updates to a view displaying the value happens
    /// asynchronously, so the view may not show the change immediately.
    public var wrappedValue: Value { get nonmutating set }

    /// A binding to the state value.
    ///
    /// Use the projected value to pass a binding value down a view hierarchy.
    /// To get the `projectedValue`, prefix the property variable with `$`. For
    /// example, in the following code example `PlayerView` projects a binding
    /// of the state property `isPlaying` to the `PlayButton` view using
    /// `$isPlaying`.
    ///
    ///     struct PlayerView: View {
    ///         var episode: Episode
    ///         @State private var isPlaying: Bool = false
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Text(episode.title)
    ///                 Text(episode.showTitle)
    ///                 PlayButton(isPlaying: $isPlaying)
    ///             }
    ///         }
    ///     }
    public var projectedValue: Binding<Value> { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension State where Value : ExpressibleByNilLiteral {

    /// Creates a state without an initial value.
    @inlinable public init() { }
}

/// A SwiftUI property wrapper that instantiates and stores an observable object in state.
///
/// - Think of `@StateObject` as a combination of `@State` and `@ObservedObject`.
/// - Like `@ObservedObject`, this type subscribes to the observable object and invalidates a view whenever the observable object changes.
/// - Unlike `@ObservedObject`, `@StateObject` holds on to its value even when the view is invalidated and redrawn.
///
/// ### Usage
///
/// In the following example, an observable object class `AppModel` is instantiated and stored in a `@StateObject`:
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var foo: Bool = false
/// }
///
/// struct ExampleView: View {
///     @StateObject var appModel = AppModel()
///
///     var body: some View {
///         Text("Hello World")
///     }
/// }
/// ```
///
/// ### How it works
///
/// The following is the basic structure of a `@StateObject`:
///
/// ```
/// struct StateObject<ObjectType: ObservableObject>: DynamicProperty {
///     var wrappedValue: ObjectType { get }
///
///     init(wrappedValue thunk: @autoclosure @escaping () -> ObjectType)
/// }
/// ```
///
/// It's important to note that the initializer takes an `@autoclosure` expression. This means that the following code is evaluated lazily:
///
/// ```
///     @StateObject var appModel = AppModel()
/// ```
///
/// `AppModel` is only initialized once per the lifetime of the `View`, `Scene` or `App` that contains the `@StateObject`. This is made possible by the `@autoclosure` annotation, that wraps the instantiation of the app model, `AppModel()`, into a lazy expression at compile time, `{ return AppModel() }`. This allows the `@StateObject` to call it appropriately as needed, which is once per its parent's lifetime.
///
/// ### Creating bindings
///
/// Just like `@State`, `@ObservedObject` and `@EnvironmentObject`, `@StateObject` allows you to create a `Binding` from its wrapped value type using the `$` syntax.
///
/// For example:
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var flag: Bool = false
/// }
///
/// struct ExampleView: View {
///     @StateObject var appModel = AppModel()
///
///     var body: some View {
///         Toggle("Flag", isOn: $appModel.flag)
///     }
/// }
/// ```
///
///  In this example, `AppModel` contains a boolean, `flag`, which is represented by a `Toggle` in `ChildView`. `Toggle` requires a `Binding<Bool>` to read and write whether it is on.
///
/// ### Comparison with `@ObservedObject`
///
/// Consider the following:
///
/// ```
/// struct ExampleView: View {
///     class ViewModel: ObservableObject {
///         init() {
///             print("Initialized")
///         }
///     }
///
///     struct ToggleDescription: View {
///         let value: Bool
///
///         @StateObject var viewModel = ViewModel()
///
///         var body: some View {
///             Text("The value is: \(String(describing: value))")
///         }
///     }
///
///     @State var foo = false
///
///     var body: some View {
///         VStack {
///             ToggleDescription(value: foo)
///
///             Toggle("Refresh", isOn: $foo)
///         }
///     }
/// }
/// ```
///
/// `ExampleView` creates a vertical stack of a `Toggle`, and a view that describes the toggle, `ToggleDescription`.
///
/// `ToggleDescription` also contains a `ViewModel`, that is instantiated and held by `@StateObject`. The `ViewModel` prints on initialization. Run this code and observe that the following is printed:
///
/// ```
/// Initialized
/// ```
///
/// Flip the toggle twice. Note that even though `ToggleDescription` is refreshed, nothing is printed further.
///
/// Now consider the following:
///
/// ```
/// struct ExampleView: View {
///     class ViewModel: ObservableObject {
///         init() {
///             print("Initialized")
///         }
///     }
///
///     struct ToggleDescription: View {
///         let value: Bool
///
///         @ObservedObject var viewModel = ViewModel()
///
///         var body: some View {
///             Text("The value is: \(String(describing: value))")
///         }
///     }
///
///     @State var foo = false
///
///     var body: some View {
///         VStack {
///             ToggleDescription(value: foo)
///
///             Toggle("Refresh", isOn: $foo)
///         }
///     }
/// }
/// ```
///
/// This example is identical to the previous example **except** for the fact that `@StateObject` has been replaced with `@ObservedObject`. Run this code now, and observe the following print again:
///
/// ```
/// Initialized
/// ```
///
/// Now flip the toggle twice. The console will print the following:
///
/// ```
/// Initialized
/// Initialized
/// ```
///
/// This highlights the fundamental difference between `@StateObject` and `@ObservedObject`.
///
/// -  `@StateObject` instantiates and holds the object in state
/// -  `@ObservedObject` is *assigned* an object, and **does not** hold it in state
///
/// ### Usage with `App`
///
/// `@StateObject` provides a great way to initialize global, application-wide models.
///
/// In the following example, a `@StateObject` is instantiated in `MyApp`, and passed down to `ExampleView` as an environment object.
///
/// ```
/// class AppModel: ObservableObject {
///     @Published var foo: Bool = false
/// }
///
/// @main
/// struct MyApp: App {
///     @StateObject var appModel = AppModel()
///
///     var body: some Scene {
///         WindowGroup {
///             ExampleView()
///                 .environmentObject(appModel)
///         }
///     }
/// }
///
/// struct ExampleView: View {
///     @EnvironmentObject var appModel: AppModel
///
///     var body: some View {
///         Text("Hello World")
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@frozen @propertyWrapper public struct StateObject<ObjectType> : DynamicProperty where ObjectType : ObservableObject {

    /// Creates a new state object with an initial wrapped value.
    ///
    /// You don’t call this initializer directly. Instead, declare a property
    /// with the `@StateObject` attribute in a `SwiftUI/View`,
    /// `SwiftUI/App`, or `SwiftUI/Scene`, and provide an initial value:
    ///
    ///     struct MyView: View {
    ///         @StateObject var model = DataModel()
    ///
    ///         // ...
    ///     }
    ///
    /// SwiftUI creates only one instance of the state object for each
    /// container instance that you declare. In the code above, SwiftUI
    /// creates `model` only the first time it initializes a particular instance
    /// of `MyView`. On the other hand, each different instance of `MyView`
    /// receives a distinct copy of the data model.
    ///
    /// - Parameter thunk: An initial value for the state object.
    @inlinable public init(wrappedValue thunk: @autoclosure @escaping () -> ObjectType) { }

    /// The underlying value referenced by the state object.
    ///
    /// The wrapped value property provides primary access to the value's data.
    /// However, you don't access `wrappedValue` directly. Instead, use the
    /// property variable created with the `@StateObject` attribute:
    ///
    ///     @StateObject var contact = Contact()
    ///
    ///     var body: some View {
    ///         Text(contact.name) // Accesses contact's wrapped value.
    ///     }
    ///
    /// When you change a property of the wrapped value, you can access the new
    /// value immediately. However, SwiftUI updates views displaying the value
    /// asynchronously, so the user interface might not update immediately.
    public var wrappedValue: ObjectType { get }

    /// A projection of the state object that creates bindings to its
    /// properties.
    ///
    /// Use the projected value to pass a binding value down a view hierarchy.
    /// To get the projected value, prefix the property variable with `$`. For
    /// example, you can get a binding to a model's `isEnabled` Boolean so that
    /// a `SwiftUI/Toggle` view can control the value:
    ///
    ///     struct MyView: View {
    ///         @StateObject var model = DataModel()
    ///
    ///         var body: some View {
    ///             Toggle("Enabled", isOn: $model.isEnabled)
    ///         }
    ///     }
    public var projectedValue: ObservedObject<ObjectType>.Wrapper { get }
}

/// Two side-by-side plus/minus buttons.
///
/// Use a stepper to give user control
/// incrementing or decrementing a discrete value.
///
/// - Note: For changing a continuous value, use ``Slider`` instead.
///
/// In general, there are 3 different stepper label types, and 3 different increment/decrement
/// types, for a total of 9 different initializers.
///
/// Label types:
/// 1. String
/// 2. Localized string key
/// 3. View
///
/// Increment/decrement types:
/// 1. Increment and decrement actions
/// 2. Closed range binding
/// 3. Unlimited range binding
///
/// Here is a very simple example:
///
/// ```
/// struct StepperView: View {
///     @State private var value = 0
///
///     var body: some View {
///         Stepper(onIncrement: { value += 1 },
///                 onDecrement: { value -= 1 }) {
///             Text("\(value)")
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Stepper<Label> : View where Label : View {

    /// Creates a stepper with a view label and increment/decrement actions.
    ///
    /// Use this initializer to create a control with a custom title that
    /// executes closures you provide when the user clicks or taps the
    /// stepper's increment or decrement buttons.
    ///
    /// The example below uses an array that holds a number of `Color` values,
    /// a local state variable, `value`, to set the control's background
    /// color, and title label. When the user clicks or taps on the stepper's
    /// increment or decrement buttons SwiftUI executes the relevant
    /// closure that updates `value`, wrapping the `value` to prevent overflow.
    /// SwiftUI then re-renders the view, updating the text and background
    /// color to match the current index:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let colors: [Color] = [.orange, .red, .gray, .blue, .green,
    ///                                .purple, .pink]
    ///
    ///         func incrementStep() {
    ///             value += 1
    ///             if value >= colors.count { value = 0 }
    ///         }
    ///
    ///         func decrementStep() {
    ///             value -= 1
    ///             if value < 0 { value = colors.count - 1 }
    ///         }
    ///
    ///         var body: some View {
    ///             Stepper(onIncrement: incrementStep,
    ///                 onDecrement: decrementStep) {
    ///                 Text("Value: \(value) Color: \(colors[value].description)")
    ///             }
    ///             .background(colors[value])
    ///         }
    ///    }
    ///
    /// - Parameters:
    ///     - onIncrement: The closure to execute when the user clicks or taps
    ///       the control's plus button.
    ///     - onDecrement: The closure to execute when the user clicks or taps
    ///       the control's minus button.
    ///     - onEditingChanged: A closure called when editing begins and ends.
    ///       For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    ///     - label: A view describing the purpose of this stepper.
    public init(onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Stepper {

    /// Creates a stepper with a view label and unlimited range binding.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a bound value by a specific amount each time the user
    /// clicks or taps the stepper's increment or decrement buttons.
    ///
    /// In the example below, a stepper increments or decrements `value` by the
    /// `step` value of 5 at each click or tap of the control's increment or
    /// decrement button:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     step: step) {
    ///                 Text("Current value: \(value), step: \(step)")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - value: The `Binding` to a value that you provide.
    ///   - step: The amount to increment or decrement `value` each time the
    ///     user clicks or taps the stepper's increment or decrement buttons.
    ///     Defaults to `1`.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    ///   - label: A view describing the purpose of this stepper.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<V>(value: Binding<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : Strideable { }

    /// Creates a stepper with a view label and closed range binding.
    ///
    /// Use this initializer to create a stepper that increments or decrements
    /// a binding to value by the step size you provide within the given bounds.
    /// By setting the bounds, you ensure that the value never goes below or
    /// above the lowest or highest value, respectively.
    ///
    /// The example below shows a stepper that displays the effect of
    /// incrementing or decrementing a value with the step size of `step`
    /// with the bounds defined by `range`:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             Stepper(value: $value,
    ///                     in: range,
    ///                     step: step) {
    ///                 Text("Current: \(value) in \(range.description) " +
    ///                      "stepping by \(step)")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - value: A `Binding` to a value that you provide.
    ///   - bounds: A closed range that describes the upper and lower bounds
    ///     permitted by the stepper.
    ///   - step: The amount to increment or decrement the stepper when the
    ///     user clicks or taps the stepper's increment or decrement buttons,
    ///     respectively.
    ///   - onEditingChanged: A closure that's called when editing begins and
    ///     ends. For example, on iOS, the user may touch and hold the increment
    ///     or decrement buttons on a stepper which causes the execution
    ///     of the `onEditingChanged` closure at the start and end of
    ///     the gesture.
    ///   - label: A view describing the purpose of this stepper.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<V>(value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }, @ViewBuilder label: () -> Label) where V : Strideable { }
}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Stepper where Label == Text {

    /// Creates a stepper with a localized string key binding and increment/decrement actions.
    ///
    /// Use this initializer to create a stepper with a custom title that
    /// executes closures you provide when either of the stepper's increment
    /// or decrement buttons are pressed. This version of `Stepper` doesn't
    /// take a binding to a value, nor does it allow you to specify a range of
    /// acceptable values, or a step value -- it simply calls the closures you
    /// provide when the control's buttons are pressed.
    ///
    /// The example below uses an array that holds a number of `Color` values,
    /// a local state variable, `value`, to set the control's background
    /// color, and title label. When the user clicks or taps on the stepper's
    /// increment or decrement buttons SwiftUI executes the relevant
    /// closure that updates `value`, wrapping the `value` to prevent overflow.
    /// SwiftUI then re-renders the view, updating the text and background
    /// color to match the current index:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let colors: [Color] = [.orange, .red, .gray, .blue, .green,
    ///                                .purple, .pink]
    ///
    ///         func incrementStep() {
    ///             value += 1
    ///             if value >= colors.count { value = 0 }
    ///         }
    ///
    ///         func decrementStep() {
    ///             value -= 1
    ///             if value < 0 { value = colors.count - 1 }
    ///         }
    ///
    ///         var body: some View {
    ///             Stepper("Value: \(value) Color: \(colors[value].description)",
    ///                      onIncrement: incrementStep,
    ///                      onDecrement: decrementStep)
    ///             .background(colors[value])
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - onIncrement: The closure to execute when the user clicks or taps the
    ///       control's plus button.
    ///     - onDecrement: The closure to execute when the user clicks or taps the
    ///       control's minus button.
    ///    - onEditingChanged: A closure that's called when editing begins and
    ///      ends. For example, on iOS, the user may touch and hold the increment
    ///      or decrement buttons on a `Stepper` which causes the execution
    ///      of the `onEditingChanged` closure at the start and end of
    ///      the gesture.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ titleKey: LocalizedStringKey, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: @escaping (Bool) -> Void = { _ in }) { }

    /// Creates a stepper with a string label and increment/decrement actions.
    ///
    /// Use `Stepper(_:onIncrement:onDecrement:onEditingChanged:)` to create a
    /// control with a custom title that executes closures you provide when
    /// the user clicks or taps on the stepper's increment or decrement buttons.
    ///
    /// The example below uses an array that holds a number of `Color` values,
    /// a local state variable, `value`, to set the control's background
    /// color, and title label. When the user clicks or taps on the stepper's
    /// increment or decrement buttons SwiftUI executes the relevant
    /// closure that updates `value`, wrapping the `value` to prevent overflow.
    /// SwiftUI then re-renders the view, updating the text and background
    /// color to match the current index:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let title: String
    ///         let colors: [Color] = [.orange, .red, .gray, .blue, .green,
    ///                                .purple, .pink]
    ///
    ///         func incrementStep() {
    ///             value += 1
    ///             if value >= colors.count { value = 0 }
    ///         }
    ///
    ///         func decrementStep() {
    ///             value -= 1
    ///             if value < 0 { value = colors.count - 1 }
    ///         }
    ///
    ///         var body: some View {
    ///             Stepper(title, onIncrement: incrementStep, onDecrement: decrementStep)
    ///                 .background(colors[value])
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - onIncrement: The closure to execute when the user clicks or taps the
    ///       control's plus button.
    ///     - onDecrement: The closure to execute when the user clicks or taps the
    ///       control's minus button.
    ///    - onEditingChanged: A closure that's called when editing begins and
    ///      ends. For example, on iOS, the user may touch and hold the increment
    ///      or decrement buttons on a `Stepper` which causes the execution
    ///      of the `onEditingChanged` closure at the start and end of
    ///      the gesture.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<S>(_ title: S, onIncrement: (() -> Void)?, onDecrement: (() -> Void)?, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol { }

    /// Creates a stepper with a localized string key label and unlimited range binding.
    ///
    /// Use ``Stepper(_:value:step:onEditingChanged:)`` to create a stepper with a
    /// custom title that increments or decrements a binding to value by the
    /// step size you specify.
    ///
    /// In the example below, the stepper increments or decrements the binding
    /// value by `5` each time the user clicks or taps on the control's
    /// increment or decrement buttons, respectively:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///
    ///         var body: some View {
    ///             Stepper("Current value: \(value), step: \(step)",
    ///                     value: $value,
    ///                     step: step)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - value: A `Binding` to a value that you provide.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's plus or minus button,
    ///       respectively.  Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the
    ///       increment or decrement buttons on a `Stepper` which causes the
    ///       execution of the `onEditingChanged` closure at the start and end
    ///       of the gesture.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : Strideable { }

    /// Creates a stepper with a string label and unlimited range binding.
    ///
    /// Use ``Stepper(_:value:step:onEditingChanged:)`` to create a stepper with a
    /// custom title that increments or decrements a binding to value by the
    /// step size you specify.
    ///
    /// In the example below, the stepper increments or decrements the binding
    /// value by `5` each time one of the user clicks or taps the control's
    /// increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 1
    ///         let step = 5
    ///         let title: String
    ///
    ///         var body: some View {
    ///             Stepper(title, value: $value, step: step)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - value: The `Binding` to a value that you provide.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the
    ///       increment or decrement buttons on a `Stepper` which causes the
    ///       execution of the `onEditingChanged` closure at the start and end
    ///       of the gesture.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<S, V>(_ title: S, value: Binding<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol, V : Strideable { }

    /// Creates a stepper with a localized string key label and closed range binding.
    ///
    /// Use `Stepper(_:value:in:step:onEditingChanged:)` to create a stepper
    /// that increments or decrements a value within a specific range of values
    /// by a specific step size. In the example below, a stepper increments or
    /// decrements a binding to value over a range of `1...50` by `5` at each
    /// press of the stepper's increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         @State private var titleKey = "Stepper"
    ///
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             VStack(spacing: 20) {
    ///                 Text("Current Stepper Value: \(value)")
    ///                 Stepper(titleKey, value: $value, in: range, step: step)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - titleKey: The key for the stepper's localized title describing
    ///       the purpose of the stepper.
    ///     - value: A `Binding` to a value that your provide.
    ///     - bounds: A closed range that describes the upper and lower bounds
    ///       permitted by the stepper.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<V>(_ titleKey: LocalizedStringKey, value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where V : Strideable { }

    /// Creates a stepper with a string label and closed range binding.
    ///
    /// Use `Stepper(_:value:in:step:onEditingChanged:)` to create a stepper
    /// that increments or decrements a value within a specific range of values
    /// by a specific step size. In the example below, a stepper increments or
    /// decrements a binding to value over a range of `1...50` by `5` each time
    /// the user clicks or taps the stepper's increment or decrement buttons:
    ///
    ///     struct StepperView: View {
    ///         @State private var value = 0
    ///         let step = 5
    ///         let range = 1...50
    ///
    ///         var body: some View {
    ///             Stepper("Current: \(value) in \(range.description) stepping by \(step)",
    ///                     value: $value,
    ///                     in: range,
    ///                     step: step)
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///     - title: A string describing the purpose of the stepper.
    ///     - value: A `Binding` to a value that your provide.
    ///     - bounds: A closed range that describes the upper and lower bounds
    ///       permitted by the stepper.
    ///     - step: The amount to increment or decrement `value` each time the
    ///       user clicks or taps the stepper's increment or decrement button,
    ///       respectively. Defaults to `1`.
    ///     - onEditingChanged: A closure that's called when editing begins and
    ///       ends. For example, on iOS, the user may touch and hold the increment
    ///       or decrement buttons on a `Stepper` which causes the execution
    ///       of the `onEditingChanged` closure at the start and end of
    ///       the gesture.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init<S, V>(_ title: S, value: Binding<V>, in bounds: ClosedRange<V>, step: V.Stride = 1, onEditingChanged: @escaping (Bool) -> Void = { _ in }) where S : StringProtocol, V : Strideable { }
}

/// A structure describing how to stroke a `Shape` in a particular style.
///
/// Use this structure to stroke (add a border to) a ``Shape`` in a customized way.
///
/// - Note: You cannot use a `StrokeStyle` when applying a
/// ``View/border(_:)`` to a ``View``. Instead, use ``ShapeStyle``.
///
/// ### Creating a `StrokeStyle`
///
/// Create a `StrokeStyle` using its initilizer,
/// ``StrokeStyle/init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)``.
/// A simple example is below.
///
/// ```
/// struct StrokedCircle: View {
///     var body: some View {
///         Circle()
///             .stroke(StrokeStyle())
///     }
/// }
/// ```
///
/// ### Using a `StrokeStyle`
///
/// Use the ``Shape/stroke(_:style:)``
/// or ``Shape/stroke(style:)`` methods to add a custom stroke
/// to a ``Shape``.
///
/// In addition, two special kinds of ``Shape``s have their own methods
/// for adding strokes with custom styles:
/// 1. ``InsettableShape``: An insettable shape allows you to inset the shape
/// by half the stroke width, then apply the stroke, so that the final
/// result remains inside the original frame. To achieve this effect,
/// use one of these methods:
///     1. ``InsettableShape/strokeBorder(_:style:antialiased:)``
///     2. ``InsettableShape/strokeBorder(style:antialiased:)``
/// 2. ``Path``: A path is a special kind of customizable shape. Use path's
/// special stroking method, ``Path/strokedPath(_:)``, to return another path,
/// rather than a generic shape.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct StrokeStyle : Equatable {

	/// The width of the stroke, specified in points.
    ///
    /// This property can be written to or read directly, but it
    /// can also be specified in the initilizer,
    /// ``StrokeStyle/init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)``.
    ///
    /// ```
    /// struct CircleView: View {
    ///     var body: some View {
    ///         var style = StrokeStyle()
    ///         style.lineWidth = 16
    ///
    ///         return Circle()
    ///             .stroke(style)
    ///     }
    /// }
    /// ```
    public var lineWidth: CGFloat

    /// The style for rendering the endpoint of the stroke line.
    ///
    /// This property can be written to or read directly, but it
    /// can also be specified in the initilizer,
    /// ``StrokeStyle/init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)``.
    ///
    /// ```
    /// struct CircleView: View {
    ///     var body: some View {
    ///         var style = StrokeStyle()
    ///         style.lineCap = .butt
    ///
    ///         return Circle()
    ///             .stroke(style)
    ///     }
    /// }
    /// ```
    public var lineCap: CGLineCap

    /// The style for rendering the joining point of stroked lines
    ///
    /// This property can be written to or read directly, but it
    /// can also be specified in the initilizer,
    /// ``StrokeStyle/init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)``.
    ///
    /// ```
    /// struct CircleView: View {
    ///     var body: some View {
    ///         var style = StrokeStyle()
    ///         style.lineJoin = .bevel
    ///
    ///         return Circle()
    ///             .stroke(style)
    ///     }
    /// }
    /// ```
    public var lineJoin: CGLineJoin

    /// The limit on the ratio of the miter length to stroke width.
    ///
    /// This property can be written to or read directly, but it
    /// can also be specified in the initilizer,
    /// ``StrokeStyle/init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)``.
    ///
    /// ```
    /// struct CircleView: View {
    ///     var body: some View {
    ///         var style = StrokeStyle()
    ///         style.miterLimit = 24.0
    ///
    ///         return Circle()
    ///             .stroke(style)
    ///     }
    /// }
    /// ```
    public var miterLimit: CGFloat

    /// The dash array for allowing the stroke to show discontinuities.
    ///
    /// This property can be written to or read directly, but it
    /// can also be specified in the initilizer,
    /// ``StrokeStyle/init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)``.
    ///
    /// ```
    /// struct CircleView: View {
    ///     var body: some View {
    ///         var style = StrokeStyle()
    ///         style.dash = [25.0, 25.0, 0.0, 25.0]
    ///
    ///         return Circle()
    ///             .stroke(style)
    ///     }
    /// }
    /// ```
    public var dash: [CGFloat]

    /// The dash phase for moving the dashes forward or backward along the stroke.
    ///
    /// This property can be written to or read directly, but it
    /// can also be specified in the initilizer,
    /// ``StrokeStyle/init(lineWidth:lineCap:lineJoin:miterLimit:dash:dashPhase:)``.
    ///
    /// ```
    /// struct CircleView: View {
    ///     var body: some View {
    ///         var style = StrokeStyle()
    ///         style.dashPhase = 3.0
    ///
    ///         return Circle()
    ///             .stroke(style)
    ///     }
    /// }
    /// ```
    public var dashPhase: CGFloat

   	/// Creates a custom stroke style.
   	///
    /// See ``StrokeStyle`` for info on how to use a stroke style once it
    /// is created.
    ///
    /// Play with the parameters in the example below to see how to customize
    /// your own shape style.
    ///
    /// struct WeirdStrokedCircleView: View {
    ///     let style = StrokeStyle(lineWidth: 15.0,
    ///                             lineCap: .butt,
    ///                             lineJoin: .bevel,
    ///                             miterLimit: 24.0,
    ///                             dash: [25.0, 25.0, 0.0, 25.0],
    ///                             dashPhase: 3.0)
    ///     var body: some View {
    ///         Cirlce()
    ///             .stroke(style: style)
    ///     }
    /// }
    ///
   	/// - Parameters:
   	///   - lineWidth: The stroke line width.
   	///   - lineCap: The stroke line cap style.
   	///   - lineJoin: The stroke line join style.
   	///   - miterLimit: The stroke miter limit.
   	///   - dash: The stroke dash array.
   	///   - dashPhase: The stroke dash phase.
    public init(lineWidth: CGFloat = 1, lineCap: CGLineCap = .butt, lineJoin: CGLineJoin = .miter, miterLimit: CGFloat = 10, dash: [CGFloat] = [CGFloat](), dashPhase: CGFloat = 0) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: StrokeStyle, b: StrokeStyle) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension StrokeStyle : Animatable {

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<CGFloat, AnimatablePair<CGFloat, CGFloat>>

    /// The data to animate.
    public var animatableData: StrokeStyle.AnimatableData
}

/// A view that subscribes to a publisher with an action.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct SubscriptionView<PublisherType, Content> : View where PublisherType : Publisher, Content : View, PublisherType.Failure == Never {

    /// The content view.
    public var content: Content

    /// The `Publisher` that is being subscribed.
    public var publisher: PublisherType

    /// The `Action` executed when `publisher` emits an event.
    public var action: (PublisherType.Output) -> Void

    /// Create a view with content the subscribes to a publisher with an action.
    ///
    /// - Parameters:
    ///   - content: The content that you want displayed in the view.
    ///   - publisher: The publisher to use for the subscription.
    ///   - action: The action you want performed in conjunction with the publisher.
    @inlinable public init(content: Content, publisher: PublisherType, action: @escaping (PublisherType.Output) -> Void) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A toggle style that displays a leading label and a trailing switch.
///
/// ![SwitchToggleStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/togglestyle-switch-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State private var status = true
///     var body: some View {
///          Toggle(isOn: $status) {
///              Text("Banana🍌🍌")
///          }
///          .toggleStyle(SwitchToggleStyle())
///          .padding()
///     }
/// }
/// ```
///
/// > To apply this style to a toggle, or to a view that contains toggles, use the `View/toggleStyle(_:)` modifier.
@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
public struct SwitchToggleStyle : ToggleStyle {

    /// Creates a switch toggle style.
    ///
    /// ![SwitchToggleStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/togglestyle-switch-example-1.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State private var status = true
    ///     var body: some View {
    ///          Toggle(isOn: $status) {
    ///              Text("Banana🍌🍌")
    ///          }
    ///          .toggleStyle(SwitchToggleStyle())
    ///          .padding()
    ///     }
    /// }
    /// ```
    public init() { }

    /// Creates a switch style with a tint color.
    @available(iOS 14.0, macOS 11.0, watchOS 7.0, *)
    @available(tvOS, unavailable)
    public init(tint: Color) { }

    /// Creates a view representing the body of a toggle.
    ///
    /// The system calls this method for each `Toggle` instance in a view
    /// hierarchy where this style is the current toggle style.
    ///
    /// - Parameter configuration: The properties of the toggle, such as its
    ///   label and its “on” state.
    public func makeBody(configuration: SwitchToggleStyle.Configuration) -> some View { }


    /// A view that represents the appearance and interaction of a toggle.
    public typealias Body = some View
}

/// A parent view for tab-style navigation.
///
/// `TabView` is a container view that provides tab-style navigation for its child views.
///
/// [tabview-tabitem ->]
/// ### Tab-bar based navigation
///
/// Place child views in a `TabView` and apply `View/tabItem(_:)` to each child for tab-bar style navigation.
///
/// ![TabView Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         TabView {
///             Text("Bananas 🍌🍌")
///                 .tabItem {
///                     Image(systemName: "1.circle.fill")
///                     Text("🍌🍌")
///                 }
///             Text("Apples 🍏🍏")
///                 .tabItem {
///                     Image(systemName: "2.square.fill")
///                     Text("🍏🍏")
///                 }
///             Text("Peaches 🍑🍑")
///                 .tabItem {
///                     Image(systemName: "3.square.fill")
///                     Text("🍑🍑")
///                 }
///         }
///         .font(.headline)
///     }
/// }
/// ```
/// [<-]
/// [tabview-style ->]
/// ### Page-style navigation
///
/// Place child views in a `TabView` with a `View.tabViewStyle(PageTabViewStyle())` attached to the `TabView` for a page-style style navigation.
///
/// The following example creates a paginated view with the three `Text` child views as individual pages.
///
/// ![TabView Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-2.gif)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         TabView {
///             Text("Bananas 🍌🍌")
///             Text("Apples 🍏🍏")
///             Text("Peaches 🍑🍑")
///         }
///         .foregroundColor(Color.white)
///         .background(Color.yellow)
///         .tabViewStyle(PageTabViewStyle())
///     }
/// }
/// ```
///
/// `TabView` also supports dynamically loading pages. The example above can be re-expressed as the following:
///
/// ![TabView Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-3.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var items = ["Bananas 🍌🍌", "Apples 🍏🍏", "Peaches 🍑🍑"]
///
///     var body: some View {
///         TabView {
///             ForEach(items, id: /\.self) {
///                 Text($0)
///             }
///         }
///         .tabViewStyle(PageTabViewStyle())
///     }
/// }
/// ```
///
/// This example supports loading a dynamic list of pages from `items`.
///
/// A page-styled `TabView` will add a row of page indicator(s) at the bottom of the container by default. If `View/tabItem(_:)` is used, these indicators each take the form of the corresponding tab item's primary image. If not - these page indicators resort to system defaults.
///
/// To disable page indicators altogether, apply a `PageIndexViewStyle` using `View/indexViewStyle(_:)`, like so:
///
/// ![TabView Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-4.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var items = ["Bananas 🍌🍌", "Apples 🍏🍏", "Peaches 🍑🍑"]
///
///     var body: some View {
///         TabView {
///             ForEach(items, id: /\.self) {
///                 Text($0)
///             }
///         }
///         .tabViewStyle(PageTabViewStyle())
///         .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .never))
///     }
/// }
/// ```
/// [<-]
/// [tabview-tag ->]
/// ### Handling tab-selection
///
/// `TabView` provides the ability to observe and/or set the active tab selection via its initializer `TabView/init(selection:content)`, and the modifier `View/tag(_:)`.
///
/// Here is an example that writes tab selection to a state variable:
///
/// ![TabView Example 5](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-5.gif)
///
/// ```
/// struct ExampleView: View {
///     enum TabItem {
///         case bananas
///         case apples
///         case peaches
///     }
///
///     @State var selectedItem: TabItem = .bananas
///
///     var body: some View {
///         TabView(selection: $selectedItem) {
///             Text("Bananas 🍌🍌")
///                 .tabItem {
///                     Image(systemName: "1.circle.fill")
///                     Text("🍌🍌")
///                 }
///                 .tag(TabItem.bananas)
///
///             Text("Apples 🍏🍏")
///                 .tabItem {
///                     Image(systemName: "2.square.fill")
///                     Text("🍏🍏")
///                 }
///                 .tag(TabItem.apples)
///
///             Text("Peaches 🍑🍑")
///                 .tabItem {
///                     Image(systemName: "3.square.fill")
///                     Text("🍑🍑")
///                 }
///                 .tag(TabItem.peaches)
///         }
///     }
/// }
/// ```
///
/// In this example, each tab item is assigned a unique tag using the user-defined, hashable enum `TabItem`. `TabView` in turn takes a binding to the tab selection, `$selectedItem`, and updates it whenever a new tab is selected. `$selectedItem` in turn can also be used to programmatically control tab-selection, as bindings work bidirectionally.
///
/// Note that `View/tag(_:)` accepts any `Hashable` value. An enum was used in the previous example, but it could've just as easily been a `String` or an `Int`.
///
/// For example, the following uses a traditional 0-based tab indexing:
///
/// ![TabView Example 6](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TabView-example-6.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var selectedItem: Int = 0
///
///     var body: some View {
///         TabView(selection: $selectedItem) {
///             Text("Bananas 🍌🍌")
///                 .tag(0)
///
///             Text("Apples 🍏🍏")
///                 .tag(1)
///
///             Text("Peaches 🍑🍑")
///                 .tag(2)
///         }
///     }
/// }
/// ```
/// [<-]
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
public struct TabView<SelectionValue, Content> : View where SelectionValue : Hashable, Content : View {

    /// Creates an instance that selects from content associated with
    /// `Selection` values.
    public init(selection: Binding<SelectionValue>?, @ViewBuilder content: () -> Content) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
extension TabView where SelectionValue == Int {

	/// Creates a tab view from a view builder. The tab view maintains its own selection.
	///
	/// This is useful if you don't want to have to pass in your own binding
	/// selection index, and just want the view to default at the first page.
	/// You will still be able to move tabs, but you won't be able to programmatically
	/// change tabs from outside the view.
    public init(@ViewBuilder content: () -> Content) { }
}

/// This protocol is used to change the appearance and interaction of a `TabView`.
///
/// This protocol does not make its interface public and cannot be customized. The only
/// types available are the ones included in the framework and are platform dependent:
/// - ``DefaultTabViewStyle`` (all platforms)
/// - ``PageTabViewStyle`` (NO macOS)
/// - CarouselTabViewStyle (watchOS only)
///
/// To learn more about each style, visit their pages.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol TabViewStyle{ }
extension TabViewStyle {
}

/// A gesture that recognizes one or more taps.
///
/// To recognize a tap gesture on a view, create and configure the gesture, and
/// then add it to the view using the `View/gesture(_:including:)` modifier.
/// The following code adds a tap gesture to a `Circle` that toggles the color
/// of the circle.
///
///     struct TapGestureView: View {
///         @State var tapped = false
///
///         var tap: some Gesture {
///             TapGesture(count: 1)
///                 .onEnded { _ in self.tapped = !self.tapped }
///         }
///
///         var body: some View {
///             Circle()
///                 .fill(self.tapped ? Color.blue : Color.red)
///                 .frame(width: 100, height: 100, alignment: .center)
///                 .gesture(tap)
///         }
///     }
@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
public struct TapGesture : Gesture {

    /// The required number of tap events.
    public var count: Int

    /// Creates a tap gesture with the number of required taps.
    ///
    /// - Parameter count: The required number of taps to complete the tap
    ///   gesture.
    public init(count: Int = 1) { }

    /// The type representing the gesture's value.
    public typealias Value = ()

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}


/// A view that displays read-only text.
///
/// `Text` draws a string in your app and comes equipped with modifiers to customize your text. This view sizes itself to fit the provided content, styling and containing view.
///
/// ![Text Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-example-1.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Text("🍌🍌")
///     }
/// }
/// ```
///
/// `Text` is most commonly initialized with a string, however, it has 9 different initializers.
///
/// For example, use `Text/init(_:style:)` to display a date in a `Text` view.
///
///  ![Text Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-example-2.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Text(Date(), style: .date)
///     }
/// }
/// ```
///
/// `Text` also accepts 12 unique modifiers to customize your string.
///
///  ![Text Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-example-3.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Text(Date(), style: .date)
///             .underline(true, color: .orange)
///             .font(.system(size: 20, weight: .bold, design: .rounded))
///     }
/// }
/// ```
///
/// `Text` conforms to the `View` protocol. Therefore, any modifiers that return `some View`, such as `View/foregroundColor(_:)`, are compatible with `Text`.
///
///  ![Text Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-example-4.png)
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         Text(Date(), style: .date)
///             .font(.system(size: 20, weight: .bold, design: .rounded))
///             .foregroundColor(.orange)
///     }
/// }
/// ```
///
/// **Remember**, any modifier that returns `some View` must be used after modifiers that return `Text`.
///
/// If your app is localized, you can display localized text by passing the key to the initializer. For example, if you used the localization key of "banana" and mapped it to 🍌🍌 for your current location, the localized string could be displayed with this line:
///
///     struct ExampleView: View {
///         var body: some View {
///             Text("banana")
///         }
///     }
///
/// See `Text/init(_:tableName:bundle:comment:)` for more information on how to initialize `Text` with localized strings. This initializer can be used to display localized keys coming from a non-standard bundle or string table.
///
/// Images can be displayed in a text view. This enables your app to optionally include them inside a text string, where they will resize based on your view's font. See `Text/init(_:)-9a226` for more on initializing `Text` with images.
///
/// Use the `View` modifiers `View/lineLimit(_:)`, `View/allowsTightening(_:)`,
/// `View/minimumScaleFactor(_:)`, and `View/truncationMode(_:)` to configure how `Text` handles space constraints.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Text : Equatable {

    /// Creates a text view that displays a string literal without localization.
    ///
    /// Use this initializer to create a text view with a string literal without
    /// performing localization:
    ///
    /// ```
    /// struct VerbatimTextView: View {
    ///     var body: some View {
    ///         Text(verbatim: "pencil") // Displays the string "pencil" in any locale.
    ///     }
    /// }
    /// ```
    ///
    /// If you want to localize a string literal before displaying it, use the
    /// `Text/init(_:tableName:bundle:comment:)` initializer instead. If you
    /// want to display a string variable, use the `Text/init(_:)-9d1g4`
    /// initializer, which also bypasses localization.
    ///
    /// - Parameter content: A string to display without localization.
    @inlinable public init(verbatim content: String) { }

    /// Creates a text view that displays a stored string without localization.
    ///
    /// Use this intializer to create a text view that displays — without
    /// localization — the text in a string variable.
    ///
    /// ```
    /// struct VerbatimTextView: View {
    ///     var someString = "Don't localize me"
    ///     var body: some View {
    ///         Text(someString) // Displays the contents of `someString` without localization.
    ///     }
    /// }
    /// ```
    ///
    /// SwiftUI doesn't call the `init(_:)` method when you initialize a text
    /// view with a string literal as the input. Instead, a string literal
    /// triggers the `Text/init(_:tableName:bundle:comment:)` method — which
    /// treats the input as a `LocalizedStringKey` instance — and attempts to
    /// perform localization.
    ///
    /// By default, SwiftUI assumes that you don't want to localize stored
    /// strings, but if you do, you can first create a localized string key from
    /// the value, and initialize the text view with that. Using a key as input
    /// triggers the `Text/init(_:tableName:bundle:comment:)` method instead.
    ///
    /// - Parameter content: The string value to display without localization.
    public init<S>(_ content: S) where S : StringProtocol { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Text, b: Text) -> Bool { }
}

extension Text {

    /// Creates an instance that wraps an `Image`, suitable for concatenating
    /// with other `Text`
    ///
    /// In the example below, we're able to turn an ``Image`` into a text
    /// view so that we can add them together and return a side-by-side
    /// view:
    ///
    /// ```
    /// struct BookView: View {
    ///     let image = Image(systemName: "book")
    ///     var body: some View {
    ///         Text(image) + Text("The Art of War")
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter image: The Image view to turn into a view of type `Text`
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public init(_ image: Image) { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Text {

    /// Creates a text view that displays the formatted representation of a value.
    ///
    /// Use this initializer to create a text view that will format `subject`
    /// using `formatter`.
    ///
    /// - Note: The first parameter to this initializer must either of type
    /// [NSObject](https://developer.apple.com/documentation/objectivec/nsobject),
    /// like [NSNumber](https://developer.apple.com/documentation/foundation/nsnumber),
    /// or [ReferenceConvertible](https://developer.apple.com/documentation/foundation/referenceconvertible),
    /// like [Date](https://developer.apple.com/documentation/foundation/date).
    /// The type will depend on the formatter.
    ///
    /// See [Formatter](https://developer.apple.com/documentation/foundation/formatter)
    /// for more info on creating a formatter.
    ///
    /// ```
    /// struct ByteCountView: View {
    ///     var body: some View {
    ///         Text(NSNumber(value: 19728),
    ///              formatter: ByteCountFormatter()) //"20 KB"
    ///     }
    /// }
    /// ```
    ///
    /// - Paramters:
    ///   - subject: The item to be formatted and then displayed by the `Text` view.
    ///   - formatter: The `Formatter` to use in formatting the subject.
    public init<Subject>(_ subject: Subject, formatter: Formatter) where Subject : ReferenceConvertible { }

    /// Creates a text view that displays the formatted representation of a value.
    ///
    /// Use this initializer to create a text view that will format `subject`
    /// using `formatter`.
    ///
    /// - Note: The first parameter to this initializer must either of type
    /// [NSObject](https://developer.apple.com/documentation/objectivec/nsobject),
    /// like [NSNumber](https://developer.apple.com/documentation/foundation/nsnumber),
    /// or [ReferenceConvertible](https://developer.apple.com/documentation/foundation/referenceconvertible),
    /// like [Date](https://developer.apple.com/documentation/foundation/date).
    /// The type will depend on the formatter.
    ///
    /// See [Formatter](https://developer.apple.com/documentation/foundation/formatter)
    /// for more info on creating a formatter.
    ///
    /// ```
    /// struct ByteCountView: View {
    ///     var body: some View {
    ///         Text(NSNumber(value: 19728),
    ///              formatter: ByteCountFormatter()) //"20 KB"
    ///     }
    /// }
    /// ```
    ///
    /// - Paramters:
    ///   - subject: The item to be formatted and then displayed by the `Text` view.
    ///   - formatter: The `Formatter` to use in formatting the subject.
    public init<Subject>(_ subject: Subject, formatter: Formatter) where Subject : NSObject { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Text {

    /// A predefined style used to display a Date.
    ///
    /// Use this structure along with the ``Text/init(_:style:)``
    /// initializer to easily style a ``Date``.
    ///
    /// Options include:
    /// - ``Text/DateStyle/time``: The time component only.
    /// - ``Text/DateStyle/date``: The date component only.
    /// - ``Text/DateStyle/relative``: The amount of time between the date
    /// and now. (Updated in real time)
    /// - ``Text/DateStyle/offset``: The positive or negative amount of
    /// time between the date and now. (Updates in real time)
    /// - ``Text/DateStyle/time``: A timer that starts at the date. (Updates
    /// in real time)
    ///
    /// ```
    /// struct LotsOfTimesView: View {
    ///     let time = Date() //Sets time from when the view appears
    ///
    ///     var body: some View {
    ///         Text(time, style: .time) //"5:08 PM"
    ///         Text(time, style: .date) //"February 10, 2021"
    ///         Text(time, style: .relative) //"2 hr, 3 min"
    ///         Text(time, style: .offset) //"+2 hours"
    ///         Text(time, style: .timer) //"2:04:19"
    ///     }
    /// }
    /// ```
    public struct DateStyle {

        /// A style displaying only the time component for a date.
        ///
        /// Use this structure along with the ``Text/init(_:style:)``
        /// initializer to easily style a ``Date``.
        ///
        /// ```
        /// struct TimeView: View {
        ///     let time = Date() //Sets time from when the view appears
        ///
        ///     var body: some View {
        ///         Text(time, style: .time) //"5:08 PM"
        ///     }
        /// }
        /// ```
        public static let time: Text.DateStyle

        /// A style displaying a date.
        ///
        /// Use this structure along with the ``Text/init(_:style:)``
        /// initializer to easily style a ``Date``.
        ///
        /// ```
        /// struct DateView: View {
        ///     let time = Date() //Sets time from when the view appears
        ///
        ///     var body: some View {
        ///         Text(time, style: .date) //"February 10, 2021"
        ///     }
        /// }
        /// ```
        public static let date: Text.DateStyle

        /// A style displaying a date as relative to now.
        ///
        /// Use this structure along with the ``Text/init(_:style:)``
        /// initializer to easily style a ``Date``.
        ///
        /// ```
        /// struct RelativeView: View {
        ///     let time = Date() //Sets time from when the view appears
        ///
        ///     var body: some View {
        ///         Text(time, style: .relative) //"2 hr, 3 min"
        ///     }
        /// }
        /// ```
        public static let relative: Text.DateStyle

        /// A style displaying a date as offset from now.
        ///
        /// Use this structure along with the ``Text/init(_:style:)``
        /// initializer to easily style a ``Date``.
        ///
        /// ```
        /// struct OffsetView: View {
        ///     let time = Date() //Sets time from when the view appears
        ///
        ///     var body: some View {
        ///         Text(time, style: .offset) //"+2 hours"
        ///     }
        /// }
        /// ```
        public static let offset: Text.DateStyle

        /// A style displaying a date as timer counting from now.
        ///
        /// Use this structure along with the ``Text/init(_:style:)``
        /// initializer to easily style a ``Date``.
        ///
        /// ```
        /// struct TimerView: View {
        ///     let time = Date() //Sets time from when the view appears
        ///
        ///     var body: some View {
        ///         Text(time, style: .timer) //"2:04:19"
        ///     }
        /// }
        /// ```
        public static let timer: Text.DateStyle
    }

    /// Creates an instance that displays localized dates and times using a specific style.
    ///
    /// Use this initializer along with ``Text/DateStyle`` to style the
    /// date. See `DateStyle` for the options of te style parameter.
    ///
    /// See ``Date`` for more on how to make and use a date.
    ///
    /// ```
    /// struct TimerView: View {
    ///     let time = Date() //Sets time from when the view appears
    ///
    ///     var body: some View {
    ///         Text(time, style: .timer) //"2:04:19"
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - date: The target date to display.
    ///     - style: The style used when displaying a date.
    public init(_ date: Date, style: Text.DateStyle) { }

    /// Creates an instance that displays a localized range between two dates.
    ///
    /// Use this initializer to automatically format a range of dates
    /// based on the user's locale.
    ///
    /// See ``Date`` for more on how to create and manage a date.
    ///
    /// ```
    /// struct TimerView: View {
    ///     let time = Date() //Sets time from when the view appears
    ///
    ///     var body: some View {
    ///         Text(time...time.addingTimeInterval(600)) //"10:30 AM-10:40 AM"
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - dates: The range of dates to display
    public init(_ dates: ClosedRange<Date>) { }

    /// Creates an instance that displays a localized time interval.
    ///
    /// ```
    /// struct TimerView: View {
    ///     let time = Date() //Sets time from when the view appears
    ///
    ///     var body: some View {
    ///         Text(DateInterval(start: time,
    ///                           end: time.addingTimeInterval(600))) //"10:30 AM-10:40 AM"
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///     - interval: The date interval to display
    public init(_ interval: DateInterval) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Text {

    /// Creates a text view that displays localized content identified by a key.
    ///
    /// Use this intializer to look for the `key` parameter in a localization
    /// table and display the associated string value in the initialized text
    /// view. If the initializer can't find the key in the table, or if no table
    /// exists, the text view displays the string representation of the key
    /// instead.
    ///
    /// ```
    /// struct PencilView: View {
    ///     var body: some View {
    ///         Text("pencil") // Localizes the key if possible, or displays "pencil" if not.
    ///     }
    /// }
    /// ```
    ///
    /// When you initialize a text view with a string literal, the view triggers
    /// this initializer because it assumes you want the string localized, even
    /// when you don't explicitly specify a table, as in the above example. If
    /// you haven't provided localization for a particular string, you still get
    /// reasonable behavior, because the initializer displays the key, which
    /// typically contains the unlocalized string.
    ///
    /// If you initialize a text view with a string variable rather than a
    /// string literal, the view triggers the `Text/init(_:)-9d1g4`
    /// initializer instead, because it assumes that you don't want localization
    /// in that case. If you do want to localize the value stored in a string
    /// variable, you can choose to call the `init(_:tableName:bundle:comment:)`
    /// initializer by first creating a `LocalizedStringKey` instance from the
    /// string variable:
    ///
    /// ```
    /// struct PencilView: View {
    ///     let someString = "pencil"
    ///     var body: some View {
    ///         Text(LocalizedStringKey(someString)) // Localizes the contents of `someString`.
    ///     }
    /// }
    /// ```
    ///
    /// If you have a string literal that you don't want to localize, use the
    /// `Text/init(verbatim:)` initializer instead.
    ///
    /// - Parameters:
    ///   - key: The key for a string in the table identified by `tableName`.
    ///   - tableName: The name of the string table to search. If `nil`, use the
    ///     table in the `Localizable.strings` file.
    ///   - bundle: The bundle containing the strings file. If `nil`, use the
    ///     main bundle.
    ///   - comment: Contextual information about this key-value pair.
    public init(_ key: LocalizedStringKey, tableName: String? = nil, bundle: Bundle? = nil, comment: StaticString? = nil) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Text {
    /// Concatenates two text views into one new text view.
    ///
    /// ![plus Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-plus-example-1.png)
    ///
    /// ```
    ///struct ExampleView: View {
    ///     var body: some View {
    ///         Text("Banana🍌🍌")
    ///             .font(.title)
    ///         + Text("Apple🍎🍎")
    ///             .font(.title)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - lhs: The first text view with text to combine.
    ///   - rhs: The second text view with text to combine.
    ///
    /// - Returns: A new text view containing the combined contents of the two
    ///   input text views.
    public static func + (lhs: Text, rhs: Text) -> Text { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Text {

    /// The type of truncation to apply to a line of text when it's too long to
    /// fit in the available space.
    ///
    /// When a text view contains more text than it's able to display, the view
    /// might truncate the text and place an ellipsis (...) at the truncation
    /// point. Use the `View/truncationMode(_:)` modifier with one of the
    /// `TruncationMode` values to indicate which part of the text to
    /// truncate, either at the beginning, in the middle, or at the end.
    ///
    /// ```
    /// struct TruncatedTextView: View {
    ///     var body: some View {
    ///         Text("abcdefghijklmnopqrstuvwxyz")
    ///             .frame(width: 55, height: 20)
    ///             .truncationMode(.middle) //"ab...yz"
    ///     }
    /// }
    /// ```
    public enum TruncationMode {

        /// Truncate at the beginning of the line.
        ///
        /// Use this kind of truncation to omit characters from the beginning of
        /// the string. For example, you could truncate the English alphabet as
        /// "...wxyz".
        ///
        /// Use this case along with `View/truncationMode(_:)` to truncate
        /// the beginning of the text.
        ///
        /// ```
        /// struct HeadTextView: View {
        ///     var body: some View {
        ///         Text("abcdefghijklmnopqrstuvwxyz")
        ///             .frame(width: 55, height: 20)
        ///             .truncationMode(.head) //"...wxyz"
        ///     }
        /// }
        /// ```
        case head

        /// Truncate at the end of the line.
        ///
        /// Use this kind of truncation to omit characters from the end of the
        /// string. For example, you could truncate the English alphabet as
        /// "abcd...".
        ///
        /// ```
        /// struct HeadTextView: View {
        ///     var body: some View {
        ///         Text("abcdefghijklmnopqrstuvwxyz")
        ///             .frame(width: 55, height: 20)
        ///             .truncationMode(.tail) //"abcd..."
        ///     }
        /// }
        /// ```
        case tail

        /// Truncate in the middle of the line.
        ///
        /// Use this kind of truncation to omit characters from the middle of
        /// the string. For example, you could truncate the English alphabet as
        /// "ab...yz".
        ///
        /// ```
        /// struct HeadTextView: View {
        ///     var body: some View {
        ///         Text("abcdefghijklmnopqrstuvwxyz")
        ///             .frame(width: 55, height: 20)
        ///             .truncationMode(.middle) //"ab...yz"
        ///     }
        /// }
        /// ```
        case middle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Text.TruncationMode, b: Text.TruncationMode) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }

    /// A scheme for transforming the capitalization of characters within text.
    ///
    /// Use this enumeration with the ``View/textCase(_:)`` modifier
    /// to transform the case of text.
    ///
    /// ```
    /// struct FriendlyTextView: View {
    ///     var body: some View {
    ///         Text("Hello")
    ///             .textCase(Case.uppercase) //"HELLO"
    ///     }
    /// }
    /// ```
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public enum Case {

        /// Displays text in all uppercase characters.
        ///
        /// Use this with the ``View/textCase(_:)`` modifier
        /// to capitalize text.
        ///
        /// For example, "Hello" would be displayed as "HELLO".
        ///
        /// ```
        /// struct FriendlyTextView: View {
        ///     var body: some View {
        ///         Text("Hello")
        ///             .textCase(.uppercase) //"HELLO"
        ///     }
        /// }
        /// ```
        ///
        /// - SeeAlso: `StringProtocol.uppercased(with:)`
        case uppercase

        /// Displays text in all lowercase characters.
        ///
        /// Use this with the ``View/textCase(_:)`` modifier
        /// to lowercase text.
        ///
        /// For example, "Hello" would be displayed as "hello".
        ///
        /// ```
        /// struct FriendlyTextView: View {
        ///     var body: some View {
        ///         Text("Hello")
        ///             .textCase(.lowercase) //"hello"
        ///     }
        /// }
        /// ```
        ///
        /// - SeeAlso: `StringProtocol.lowercased(with:)`
        case lowercase

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Text.Case, b: Text.Case) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Text : View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Text {

    /// Sets the color of the text displayed by this view.
    ///
    /// Use this method to change the color of the text rendered by a text view.
    ///
    /// For example, you can change the color of Banana🍌🍌 to yellow and Apple🍎🍎 to red.
    ///
    /// ![foregroundColor Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-foregroundColor-example-1.png)
    ///
    ///     struct ExampleView: View {
    ///        var body: some View {
    ///            VStack {
    ///                Text("Banana🍌🍌")
    ///                    .foregroundColor(.yellow)
    ///                Text("Apple 🍎🍎")
    ///                    .foregroundColor(.red)
    ///                Text("Peach 🍑🍑")
    ///                    .foregroundColor(.orange)
    ///            }
    ///            .font(.largeTitle)
    ///        }
    ///     }
    ///
    ///
    ///
    /// - Parameter color: The color to use when displaying this text.
    /// - Returns: A text view that uses the color value you supply.
    public func foregroundColor(_ color: Color?) -> Text { }

    /// Sets the default font for text in the view.
    ///
    /// Use `font(_:)` to apply a specific font to an individual
    /// Text View, or all of the text views in a container.
    ///
    /// In the example below, the first text field has a font set directly,
    /// while the font applied to the following container applies to all of the
    /// text views inside that container:
    ///
    ///     VStack {
    ///         Text("Font applied to a text view.")
    ///             .font(.largeTitle)
    ///
    ///         VStack {
    ///             Text("These two text views have the same font")
    ///             Text("applied to their parent view.")
    ///         }
    ///         .font(.system(size: 16, weight: .light, design: .default))
    ///     }
    ///
    ///
    /// ![Applying a font to a single text view or a view container](SwiftUI-view-font.png)
    ///
    /// - Parameter font: The font to use when displaying this text.
    /// - Returns: Text that uses the font you specify.
    public func font(_ font: Font?) -> Text { }
    ///
    /// Sets the font weight of the text.
    ///
    /// ![fontWeight Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-fontWeight-example-1.png)
    ///
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             VStack {
    ///                 Text("ultraLight 🍌")
    ///                     .fontWeight(Font.Weight.ultraLight)
    ///                 Text("thin🍌")
    ///                     .fontWeight(Font.Weight.thin)
    ///                 Text("light🍌")
    ///                     .fontWeight(Font.Weight.light)
    ///                 Text("regular🍌")
    ///                     .fontWeight(Font.Weight.regular)
    ///                 Text("medium🍌")
    ///                     .fontWeight(Font.Weight.medium)
    ///                 Text("semibold🍌")
    ///                     .fontWeight(Font.Weight.semibold)
    ///                 Text("bold🍌")
    ///                     .fontWeight(Font.Weight.bold)
    ///                 Text("heavy🍌")
    ///                     .fontWeight(Font.Weight.heavy)
    ///                 Text("black🍌")
    ///                     .fontWeight(Font.Weight.black)
    ///            }
    ///            .font(.title)
    ///         }
    ///     }
    ///
    ///
    /// - Parameter weight: One of the available font weights.
    ///
    /// - Returns: Text that uses the font weight you specify.
    public func fontWeight(_ weight: Font.Weight?) -> Text { }

    /// Applies a bold font weight to the text.
    ///
    /// ![Bold Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-bold-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Text("Banana 🍌🍌")
    ///             .bold()
    ///             .font(.title)
    ///     }
    /// }
    /// ```
    ///
    /// - Returns: Bold text.
    public func bold() -> Text { }

    /// Applies italics to the text.
    ///
    /// ![Italic Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-italic-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Text("Banana 🍌🍌")
    ///             .italic()
    ///             .font(.title)
    ///     }
    /// }
    /// ```
    ///
    /// - Returns: Italic text.
    public func italic() -> Text { }

    /// Applies a strikethrough to the text.
    ///
    /// ![Strikethrough Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-strikethrough-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Text("Banana 🍌🍌")
    ///             .strikethrough(false)
   ///              .font(.title)
    ///
    ///         Text("Banana 🍌🍌")
    ///             .strikethrough()
    ///             .font(.title)
    ///
    ///         Text("Banana 🍌🍌")
    ///             .strikethrough(true, color: .yellow)
    ///             .font(.title)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - active: A Boolean value that indicates whether the text has a
    ///     strikethrough applied.
    ///   - color: The color of the strikethrough. If `color` is `nil`, the
    ///     strikethrough uses the default foreground color.
    ///
    /// - Returns: Text with a line through its center.
    public func strikethrough(_ active: Bool = true, color: Color? = nil) -> Text { }

    /// Applies an underline to the text.
    ///
    /// ![Underline Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-underline-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         Text("Banana 🍌🍌 ")
    ///             .underline(false)
   ///             .font(.title)
    ///
    ///         Text("Banana 🍌🍌 ")
    ///             .underline()
    ///             .font(.title)
    ///
    ///         Text("Banana 🍌🍌 ")
    ///             .underline(true, color: .yellow)
    ///             .font(.title)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - active: A Boolean value that indicates whether the text has an
    ///     underline.
    ///   - color: The color of the underline. If `color` is `nil`, the
    ///     underline uses the default foreground color.
    ///
    /// - Returns: Text with a line running along its baseline.
    public func underline(_ active: Bool = true, color: Color? = nil) -> Text { }

    /// Sets the spacing, or kerning, between characters.
    ///
    /// Kerning defines the offset, in points, that a text view should shift
    /// characters from the default spacing. Use positive kerning to widen the
    /// spacing between characters. Use negative kerning to tighten the spacing
    /// between characters.
    ///
    /// ```
    /// struct KerningView: View {
    ///     var body: some View {
    ///         VStack(alignment: .leading) {
    ///             Text("ABCDEF")
    ///                 .kerning(-3)
    ///             Text("ABCDEF")
    ///             Text("ABCDEF")
    ///                 .kerning(3)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// The last character in the first case, which uses negative kerning,
    /// experiences cropping because the kerning affects the trailing edge of
    /// the text view as well.
    ///
    /// Kerning attempts to maintain ligatures. For example, the Hoefler Text
    /// font uses a ligature for the letter combination _ffl_, as in the word
    /// _raffle_.
    ///
    /// The *ffl* letter combination keeps a constant shape as the other letters
    /// move together or apart. Beyond a certain point in either direction,
    /// however, kerning does disable nonessential ligatures.
    ///
    /// - Important: If you add both the `Text/tracking(_:)` and
    ///   `Text/kerning(_:)` modifiers to a view, the view applies the
    ///   tracking and ignores the kerning.
    ///
    /// - Parameter kerning: The spacing to use between individual characters in
    ///   this text.
    ///
    /// - Returns: Text with the specified amount of kerning.
    public func kerning(_ kerning: CGFloat) -> Text { }

    /// Sets the tracking for the text.
    ///
    /// Tracking adds space, measured in points, between the characters in the
    /// text view. A positive value increases the spacing between characters,
    /// while a negative value brings the characters closer together.
    ///
    /// ```
    /// struct TrackingView: View {
    ///     var body: some View {
    ///         VStack(alignment: .leading) {
    ///             Text("ABCDEF")
    ///                 .tracking(-3)
    ///             Text("ABCDEF")
    ///             Text("ABCDEF")
    ///                 .tracking(3)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// The code above uses an unusually large amount of tracking to make it
    /// easy to see the effect.
    ///
    /// The effect of tracking resembles that of the `Text/kerning(_:)`
    /// modifier, but adds or removes trailing whitespace, rather than changing
    /// character offsets. Also, using any nonzero amount of tracking disables
    /// nonessential ligatures, whereas kerning attempts to maintain ligatures.
    ///
    /// - Important: If you add both the `Text/tracking(_:)` and
    ///   `Text/kerning(_:)` modifiers to a view, the view applies the
    ///   tracking and ignores the kerning.
    ///
    /// - Parameter tracking: The amount of additional space, in points, that
    ///   the view should add to each character cluster after layout.
    ///
    /// - Returns: Text with the specified amount of tracking.
    public func tracking(_ tracking: CGFloat) -> Text { }

    /// Sets the vertical offset for the text relative to its baseline.
    ///
    /// Change the baseline offset to move the text in the view (in points) up
    /// or down relative to its baseline. The bounds of the view expand to
    /// contain the moved text.
    ///
    /// ```
    /// struct BaselineOffsetView: View {
    ///     var body: some View {
    ///         HStack(alignment: .top) {
    ///             Text("Hello")
    ///                 .baselineOffset(-10)
    ///                 .border(Color.red)
    ///             Text("Hello")
    ///                 .border(Color.green)
    ///             Text("Hello")
    ///                 .baselineOffset(10)
    ///                 .border(Color.blue)
    ///         }
    ///         .background(Color(white: 0.9))
    ///     }
    /// }
    /// ```
    ///
    /// By drawing a border around each text view, you can see how the text
    /// moves, and how that affects the view.
    ///
    /// The first view, with a negative offset, grows downward to handle the
    /// lowered text. The last view, with a positive offset, grows upward. The
    /// enclosing `HStack` instance, shown in gray, ensures all the text views
    /// remain aligned at their top edge, regardless of the offset.
    ///
    /// - Parameter baselineOffset: The amount to shift the text vertically (up
    ///   or down) relative to its baseline.
    ///
    /// - Returns: Text that's above or below its baseline.
    public func baselineOffset(_ baselineOffset: CGFloat) -> Text { }
}

extension Text.DateStyle : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Text.DateStyle, b: Text.DateStyle) -> Bool { }
}

extension Text.DateStyle : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws { }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Text.TruncationMode : Equatable {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Text.TruncationMode : Hashable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Text.Case : Equatable {
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension Text.Case : Hashable {
}

/// An enum indicating available alignments for text that spans multiple-lines.
///
/// This is used in conjuction with `View/multilineTextAlignment(_:)`, for example:
///
/// ![Text alignment center](textalignment-center.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        Text("Gregor's eyes then turned to the window, and the overcast weather--he could hear raindrops hitting against the metal window ledge--completely depressed him.")
///            .padding(20)
///            .font(.system(size: 10))
///            .multilineTextAlignment(TextAlignment.center)
///    }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public enum TextAlignment : Hashable, CaseIterable {

  	/// Aligns each line of the text to the leading edge, left in left-to-right languages,
  	/// and right in right-to-left languages.
    ///
    /// For example:
    ///
    /// ![Text alignment leading](textalignment-leading.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///
    ///    var body: some View {
    ///        Text("Gregor's eyes then turned to the window, and the overcast weather--he could hear raindrops hitting against the metal window ledge--completely depressed him.")
    ///            .padding(20)
    ///            .font(.system(size: 10))
    ///            .multilineTextAlignment(TextAlignment.leading)
    ///    }
    /// }
    /// ```
    case leading

    /// Aligns each line of the text with the center of the view.
    ///
    /// For example:
    ///
    /// ![Text alignment center](textalignment-center.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///
    ///    var body: some View {
    ///        Text("Gregor's eyes then turned to the window, and the overcast weather--he could hear raindrops hitting against the metal window ledge--completely depressed him.")
    ///            .padding(20)
    ///            .font(.system(size: 10))
    ///            .multilineTextAlignment(TextAlignment.center)
    ///    }
    /// }
    /// ```
    case center

    /// Aligns each line of the text to the trailing edge, right in left-to-right languages,
    /// and left in right-to-left languages.
    ///
    /// For example:
    ///
    /// ![Text alignment trailing](textalignment-trailing.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///
    ///    var body: some View {
    ///        Text("Gregor's eyes then turned to the window, and the overcast weather--he could hear raindrops hitting against the metal window ledge--completely depressed him.")
    ///            .padding(20)
    ///            .font(.system(size: 10))
    ///            .multilineTextAlignment(TextAlignment.trailing)
    ///    }
    /// }
    /// ```
    case trailing

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: TextAlignment, b: TextAlignment) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [TextAlignment]

    /// A collection of all values of this type.
    ///
    /// This will return an array of all available TextAlignment values:
    /// `.leading`, `.center`, and `.trailing`
    public static var allCases: [TextAlignment] { get }
}

/// A built-in group of commands for searching, editing, and transforming
/// selections of text.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the `Scene.commands(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TextEditingCommands : Commands {

    /// A new value describing the built-in text-editing commands.
    public init() { }

    /// The composition of commands that comprise the command group.
    public var body: some Commands { get }

    /// The type of command group representing the body of this command group.
    public typealias Body = some Commands
}

/// A multi-line text field.
///
/// A text editor view allows you to display and edit multiline, scrollable
/// text in your app's user interface. The text editor responds to usual
/// view modifiers like:
/// - `View/font(_:)`
/// - `View/foregroundColor(_:)`
/// - `View/multilineTextAlignment(_:)`
///
/// ### Creating a text editor
///
/// You create a text editor by adding a `TextEditor` instance to the
/// body of your view, and initialize it by passing in a
/// `Binding` to a string variable in your app:
///
///     struct TextEditingView: View {
///         @State private var fullText = "This is some editable text..."
///
///         var body: some View {
///             TextEditor(text: $fullText)
///         }
///     }
///
/// ### Styling a text editor
///
/// To style the text, use the standard view modifiers to configure a system
/// font, set a custom font, or change the color of the view's text.
///
/// In this example, the view renders the editor's text in gray with a
/// custom font:
///
///     struct TextEditingView: View {
///         @State private var fullText = "This is some editable text..."
///
///         var body: some View {
///             TextEditor(text: $fullText)
///                 .foregroundColor(Color.gray)
///                 .font(.custom("HelveticaNeue", size: 13))
///         }
///     }
///
/// If you want to change the spacing or font scaling aspects of the text, you
/// can use modifiers like `View/lineLimit(_:)`,
/// `View/lineSpacing(_:)`, and `View/minimumScaleFactor(_:)` to configure
/// how the view displays text depending on the space constraints. For example,
/// here the `View/lineSpacing(_:)` modifier sets the spacing between lines
/// to 5 points:
///
///     struct TextEditingView: View {
///         @State private var fullText = "This is some editable text..."
///
///         var body: some View {
///             TextEditor(text: $fullText)
///                 .lineLimit(3)
///                 .lineSpacing(5)
///                 .minimumScaleFactor(0.5)
///         }
///     }
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TextEditor : View {

    /// Creates a multi-line text field.
    ///
    /// Use a `TextEditor` instance to create a view in which users can enter
    /// and edit long-form text.
    ///
    /// In this example, the text editor renders gray text using the 13
    /// point Helvetica Neue font with 5 points of spacing between each line:
    ///
    ///     struct TextEditingView: View {
    ///         @State private var fullText: String = "This is some editable text..."
    ///
    ///         var body: some View {
    ///             TextEditor(text: $fullText)
    ///                 .foregroundColor(Color.gray)
    ///                 .font(.custom("HelveticaNeue", size: 13))
    ///                 .lineSpacing(5)
    ///         }
    ///     }
    ///
    /// You can define the styling for the text within the view, including the
    /// text color, font, and line spacing. You define these styles by applying
    /// standard view modifiers to the view.
    ///
    /// - Parameter text: A `Binding` to the variable containing the
    ///    text to edit.
    public init(text: Binding<String>) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

/// A view for editable text.
///
/// `TextField` provides an interface to display and modify editable text.
///
/// `TextField` has 4 different initializers, and is most commonly initialized with a `@State` variable and placeholder text.
///
/// ![TextField Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TextField-example-1.gif)
///
///     struct ExampleView: View {
///         @State var myFruit: String = ""
///
///         var body: some View {
///             VStack {
///                   Text(myFruit)
///                   TextField("Fruit", text: $myFruit)
///             }
///             .padding()
///         }
///     }
/// [textfield-style ->]
/// `TextField` can be styled with the `View/textFieldStyle(_:)` modifier.
///
/// ![TextField Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/TextField-example-2.gif)
///
///     struct ExampleView: View {
///         @State var myFruit: String = ""
///
///         var body: some View {
///             Text(myFruit)
///             TextField("Fruit", text: $myFruit)
///                 .textFieldStyle(RoundedBorderTextFieldStyle())
///                 .padding()
///         }
///     }
///
/// [<-]
/// The `TextFieldStyle` protocol and `View/textFieldStyle(_:)` modifier provide helpful functionality to implement a well styled `TextField`.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct TextField<Label> : View where Label : View {

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension TextField where Label == Text {

    /// Creates a text field with a text label generated from a localized title
    /// string.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - text: The text to be displayed and edited.
    ///   - onEditingChanged: An action thats called when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure recieves a Boolean indicating whether the text field is
    ///     currently being edited.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user hits the return key) while the text
    ///     field has focus.
    public init(_ titleKey: LocalizedStringKey, text: Binding<String>, onEditingChanged: @escaping (Bool) -> Void = { _ in }, onCommit: @escaping () -> Void = {}) { }

    /// Creates a text field with a text label generated from a title string.
    ///
    /// - Parameters:
    ///   - title: The title of the text view, describing its purpose.
    ///   - text: The text to be displayed and edited.
    ///   - onEditingChanged: An action thats called when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure recieves a Boolean indicating whether the text field is
    ///     currently being edited.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user hits the return key) while the text
    ///     field has focus.
    public init<S>(_ title: S, text: Binding<String>, onEditingChanged: @escaping (Bool) -> Void = { _ in }, onCommit: @escaping () -> Void = {}) where S : StringProtocol { }

    /// Create an instance which binds over an arbitrary type, `T`.
    ///
    /// - Parameters:
    ///   - titleKey: The key for the localized title of the text field,
    ///     describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `T`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onEditingChanged: An action thats called when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure recieves a Boolean indicating whether the text field is
    ///     currently being edited.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user hits the return key) while the text
    ///     field has focus.
    public init<T>(_ titleKey: LocalizedStringKey, value: Binding<T>, formatter: Formatter, onEditingChanged: @escaping (Bool) -> Void = { _ in }, onCommit: @escaping () -> Void = {}) { }

    /// Create an instance which binds over an arbitrary type, `T`.
    ///
    /// - Parameters:
    ///   - title: The title of the text field, describing its purpose.
    ///   - value: The underlying value to be edited.
    ///   - formatter: A formatter to use when converting between the
    ///     string the user edits and the underlying value of type `T`.
    ///     In the event that `formatter` is unable to perform the conversion,
    ///     `binding.value` isn't modified.
    ///   - onEditingChanged: An action thats called when the user
    ///     begins editing `text` and after the user finishes editing `text`.
    ///     The closure recieves a Boolean indicating whether the text field is
    ///     currently being edited.
    ///   - onCommit: An action to perform when the user performs an action
    ///     (for example, when the user hits the return key) while the text
    ///     field has focus.
    public init<S, T>(_ title: S, value: Binding<T>, formatter: Formatter, onEditingChanged: @escaping (Bool) -> Void = { _ in }, onCommit: @escaping () -> Void = {}) where S : StringProtocol { }
}

/// A specification for the appearance and interaction of a text field.
///
/// Use types conforming to this protocol with
/// ``View/textFieldStyle(_:)`` to change the
/// style of ``TextField`` views.
///
/// There are currently only 3 styles available on iOS:
/// - ``DefaultTextFieldStyle``
/// - ``PlainTextFieldStyle``
/// - ``RoundedBorderTextFieldStyle``
/// - ``SquareBorderTextFieldStyle`` (macOS only)
///
/// There is currently no way to create your own text field styles.
/// The best way to create a custom text field is by placing
/// your ``TextField`` in a ``ZStack``, and styling the elements around it.
///
/// ```
/// struct TextFieldView: View {
///     @State private var input = ""
///
///     var body: some View {
///         TextField("iMessage", text: $input)
///             .textFieldStyle(RoundedBorderTextFieldStyle())
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol TextFieldStyle { }
extension TextFieldStyle {
}

/// A built-in set of commands for transforming the styles applied to selections
/// of text.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the `Scene.commands(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct TextFormattingCommands : Commands {

    /// A new value describing the built-in text-formatting commands.
    public init() { }

    /// The composition of commands that comprise the command group.
    public var body: some Commands { get }

    /// The type of command group representing the body of this command group.
    public typealias Body = some Commands
}

/// A label style that only displays the title of the label.
///
/// ![TitleOnlyLabelStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/labelstyle-title-only-example-1.png)
///
///
///     struct ExampleView: View {
///         var body: some View {
///              Label("Banana🍌🍌", systemImage: "heart.fill")
///                  .labelStyle(TitleOnlyLabelStyle())
///         }
///     }
///
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct TitleOnlyLabelStyle : LabelStyle {

    /// Creates a title-only label style.
    public init() { }

    /// Creates a view that represents the body of a label.
    ///
    /// The system calls this method for each `Label` instance in a view
    /// hierarchy where this style is the current label style.
    ///
    /// - Parameter configuration: The properties of the label.
    public func makeBody(configuration: TitleOnlyLabelStyle.Configuration) -> some View { }


    /// A view that represents the body of a label.
    public typealias Body = some View
}

/// An on-off switch.
///
/// Create a toggle by providing an `isOn` binding and a label.
///
/// ```
/// struct SwitchView: View {
///     @State private var vibrateOnRing = false
///
///     var body: some View {
///         Toggle(isOn: $vibrateOnRing) {
///             Text("Vibrate on Ring")
///         }
///     }
/// }
/// ```
///
/// For the common case of text-only labels, you can use the convenience
/// initializer that takes a title string (or localized string key) as its first
/// parameter, instead of a trailing closure:
///
/// ```
/// struct SwitchView: View {
///     @State private var vibrateOnRing = true
///
///     var body: some View {
///         Toggle("Vibrate on Ring", isOn: $vibrateOnRing)
///     }
/// }
/// ```
///
/// ### Styling Toggles
///
/// You can customize the appearance of toggles by using a ``ToggleStyle``, or creating your own
/// styles that conform to the ``ToggleStyle`` protocol. Available styles include:
/// - ``DefaultToggleStyle``
/// - ``SwitchToggleStyle``
/// - ``CheckboxToggleStyle``
///
/// To set the style, use the ``View/toggleStyle(_:)`` modifier:
///
/// ```
/// struct RingerView: View {
///     @State private var vibrateOnRing = true
///     @State private var vibrateOnSilent = true
///     var body: some View {
///         VStack {
///             Toggle("Vibrate on Ring 🔔", isOn: $vibrateOnRing)
///             Toggle("Vibrate on Silent 🔕", isOn: $vibrateOnSilent)
///         }
///         .toggleStyle(SwitchToggleStyle())
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct Toggle<Label> : View where Label : View {

    /// Creates an on-off switch with a custom label.
    ///
    /// ```
    /// struct ToggleView: View {
    ///     @State private var on = false
    ///     var body: some View {
    ///         Toggle(isOn: $on, label: {
    ///             Text("Airplane Mode ✈️")
    ///          })
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - isOn: A boolean binding connected to whether the toggle is on.
    ///   - label: A closure that returns the toggle label.
    public init(isOn: Binding<Bool>, @ViewBuilder label: () -> Label) { }

    /// The content and behavior of the view.
    public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = some View
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Toggle where Label == ToggleStyleConfiguration.Label {

    /// Creates a an on-off switch based on a toggle style configuration.
    ///
    /// Use this initializer **only** within the
    /// `ToggleStyle/makeBody(configuration:)` method of a `ToggleStyle` to
    /// create a toggle for configuring. This is useful for new custom
    /// toggle styles that only modify the current toggle style, instead of
    /// implementing a brand new style.
    ///
    /// For example, the following style adds a red border around the toggle,
    /// but otherwise preserves the toggle's current style:
    ///
    ///     struct RedBorderedToggleStyle: ToggleStyle {
    ///         typealias Body = Toggle
    ///         func makeBody(configuration: Configuration) -> some View {
    ///             Toggle(configuration)
    ///                 .border(Color.red)
    ///         }
    ///     }
    ///
    ///     struct ContentView: View {
    ///         @State private var on = true
    ///         var body: some View {
    ///             Toggle("🍌🍌", isOn: $on)
    ///                 .toggleStyle(RedBorderedToggleStyle())
    ///         }
    ///     }
    ///
    /// - Parameter configuration: A toggle style configuration, passed from makeBody(configuration:).
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
    public init(_ configuration: ToggleStyleConfiguration) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Toggle where Label == Text {

    /// Creates an on-off switch with a localized string key label.
    ///
    /// Uses a localized string key to create a toggle.
    ///
    /// ```
    /// struct LocalizedToggleView: View {
    ///     @State private var on = false
    ///     var body: some View {
    ///         Toggle(LocalizedStringKey("Airplane Mode"), isOn: $on)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - titleKey: A localized string label.
    ///   - isOn: A boolean binding connected to whether the toggle is on.
    public init(_ titleKey: LocalizedStringKey, isOn: Binding<Bool>) { }

    /// Creates an on-off switch with a string label.
    ///
    /// Uses a string to create a toggle.
    ///
    /// ```
    /// struct SettingsToggleView: View {
    ///     @State private var on = false
    ///     var body: some View {
    ///         Toggle("Airplane Mode ✈️", isOn: $on)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - title: A string label.
    ///   - isOn: A boolean binding connected to whether the toggle is on.
    public init<S>(_ title: S, isOn: Binding<Bool>) where S : StringProtocol { }
}

/// Structs conforming to the this protocol can customize the styles for ``Toggle`` views.
///
/// ToggleStyle allows for easy customization of a toggle view. In order to customize the style,
/// simply create a new type conforming to this protocol that returns the custom view
/// in the ``ToggleStyle/makeBody(_:)`` function. Note that while theToggleStyle
/// protocol takes care of most the implementation, the conforming type must still
/// toggle the isOn property.
///
/// To configure the current toggle style for a view hierarchy, use the
/// ``View/toggleStyle(_:)`` modifier.
///
/// For example, to make a custom toggle style which conforms to this protocol:
///
/// ![Toggle style example 1](togglestyle-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///    @State private var toggleStatus: Bool = false
///
///    var body: some View {
///        Toggle(isOn: $toggleStatus, label: {
///            Text("Active")
///        })
///        .padding(50)
///        .toggleStyle(CustomRectangleToggleStyle())
///    }
/// }
///
/// struct CustomRectangleToggleStyle: ToggleStyle {
///
///    func makeBody(configuration: Configuration) -> some View {
///        HStack {
///            configuration.label
///            Rectangle()
///                .frame(width: 75, height: 30)
///                .overlay(
///                    Circle()
///                        .foregroundColor(configuration.isOn ? Color.green : Color.red)
///                        .padding(.all, 3)
///                        .offset(x: configuration.isOn ? 20 : -20, y: 0)
///                        .animation(Animation.linear(duration: 0.1))
///                )
///                .onTapGesture {
///                    configuration.isOn.toggle()
///
///                }
///        }
///    }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol ToggleStyle{ }
extension ToggleStyle {

    /// A view that represents the appearance and interaction of a toggle.
    associatedtype Body : View

    /// Creates a view that represents the body of a toggle.
    ///
    /// The system calls this method for each `Toggle` instance in a view
    /// hierarchy where this style is the current toggle style.
    ///
    /// For example, to make a custom toggle style which returns a ``HStack`` from makeBody:
    ///
    /// ![Toggle style example 1](togglestyle-example-1.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    @State private var toggleStatus: Bool = false
    ///
    ///    var body: some View {
    ///        Toggle(isOn: $toggleStatus, label: {
    ///            Text("Active")
    ///        })
    ///        .padding(50)
    ///        .toggleStyle(CustomRectangleToggleStyle())
    ///    }
    /// }
    ///
    /// struct CustomRectangleToggleStyle: ToggleStyle {
    ///
    ///    func makeBody(configuration: Configuration) -> some View {
    ///        HStack {
    ///            configuration.label
    ///            Rectangle()
    ///                .frame(width: 75, height: 30)
    ///                .overlay(
    ///                    Circle()
    ///                        .foregroundColor(configuration.isOn ? Color.green : Color.red)
    ///                        .padding(.all, 3)
    ///                        .offset(x: configuration.isOn ? 20 : -20, y: 0)
    ///                        .animation(Animation.linear(duration: 0.1))
    ///                )
    ///                .onTapGesture {
    ///                    configuration.isOn.toggle()
    ///
    ///                }
    ///        }
    ///    }
    /// }
    /// ```
    ///
    /// - Parameter configuration: The properties of the toggle, such as its
    ///   label and its “on” state.
    func makeBody(configuration: Self.Configuration) -> Self.Body { }

    /// The properties of a toggle instance.
    ///
    /// See ``ToggleStyleConfiguration`` for more details.
    typealias Configuration = ToggleStyleConfiguration
}

/// The properties of a toggle instance.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ToggleStyleConfiguration {

    /// A type-erased label of a toggle.
    public struct Label : View {

        /// The type of view representing the body of this view.
        ///
        /// When you create a custom view, Swift infers this type from your
        /// implementation of the required `body` property.
        public typealias Body = Never
    }

    /// A view that describes the effect of switching the toggle between its
    /// on and off states.
    public let label: ToggleStyleConfiguration.Label

    /// A binding to a state property that indicates whether the toggle is on or
    /// off.
    public var isOn: Bool { get nonmutating set }

    /// A binding to let you listen to changes in the toggle's "is on" property.
    public var $isOn: Binding<Bool> { get }
}

/// A built-in set of commands for manipulating window toolbars.
///
/// These commands are optional and can be explicitly requested by passing a
/// value of this type to the `Scene.commands(_:)` modifier.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ToolbarCommands : Commands {

    /// A new value describing the built-in toolbar-related commands.
    public init() { }

    /// The composition of commands that comprise the command group.
    public var body: some Commands { get }

    /// The type of command group representing the body of this command group.
    public typealias Body = some Commands
}

/// Conforming types represent items that can be placed in various locations
/// in a toolbar.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol ToolbarContent{ }
extension ToolbarContent {

    /// The type of content representing the body of this toolbar content.
    associatedtype Body : ToolbarContent

    /// The composition of content that comprise the toolbar content.
    @ToolbarContentBuilder var body: Self.Body { get }
}

/// Constructs a toolbar item set from multi-expression closures.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_functionBuilder public struct ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing a single toolbar content.
    public static func buildBlock<Content>(_ content: Content) -> some ToolbarContent where Content : ToolbarContent { }

	/// Builds a new coustom toolbar contents structure from a block containing a single custom toolbar content.
    public static func buildBlock<Content>(_ content: Content) -> some CustomizableToolbarContent where Content : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 2 toolbar contents.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 3 toolbar contents.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 4 toolbar contents.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 5 toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 6 toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 7 toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 8 toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent, C7 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 9 toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent, C7 : ToolbarContent, C8 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new toolbar contents structure from a block containing 10 toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some ToolbarContent where C0 : ToolbarContent, C1 : ToolbarContent, C2 : ToolbarContent, C3 : ToolbarContent, C4 : ToolbarContent, C5 : ToolbarContent, C6 : ToolbarContent, C7 : ToolbarContent, C8 : ToolbarContent, C9 : ToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 2 custom toolbar contents.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 3 custom toolbar contents.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 4 custom toolbar contents.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 5 custom toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 6 custom toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 7 custom toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 8 custom toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent, C7 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 9 custom toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent, C7 : CustomizableToolbarContent, C8 : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarContentBuilder {

	/// Builds a new custom toolbar contents structure from a block containing 10 custom toolbar contents.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> some CustomizableToolbarContent where C0 : CustomizableToolbarContent, C1 : CustomizableToolbarContent, C2 : CustomizableToolbarContent, C3 : CustomizableToolbarContent, C4 : CustomizableToolbarContent, C5 : CustomizableToolbarContent, C6 : CustomizableToolbarContent, C7 : CustomizableToolbarContent, C8 : CustomizableToolbarContent, C9 : CustomizableToolbarContent { }

}

/// A model to represent a navigation item.
///
/// A model that represents a toolbar or navigation item.
///
/// A `ToolbarItem` is essentially the following structure:
///
/// ```
/// struct ToolbarItem<ID, Content: View> {
///     let id: ID
///     let placement: ToolbarItemPlacement
///     let content: Content
/// }
/// ```
///
/// -  `id` is responsible for efficient updates to the toolbar item.
/// - `placement` controls where the item is placed.
/// - `content` represents the actual content of the item.
///
/// ### Adding toolbar items
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello, World!")
///                 .toolbar {
///                     ToolbarItem(id: "bananas") {
///                         Text("🍌🍌")
///                     }
///
///                     ToolbarItem(id: "apples") {
///                         Text("🍏🍏")
///                     }
///
///                     ToolbarItem(id: "peaches") {
///                         Text("🍑🍑")
///                     }
///                 }
///         }
///     }
/// }
/// ```
///
/// ### Placing a toolbar item on the navigation bar
///
/// `ToolbarItem` can be explicitly placed on the navigation bar using either `ToolbarItemPlacement.navigationBarLeading` or `ToolbarItemPlacement.navigationBarTrailing`. For example:
///
/// ```
/// struct ExampleView: View {
///     var body: some View {
///         NavigationView {
///             Text("Hello, World!")
///                 .toolbar {
///                     ToolbarItem(placement: .navigationBarLeading) {
///                         Spacer()
///                     }
///                 }
///         }
///     }
/// }
/// ```
///
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ToolbarItem<ID, Content> : ToolbarContent where Content : View {

    /// The type of content representing the body of this toolbar content.
    public typealias Body = Never
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarItem where ID == Void {

    /// Creates a toolbar item with the specified placement and content.
    ///
    /// - Parameters:
    ///   - placement: Which section of the toolbar
    ///     the item should be placed in.
    ///   - content: The content of the item.
    public init(placement: ToolbarItemPlacement = .automatic, @ViewBuilder content: () -> Content) { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarItem : CustomizableToolbarContent where ID == String {

    /// Creates a toolbar item with the specified placement and content,
    /// which allows for user customization.
    ///
    /// - Parameters:
    ///   - id: A unique identifier for this item.
    ///   - placement: Which section of the toolbar
    ///     the item should be placed in.
    ///   - showsByDefault: Whether the item appears by default in the toolbar,
    ///     or only shows if the user explicitly adds it via customization.
    ///   - content: The content of the item.
    public init(id: String, placement: ToolbarItemPlacement = .automatic, showsByDefault: Bool = true, @ViewBuilder content: () -> Content) { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ToolbarItem : Identifiable where ID : Hashable {

    /// The stable identity of the entity associated with this instance.
    public var id: ID { get }
}

/// A model that represents a group of `ToolbarItem`s which can be placed in
/// the toolbar or navigation bar.
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ToolbarItemGroup<Content> : ToolbarContent where Content : View {

    /// Creates a toolbar item group with a specified placement and content.
    ///
    /// - Parameters:
    ///  - placement: Which section of the toolbar all of its vended
    ///    `ToolbarItem`s should be placed in.
    ///  - content: The content of the group. Each view specified in the
    ///    `ViewBuilder` will be given its own `ToolbarItem` in the toolbar.
    public init(placement: ToolbarItemPlacement = .automatic, @ViewBuilder content: () -> Content) { }

    /// The type of content representing the body of this toolbar content.
    public typealias Body = Never
}

/// A structure which defines the placement of a toolbar item.
///
/// There are two types of placements:
/// - Semantic placements, such as `.principal` and `.navigation`,
/// which denote the intent of the item being added.
/// SwiftUI will determine the appropriate placement for the item
/// based on this intent, as well as the current platform.
/// - Positional placements, such as `.navigationBarLeading`,
/// which denote a precise placement for the item,
/// usually for a particular platform.
///
/// Toolbar placements are used with the ``ToolbarItem`` when defining a toolbar.
/// For example:
///
/// ![Toolbar item placement example 1](toolbar-placement-example-1.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        Text("🍌🍌")
///        .toolbar {
///            ToolbarItem(placement: .bottomBar) {
///                Button("Bottom bar button") {}
///            }
///        }
///    }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct ToolbarItemPlacement {

    /// The item is placed automatically, depending on many factors including
    /// the platform, size class, or presence of other items.
    ///
    /// On macOS and Mac Catalyst, items are placed in the current toolbar
    /// section in order of leading to trailing. On watchOS, only the first
    /// item will appear, pinned beneath the navigation bar.
    ///
    /// On iOS, iPadOS and tvOS, items are placed in the trailing position of
    /// the navigation bar.
    ///
    /// In compact horizontal size classes, both the leading and the trailing
    /// positions of the navigation bar are limited to a single item each.
    public static let automatic: ToolbarItemPlacement

    /// The item is placed in the principal item section.
    ///
    /// Principal actions receive prominent placement.
    /// As an example, the location field for a web browser would be
    /// considered a principal item.
    ///
    /// On macOS and Mac Catalyst, the principal item will be placed in the
    /// center of the toolbar.
    ///
    /// On iOS, iPadOS, and tvOS, the principal item will be placed in
    /// the center of the navigation bar. This item will take precedent over
    /// a title specified through `.navigationTitle()`.
    @available(watchOS, unavailable)
    public static let principal: ToolbarItemPlacement

    /// The item represents a navigation action.
    ///
    /// Navigation actions allow the user to move between contexts.
    /// For example, the forward and back buttons of a web browser
    /// are considered navigation actions.
    ///
    /// On macOS and Mac Catalyst, navigation items will be placed in the
    /// leading edge of the toolbar ahead of the inline title if that is
    /// present in the toolbar.
    ///
    /// On iOS, iPadOS, and tvOS, navigation items will appear in the leading
    /// edge of the navigation bar. If a system navigation item like a back
    /// button is present in a compact width, they will instead appear in
    /// the .primaryAction placement.
    @available(watchOS, unavailable)
    public static let navigation: ToolbarItemPlacement

    /// The item represents a primary action.
    ///
    /// A primary action is considered to be a more frequently used action
    /// for the current context. For example, a button which allows the user
    /// to compose a new message in a chat application.
    ///
    /// On macOS and Mac Catalyst, the primary action is considered to be the
    /// leading edge of the toolbar.
    ///
    /// On iOS, iPadOS and tvOS, the primary action is considered to be
    /// the trailing edge of the navigation bar.
    ///
    /// On watchOS, the primary action is placed beneath the navigation
    /// bar and revealed by scrolling.
    public static let primaryAction: ToolbarItemPlacement

    /// The item represents a change in status for the current context.
    ///
    /// Status items are informational in nature,
    /// and do not represent an action that can be taken by the user.
    /// For example, a message indicating the last time the server has been
    /// checked for new messages.
    ///
    /// On macOS and Mac Catalyst, status items will be placed in the center
    /// of the toolbar.
    ///
    /// On iOS and iPadOS, status items will be placed in the center of the
    /// bottom toolbar.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let status: ToolbarItemPlacement

    /// The item represents a confirmation action for a modal interface.
    ///
    /// Confirmation actions are used to receive user confirmation of a
    /// particular action. An example of a confirmation action would be
    /// an action with the label "Add" to add a new event to the calendar.
    ///
    /// On macOS and Mac Catalyst, confirmationAction items will be placed
    /// on the trailing edge in the trailing-most position of the sheet
    /// and gain the apps accent color as a background color.
    ///
    /// On iOS, iPadOS, and tvOS, confirmationAction items will be placed in
    /// the same location as a `.primaryAction` placement.
    ///
    /// On watchOS, confirmationAction items will be placed in the trailing
    /// edge of the navigation bar.
    public static let confirmationAction: ToolbarItemPlacement

    /// The item represents a cancellation action for a modal interface.
    ///
    /// Cancellation actions can be used to dismiss the modal interface
    /// without taking any action, usually via a 'Cancel' button.
    ///
    /// On macOS and Mac Catalyst, cancellationAction items will be placed
    /// on the trailing edge of the sheet but be placed before any
    /// confirmationAction items.
    ///
    /// On iOS, iPadOS, tvOS and watchOS, cancellationAction items will
    /// be placed on the leading edge of the navigation bar.
    public static let cancellationAction: ToolbarItemPlacement

    /// The item represents a destructive action for a modal interface.
    ///
    /// Destructive actions are used represent the opposite of a
    /// confirmational action. For example, a button labeled 'Don't Save',
    /// which declines to save the current document before quitting.
    ///
    /// On macOS and Mac Catalyst, destructiveAction items will be placed in
    /// the leading edge of the sheet and will be given a special appearance
    /// to caution against accidental use.
    ///
    /// On iOS, tvOS and watchOS, destructiveAction items will be placed in the
    /// trailing edge of the navigation bar.
    public static let destructiveAction: ToolbarItemPlacement

    /// The item is placed in the leading edge of the navigation bar. Applies
    /// to iOS, iPadOS, tvOS, and Mac Catalyst.
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public static let navigationBarLeading: ToolbarItemPlacement

    /// The item is placed in the trailing edge of the navigation bar. Applies
    /// to iOS, iPadOS, tvOS, and Mac Catalyst.
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public static let navigationBarTrailing: ToolbarItemPlacement

    /// The item is placed in the bottom toolbar. Applies to iOS, iPadOS, and
    /// Mac Catalyst.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let bottomBar: ToolbarItemPlacement
}

/// The context of the current state-processing update.
///
/// Use a transaction to pass an animation between views in a view hierarchy.
///
/// The root transaction for a state change comes from the binding that changed,
/// plus any global values set by calling `withTransaction(_:_:)` or
/// `withAnimation(_:_:)`.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct Transaction {

    /// Creates a transaction.
    @inlinable public init() { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Transaction {

    /// Creates a transaction and assigns its animation property.
    ///
    /// - Parameter animation: The animation to perform when the current state
    ///   changes.
    public init(animation: Animation?) { }

    /// The animation, if any, associated with the current state change.
    public var animation: Animation?

    /// A Boolean value that indicates whether views should disable animations.
    ///
    /// This value is `true` during the initial phase of a two-part transition
    /// update, to prevent `View/animation(_:)` from inserting new animations
    /// into the transaction.
    public var disablesAnimations: Bool
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Transaction {

    /// A Boolean value that indicates whether the transaction originated from
    /// an action that produces a sequence of values.
    ///
    /// This value is `true` if a continuous action created the transaction, and
    /// is `false` otherwise. Continuous actions include things like dragging a
    /// slider or pressing and holding a stepper, as opposed to tapping a
    /// button.
    public var isContinuous: Bool
}

/// A shape with an affine transform applied to it.
///
/// A transformed shape has two use cases:
/// 1. Used directly via its initializer ``TransformedShape/init(shape:transform:)``.
/// 2. The return value of ``Shape/transform(_:)``.
///
/// Having an offset shape is helpful because it allows you to translate a shape
/// and then continue to use its shape properties, instead of turning into ``View``.
///
/// A simple example of constructing a ``TransformedShape``:
///
/// ```
/// struct TransformedShapeView: View {
///     var body: some View {
///         TransformedShape(shape: Rectangle(),
///                          transform: .init(rotationAngle: 6))
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct TransformedShape<Content> : Shape where Content : Shape {

	/// The original shape to be affine transformed.
    ///
    /// ```
    /// struct TransformedShapeView: View {
    ///     let transformedShape = TransformedShape(shape: Rectangle(),
    ///                                             transform: .init(rotationAngle: 6))
    ///     var body: some View {
    ///         ZStack {
    ///             transformedShape
    ///             transformedShape.shape
    ///                 .opacity(0.2)
    ///         }
    ///     }
    /// }
    /// ```
    public var shape: Content

    /// The affine transformation to apply to the original shape
    ///
    /// ```
    /// struct TransformedShapeView: View {
    ///     let transformedShape = TransformedShape(shape: Rectangle(),
    ///                                             transform: .init(rotationAngle: 6))
    ///     var body: some View {
    ///         transformedShape
    ///             .onAppear { print(transformedShape.transform.isIdentity) } //false
    ///     }
    /// }
    /// ```
    public var transform: CGAffineTransform

    /// Creates a new shape from an original shape and an affine transform.
    ///
    /// ```
    /// struct TransformedShapeView: View {
    ///     var body: some View {
    ///         TransformedShape(shape: Rectangle(),
    ///                          transform: .init(rotationAngle: 6))
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - shape: The original shape to be affine transformed.
    ///   - transform: The affine transform to apply to the original shape.
    @inlinable public init(shape: Content, transform: CGAffineTransform) { }

    /// Describes this shape as a path within a rectangular frame of reference.
    ///
    /// - Parameter rect: The frame of reference for describing this shape.
    ///
    /// - Returns: A path that describes this shape.
    public func path(in rect: CGRect) -> Path { }

    /// The type defining the data to animate.
    public typealias AnimatableData = Content.AnimatableData

    /// The data to animate.
    public var animatableData: TransformedShape<Content>.AnimatableData

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body
}

/// A View created from a swift tuple of View values.
///
/// `TupleView` is mainly used with `ViewBuilder`, and so you don't really
/// need to worry about it unless you're making your own view builders.
///
/// In the example below, we use this type to create a new kind of `VStack`
/// that only displays the first 2 views. All other views are ignored.
/// Kind of useless? Yes. Instructive? You tell me.
///
///     struct StackedView: View {
///         var body: some View {
///             First2VStack {
///                 Text("I am first 🥇")
///                 Text("Second is the best 2️⃣")
///                 Text("Hey stop ignoring me ☹️")
///             }
///         }
///     }
///
///     struct First2VStack<First: View, Second: View>: View {
///         let first: First
///         let second: Second
///
///         init(@ViewBuilder content: () -> TupleView<(First, Second)>) {
///             let views = content().value
///             first = views.0
///             second = views.1
///         }
///
///         var body: some View {
///             HStack {
///                 first
///                 second
///             }
///         }
///     }
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct TupleView<T> : View {

	/// The tuple of views in the `TupleView`.
    ///
    /// A ``TupleView`` stores a real life tuple of views in this property.
    /// Its type is a generic, `T`, which can have a tuple type.
    ///
    /// See how in the example below, we extract the value parameter from
    /// the tuple view returned by the view builder. This allows us to
    /// take the first and second elements of the type from the tuple view.
    ///
    ///     struct StackedView: View {
    ///         var body: some View {
    ///             First2VStack {
    ///                 Text("I am first 🥇")
    ///                 Text("Second is the best 2️⃣")
    ///                 Text("Hey stop ignoring me ☹️")
    ///             }
    ///         }
    ///     }
    ///
    ///     struct First2VStack<First: View, Second: View>: View {
    ///         let first: First
    ///         let second: Second
    ///
    ///         init(@ViewBuilder content: () -> TupleView<(First, Second)>) {
    ///             let views = content().value
    ///             first = views.0
    ///             second = views.1
    ///         }
    ///
    ///         var body: some View {
    ///             HStack {
    ///                 first
    ///                 second
    ///             }
    ///         }
    ///     }
    ///
    public var value: T

    /// Creates a tuple view.
    ///
    /// You usually won't use this intializer directly. Instead, if you are
    /// working with ``TupleView``s, the tuple view will usually be
    /// constructed behind the scenes using the ``ViewBuilder`` property
    /// wrapper. See that page for more info.
    ///
    /// See below for how to extract a tuple view from a view builder.
    ///
    ///     struct StackedView: View {
    ///         var body: some View {
    ///             First2VStack {
    ///                 Text("I am first 🥇")
    ///                 Text("Second is the best 2️⃣")
    ///                 Text("Hey stop ignoring me ☹️")
    ///             }
    ///         }
    ///     }
    ///
    ///     struct First2VStack<First: View, Second: View>: View {
    ///         let first: First
    ///         let second: Second
    ///
    ///         init(@ViewBuilder content: () -> TupleView<(First, Second)>) {
    ///             let views = content().value
    ///             first = views.0
    ///             second = views.1
    ///         }
    ///
    ///         var body: some View {
    ///             HStack {
    ///                 first
    ///                 second
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter value: A tuple of any number of views.
    @inlinable public init(_ value: T) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A property wrapper that is used in `App` to provide a delegate from UIKit.
@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
@propertyWrapper public struct UIApplicationDelegateAdaptor<DelegateType> : DynamicProperty where DelegateType : NSObject, DelegateType : UIApplicationDelegate {

    /// The underlying delegate.
    public var wrappedValue: DelegateType { get }

    /// Creates an `UIApplicationDelegateAdaptor` using a UIKit Application
    /// Delegate.
    ///
    /// The framework will initialize the provided delegate and manage its
    /// lifetime, calling out to it when appropriate after performing its
    /// own work.
    ///
    /// - Parameter delegate: the type of `UIApplicationDelegate` to use.
    public init(_ delegateType: DelegateType.Type = DelegateType.self) { }
}

@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIApplicationDelegateAdaptor where DelegateType : ObservableObject {

    /// Creates an `UIApplicationDelegateAdaptor` using a UIKit
    /// Application Delegate.
    ///
    /// The framework will initialize the provided delegate and manage its
    /// lifetime, calling out to it when appropriate after performing its
    /// own work.
    ///
    /// - Parameter delegate: the type of `UIApplicationDelegate` to use.
    /// - Note: the instantiated delegate will be placed in the Environment
    ///   and may be accessed by using the `@EnvironmentObject` property wrapper
    ///   in the view hierarchy.
    public init(_ delegateType: DelegateType.Type = DelegateType.self) { }

    /// A projection of the observed object that creates bindings to its
    /// properties using dynamic member lookup.
    ///
    /// Use the projected value to pass a binding value down a view
    /// hierarchy. To get the `projectedValue`, prefix the property
    /// variable with `$`.
    public var projectedValue: ObservedObject<DelegateType>.Wrapper { get }
}

/// A UIKit view controller that is used for embedding a SwiftUI view in a
/// UIKit view hierarchy.
///
/// A `UIHostingController` is used for integrating a SwiftUI view into a UIKit 
/// view hierarchy. It's a good way to introduce SwiftUI code in an existing
/// UIKit project. The hosting controller like you would any other view
/// controller; it can be presented modally, pushed to a 
/// `UINavigationController` stack, or embedded as a child view controller.
///
/// ```
/// let exampleSwiftUIView = ExampleView()
/// let hostingController = UIHostingController(rootView: exampleSwiftUIView)
/// present(hostingController, animated: true, completion: nil)
/// ```
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
open class UIHostingController<Content> : UIViewController where Content : View {

	/// > The key commands that trigger actions on this responder.
	///
	/// > A responder object that supports hardware keyboard commands can redefine
	/// this property and use it to return an array of `UIKit/UIKeyCommand` objects that
	/// it supports. Each key command object represents the keyboard sequence to
	/// recognize and the action method of the responder to call in response.
	///
	/// > The key commands you return from this method are applied to the entire
	/// responder chain. When an key combination is pressed that matches a key
	/// command object, UIKit walks the responder chain looking for an object
	/// that implements the corresponding action method. It calls that method on
	/// the first object it finds and then stops processing the event.
    @objc override dynamic open var keyCommands: [UIKeyCommand]? { get }

    /// > Creates a hosting controller object that wraps the specified SwiftUI
    /// view.
    ///
    /// - Parameter rootView: The root view of the SwiftUI view hierarchy that
    ///   you want to manage using the hosting view controller.
    ///
    /// - Returns: A `UIHostingController` object initialized with the
    ///   specified SwiftUI view.
    public init(rootView: Content) { }

    /// Creates a hosting controller object from an archive and the specified
    /// SwiftUI view.
    /// - Parameters:
    ///   - coder: The decoder to use during initialization.
    ///   - rootView: The root view of the SwiftUI view hierarchy that you want
    ///     to manage using this view controller.
    ///
    /// - Returns: A `UIViewController` object that you can present from your
    ///   interface.
    public init?(coder aDecoder: NSCoder, rootView: Content) { }

    /// Creates a hosting controller object from the contents of the specified
    /// archive.
    ///
    /// The default implementation of this method throws an exception. To create
    /// your view controller from an archive, override this method and
    /// initialize the superclass using the `init(coder:rootView:)` method
    /// instead.
    ///
    /// - Parameter coder: The decoder to use during initialization.
    @objc required dynamic public init?(coder aDecoder: NSCoder) { }

    /// Notifies the view controller that its view is about to be added to a
    /// view hierarchy.
    ///
    /// SwiftUI calls this method before adding the hosting controller's root
    /// view to the view hierarchy. You can override this method to perform
    /// custom tasks asssociated with the appearance of the view. If you
    /// override this method, you must call `super` at some point in your
    /// implementation.
    ///
    /// - Parameter animated: If `true`, the view is being added
    ///   using an animation.
    @objc override dynamic open func viewWillAppear(_ animated: Bool) { }

    /// Notifies the view controller that its view has been added to a
    /// view hierarchy.
    ///
    /// SwiftUI calls this method after adding the hosting controller's root
    /// view to the view hierarchy. You can override this method to perform
    /// custom tasks asssociated with the appearance of the view. If you
    /// override this method, you must call `super` at some point in your
    /// implementation.
    ///
    /// - Parameter animated: If `true`, the view is being added
    ///   using an animation.
    @objc override dynamic open func viewDidAppear(_ animated: Bool) { }

    /// Notifies the view controller that its view will be removed from a
    /// view hierarchy.
    ///
    /// SwiftUI calls this method before removing the hosting controller's root
    /// view from the view hierarchy. You can override this method to perform
    /// custom tasks asssociated with the disappearance of the view. If you
    /// override this method, you must call `super` at some point in your
    /// implementation.
    ///
    /// - Parameter animated: If `true`, the view is being removed
    ///   using an animation.
    @objc override dynamic open func viewWillDisappear(_ animated: Bool) { }

    /// Called to notify the view controller that its view is about to layout
    /// its subviews.
    ///
    /// When a view's bounds change, the view adjusts the position of its
    /// subviews. Your view controller can override this method to make changes
    /// before the view lays out its subviews. The default implementation of
    /// this method does nothing.
    @objc override dynamic open func viewWillLayoutSubviews() { }

    /// The root view of the SwiftUI view hierarchy managed by this view
    /// controller.
    public var rootView: Content

    /// Calculates and returns the most appropriate size for the current view.
    ///
    /// - Parameter size: The proposed new size for the view.
    ///
    /// - Returns: The size that offers the best fit for the root view and its
    ///   contents.
    public func sizeThatFits(in size: CGSize) -> CGSize { }

    @objc override dynamic open func preferredContentSizeDidChange(forChildContentContainer container: UIContentContainer) { }

    /// The preferred status bar style for the view controller.
    @objc override dynamic open var preferredStatusBarStyle: UIStatusBarStyle { get }

    /// A Boolean value that indicates whether the view controller prefers the
    /// status bar to be hidden or shown.
    @objc override dynamic open var prefersStatusBarHidden: Bool { get }

    /// The animation style to use when hiding or showing the status bar for
    /// this view controller.
    @objc override dynamic open var preferredStatusBarUpdateAnimation: UIStatusBarAnimation { get }

    /// Called when the system needs the view controller to use for determining
    /// status bar hidden/unhidden state.
    ///
    /// If your container view controller derives the hidden state of the status
    /// bar from one of its child view controllers, implement this method to
    /// specify which child view controller you want to control the hidden/
    /// unhidden state. If you return `nil` or do not override this method, the
    /// status bar hidden/unhidden state for `self` is used.
    ///
    /// If you change the return value from this method, call the
    /// `setNeedsStatusBarAppearanceUpdate()` method.
    ///
    /// - Returns The view controller whose status bar hidden/unhidden status
    /// should be used. Default return value is `nil`.
    @objc override dynamic open var childForStatusBarHidden: UIViewController? { get }

    /// Notifies the container that the size of its view is about to change.
    ///
    /// This  method is called before changing the size of a presented view
    /// controller’s view. You can override this method in your own objects and
    /// use it to perform additional tasks related to the size change. For
    /// example, a container view controller might use this method to override
    /// the traits of its embedded child view controllers. Use the provided
    /// `coordinator` object to animate any changes you make.

	/// If you override this method in your custom view controllers, always call
	/// super at some point in your implementation so that UIKit can forward the
	/// size change message appropriately. View controllers forward the size
	/// change message to their views and child view controllers. Presentation
	/// controllers forward the size change to their presented view controller.
	///
	/// - Parameters:
	///   - size: The new size for the container’s view.
	///   - coordinator: The transition coordinator object managing the size
	///   change. You can use this object to animate your changes or get
	///   information about the transition that is in progress.
    @objc override dynamic open func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { }

    /// Called just before the hosting controller is added or removed from a
    /// container view controller.
    ///
    /// Your hosting controller can override this method when it needs to know
    /// that it has been added to a container.
    ///
	/// If you are implementing your own container view controller, it must call
	/// the `willMove(toParent:)` method of the child view controller before
	/// calling the `removeFromParent()` method, passing in a parent value of
	/// `nil`.
	///
	/// When your custom container calls the `addChild(_:)` method, it
	/// automatically calls the `willMove(toParent:)` method of the view
	/// controller to be added as a child before adding it.
	///
	/// - Parameter parent: The parent view controller, or `nil` if there is no
	/// parent.
    @objc override dynamic open func willMove(toParent parent: UIViewController?) { }

    /// Called after the hosting controller is added or removed from a container
    /// view controller.
    ///
    /// Your hosting controller can override this method when it wants to react to
    /// being added to a container.
    ///
	/// If you are implementing your own container view controller, it must call
	/// the `didMove(toParent:)` method of the child view controller after the
	/// transition to the new controller is complete or, if there is no
	/// transition, immediately after calling the `addChild(_:)` method.
	///
	/// The `removeFromParent()` method automatically calls the
	/// `didMove(toParent:)` method of the child view controller after it
	/// removes the child.
	///
	/// - Parameter parent: The parent view controller, or `nil` if there is no
	/// parent.
    @objc override dynamic open func didMove(toParent parent: UIViewController?) { }

    /// Returns the target object that responds to an action.
    ///
    /// This method is called whenever an action needs to be invoked by the
    /// object. The default implementation calls the
    /// `canPerformAction(_:withSender:)` method to determine whether it can
    /// invoke the action. If the object can invoke the action, it returns
    /// itself, otherwise it passes the request up the responder chain. Your app
    /// should override this method if it wants to override how a target is
    /// selected.
    ///
    /// - Parameters:
    ///	  - action: A selector that identifies a method associated with a command.
    ///   - sender: The object calling this method. For the editing menu
    ///   commands, this is the shared `UIKit/UIApplication` object. Depending on the
    ///   context, you can query the sender for information to help you determine
    ///   the target of the command.
    ///
    /// - Returns: The object whose action method is invoked to execute the command.
    @objc override dynamic open func target(forAction action: Selector, withSender sender: Any?) -> Any? { }

    /// Returns a newly initialized view controller with the nib file in the specified bundle.
    ///
    /// This is the designated initializer for this class. When using a
    /// storyboard to define your hosting controller and its associated views,
    /// you never initialize your view controller class directly. Instead, view
	/// controllers are instantiated by the storyboard either automatically when
	/// a segue is triggered or programmatically when your app calls the
	/// `instantiateViewController(withIdentifier:)` method of a storyboard
	/// object. When instantiating a view controller from a storyboard, iOS
	/// initializes the new view controller by calling its `init(coder:)`
	/// method instead of this method and sets the `nibName` property to a nib
	/// file stored inside the storyboard.
	///
	/// The nib file you specify is not loaded right away. It is loaded the
	/// first time the view controller's view is accessed. If you want to
	/// perform additional initialization after the nib file is loaded, override
	/// the `viewDidLoad()` method and perform your tasks there.
	///
	/// If you specify `nil` for the `nibName` parameter and you do not override
	/// the `loadView()` method, the view controller searches for a nib file
	/// as described in the `nibName` property.
	///
	/// For more information about how a view controller loads its view, see
	/// [View Controller Programming Guide for iOS](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457).
	///
	/// - Parameters:
	///   - nibNameOrNil: The name of the nib file to associate with the view
	///   controller. The nib file name should not contain any leading path
	///   information. If you specify `nil`, the `nibName` property is set to `nil`.
	///   - nibBundleOrNil: The bundle in which to search for the nib file.
	///   This method looks for the nib file in the bundle's language-specific
	///   project directories first, followed by the Resources directory.
	///
	/// - Returns: A newly initialized `UIHostingController` object.
    @objc override dynamic public init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) { }
}

/// A view that represents a UIKit view controller.
///
/// Use a `UIViewControllerRepresentable` instance to create and manage a
/// <doc://com.apple.documentation/documentation/UIKit/UIViewController> object in your
/// SwiftUI interface. Adopt this protocol in one of your app's custom
/// instances, and use its methods to create, update, and tear down your view
/// controller. The creation and update processes parallel the behavior of
/// SwiftUI views, and you use them to configure your view controller with your
/// app's current state information. Use the teardown process to remove your
/// view controller cleanly from your SwiftUI. For example, you might use the
/// teardown process to notify other objects that the view controller is
/// disappearing.
///
/// To add your view controller into your SwiftUI interface, create your
/// `UIViewControllerRepresentable` instance and add it to your SwiftUI
/// interface. The system calls the methods of your custom instance at
/// appropriate times.
///
/// The system doesn't automatically communicate changes occurring within your
/// view controller to other parts of your SwiftUI interface. When you want your
/// view controller to coordinate with other SwiftUI views, you must provide a
/// `NSViewControllerRepresentable/Coordinator` instance to facilitate those
/// interactions. For example, you use a coordinator to forward target-action
/// and delegate messages from your view controller to any SwiftUI views.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public protocol UIViewControllerRepresentable : View where Self.Body == Never{ }
extension UIViewControllerRepresentable : View where Self.Body == Never {

    /// The type of view controller to present.
    associatedtype UIViewControllerType : UIViewController

    /// Creates the view controller object and configures its initial state.
    ///
    /// You must implement this method and use it to create your view controller
    /// object. Create the view controller using your app's current data and
    /// contents of the `context` parameter. The system calls this method only
    /// once, when it creates your view controller for the first time. For all
    /// subsequent updates, the system calls the
    /// `UIViewControllerRepresentable/updateUIViewController(_:context:)`
    /// method.
    ///
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system.
    ///
    /// - Returns: Your UIKit view controller configured with the provided
    ///   information.
    func makeUIViewController(context: Self.Context) -> Self.UIViewControllerType { }

    /// Updates the state of the specified view controller with new information
    /// from SwiftUI.
    ///
    /// When the state of your app changes, SwiftUI updates the portions of your
    /// interface affected by those changes. SwiftUI calls this method for any
    /// changes affecting the corresponding AppKit view controller. Use this
    /// method to update the configuration of your view controller to match the
    /// new state information provided in the `context` parameter.
    ///
    /// - Parameters:
    ///   - uiViewController: Your custom view controller object.
    ///   - context: A context structure containing information about the current
    ///     state of the system.
    func updateUIViewController(_ uiViewController: Self.UIViewControllerType, context: Self.Context) { }

    /// Cleans up the presented view controller (and coordinator) in
    /// anticipation of their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view controller. For example, you might use this method to remove
    /// observers or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiViewController: Your custom view controller object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    static func dismantleUIViewController(_ uiViewController: Self.UIViewControllerType, coordinator: Self.Coordinator) { }

    /// A type to coordinate with the view controller.
    associatedtype Coordinator = Void

    /// Creates the custom instance that you use to communicate changes from
    /// your view controller to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view controller might affect
    /// other parts of your app. In your implementation, create a custom Swift
    /// instance that can communicate with other parts of your interface. For
    /// example, you might provide an instance that binds its variables to
    /// SwiftUI properties, causing the two to remain synchronized. If your view
    /// controller doesn't interact with other parts of your app, providing a
    /// coordinator is unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// `UIViewControllerRepresentable/makeUIViewController(context:)` method.
    /// The system provides your coordinator either directly or as part of a
    /// context structure when calling the other methods of your representable
    /// instance.
    func makeCoordinator() -> Self.Coordinator { }

    /// A type alias for the representable's context.
    ///
    /// - SeeAlso: UIViewControllerRepresentableContext
    typealias Context = UIViewControllerRepresentableContext<Self>
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewControllerRepresentable where Self.Coordinator == Void {

    /// Creates the custom instance that you use to communicate changes from
    /// your view controller to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view controller might affect
    /// other parts of your app. In your implementation, create a custom Swift
    /// instance that can communicate with other parts of your interface. For
    /// example, you might provide an instance that binds its variables to
    /// SwiftUI properties, causing the two to remain synchronized. If your view
    /// controller doesn't interact with other parts of your app, providing a
    /// coordinator is unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// `UIViewControllerRepresentable/makeUIViewController(context:)` method.
    /// The system provides your coordinator either directly or as part of a
    /// context structure when calling the other methods of your representable
    /// instance.
    public func makeCoordinator() -> Self.Coordinator { }
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewControllerRepresentable {

    /// Cleans up the presented view controller (and coordinator) in
    /// anticipation of their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view controller. For example, you might use this method to remove
    /// observers or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiViewController: Your custom view controller object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    public static func dismantleUIViewController(_ uiViewController: Self.UIViewControllerType, coordinator: Self.Coordinator) { }

    /// Declares the content and behavior of this view.
    public var body: Never { get }
}

/// Contextual information about the state of the system that you use to create
/// and update your UIKit view controller.
///
/// A `UIViewControllerRepresentableContext` structure contains details about
/// the current state of the system. When creating and updating your view
/// controller, the system creates one of these structures and passes it to the
/// appropriate method of your custom `UIViewControllerRepresentable`
/// instance. Use the information in this structure to configure your view
/// controller. For example, use the provided environment values to configure
/// the appearance of your view controller and views. Don't create this
/// structure yourself.
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct UIViewControllerRepresentableContext<Representable> where Representable : UIViewControllerRepresentable {

    /// The view's associated coordinator.
    public let coordinator: Representable.Coordinator

    /// The current transaction.
    public var transaction: Transaction { get }

    /// Environment values that describe the current state of the system.
    ///
    /// Use the environment values to configure the state of your UIKit view
    /// controller when creating or updating it.
    public var environment: EnvironmentValues { get }
}

/// A view to import a UIKit view into SwiftUI.
///
/// ### Setup
///
/// To implement a `UIViewRepresentable`, you must implement four main lifecycle functions:
///
/// - `UIViewRepresentable/makeCoordinator()`
/// - `UIViewRepresentable/makeUIView(context:)`
/// - `UIViewRepresentable/updateUIView(_:context:)`
/// - `UIViewRepresentable/dismantleUIView(context:)` (this is optional, a default implementation is provided if left unimplemented)
///
/// The SwiftUI runtime:
///
/// - Creates a `Coordinator` using `makeCoordinator()` if necessary.
/// - Calls `UIViewRepresentable/makeUIView(context:) to create an instance of your` `UIViewType`.
/// - `UIViewRepresentable/updateUIView(_:context:)` is immediately called *once* after the call to `UIViewRepresentable/makeUIView(context:)` .
/// - Upon any state changes, calls  `UIViewRepresentable/updateUIView(_:context:)`
/// - Upon destruction of the parent container, calls `UIViewRepresentable/dismantleUIView(context:)`
///
/// ### Port a simple `UIView`
///
/// To port a simple UIKit view, `UIActivityIndicatorView`, you could use the following setup:
///
/// ```
/// struct ActivityIndicator: UIViewRepresentable {
///     typealias Context = UIViewRepresentableContext<Self>
///     typealias UIViewType = UIActivityIndicatorView
///
///     let isAnimated: Bool
///
///     public func makeUIView(context: Context) -> UIViewType {
///         UIActivityIndicatorView(style: .medium) // create the instance of the view
///     }
///
///     public func updateUIView(_ uiView: UIViewType, context: Context) {
///         // Check if isAnimated is true, and if the view is inactive.
///         if isAnimated && !uiView.isAnimating {
///             uiView.startAnimating() // Animate
///         }
///
///         // Check if isAnimated is false, and if the view is active.
///         if !isAnimated && uiView.isAnimating {
///             uiView.stopAnimating() // Stop animating
///         }
///     }
/// }
/// ```
///
/// Note:
///
/// - In `updateUIView(_:context:)`, you must handle `isAnimated` being either `true` or `false`.
/// - No redundant calls are made to `startAnimating` and `stopAnimating`. Redundant calls are guarded against by checking whether `uiView.isAnimating` is true or not. This is a general principle for optimizing the performance of your `UIViewRepresentable`.
///
/// Having implemented it as a `UViewRepresentable`, you could now use it in SwiftUI. For example:
///
/// ![UIViewRepresentable Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/UIViewRepresentable-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var isAnimating: Bool = false
///
///     var body: some View {
///         VStack {
///             Toggle("Animating", isOn: $isAnimating)
///
///             ActivityIndicator(isAnimated: isAnimating)
///         }
///     }
/// }
///
/// struct ActivityIndicator: UIViewRepresentable {
///     typealias Context = UIViewRepresentableContext<Self>
///     typealias UIViewType = UIActivityIndicatorView
///
///     let isAnimated: Bool
///
///     public func makeUIView(context: Context) -> UIViewType {
///         UIActivityIndicatorView(style: .medium) // create the instance of the view
///     }
///
///     public func updateUIView(_ uiView: UIViewType, context: Context) {
///         // Check if isAnimated is true, and if the view is inactive.
///         if isAnimated && !uiView.isAnimating {
///             uiView.startAnimating() // Animate
///         }
///
///         // Check if isAnimated is false, and if the view is active.
///         if !isAnimated && uiView.isAnimating {
///             uiView.stopAnimating() // Stop animating
///         }
///     }
/// }
/// ```
///
/// In this example, the `ActivityIndicator` from before is used and can be toggled by passing a boolean to `ActivityIndicator/init(isAnimated:)`.
/// [uiviewrepresentable-context ->]
/// ### Context-aware `UIViewRepresentable`s
///
/// SwiftUI heavily relies on the environment, by way of environment objects (`View/environmentObject(_:)`) and environment values (`EnvironmentValues`). The latter – environment values – are useful for creating intelligent and context-aware UIKit ports.
///
/// For example, we can remove the `isAnimated` parameter from `ActivityIndicator`, and use `isEnabled` from the environment instead  via `EnvironmentValues/isEnabled`:
///
/// ```
/// struct ActivityIndicator: UIViewRepresentable {
///     typealias Context = UIViewRepresentableContext<Self>
///     typealias UIViewType = UIActivityIndicatorView
///
///     public func makeUIView(context: Context) -> UIViewType {
///         UIActivityIndicatorView(style: .medium) // create the instance of the view
///     }
///
///     public func updateUIView(_ uiView: UIViewType, context: Context) {
///         // Check if the environment specifies that the view should be enabled, and if the view is inactive.
///         if context.environment.isEnabled && !uiView.isAnimating {
///             uiView.startAnimating() // Animate
///         }
///
///         // Check if the environment specifies that the view should be disabled, and if the view is active.
///         if !context.environment.isEnabled && uiView.isAnimating {
///             uiView.stopAnimating() // Stop animating
///         }
///     }
/// }
/// ```
/// [<-]
/// In this example, `context` is used to access the view's current `environment` (via `context.environment`), giving you access to the latest `EnvironmentValues`. By reading `EnvironmentValues/isEnabled`, we can get rid of the `isAnimated` parameter in favor of reading it from the context. This has the added advantage of being passed from any level at the top, because environment values propagate down the view hierarchy.
///
/// The `View/disabled(_:)` modifier is responsible for modifying `EnvironmentValues/isEnabled`. The example usage must be updated to use `View/disabled(_:)` instead of `isAnimated`:
///
/// ![UIViewRepresentable Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/UIViewRepresentable-example-2.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var isAnimating: Bool = false
///
///     var body: some View {
///         VStack {
///             Toggle("Animating", isOn: $isAnimating)
///
///             ActivityIndicator()
///                 .disabled(!isAnimating)
///         }
///     }
/// }
///
/// struct ActivityIndicator: UIViewRepresentable {
///     typealias Context = UIViewRepresentableContext<Self>
///     typealias UIViewType = UIActivityIndicatorView
///
///     public func makeUIView(context: Context) -> UIViewType {
///         UIActivityIndicatorView(style: .medium) // create the instance of the view
///     }
///
///     public func updateUIView(_ uiView: UIViewType, context: Context) {
///         // Check if the environment specifies that the view should be enabled, and if the view is inactive.
///         if context.environment.isEnabled && !uiView.isAnimating {
///             uiView.startAnimating() // Animate
///         }
///
///         // Check if the environment specifies that the view should be disabled, and if the view is active.
///         if !context.environment.isEnabled && uiView.isAnimating {
///             uiView.stopAnimating() // Stop animating
///         }
///     }
/// }
/// ```
///
/// Using `View/disabled(_:)`, the activity indicator can now be made active or inactive.
///
/// The benefits of using the environment and context become apparent when multiple views are used together. For example:
///
/// ![UIViewRepresentable Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/UIViewRepresentable-example-3.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var isAnimating: Bool = false
///
///     var body: some View {
///         VStack {
///             Toggle("Animating", isOn: $isAnimating)
///
///             VStack {
///                 ActivityIndicator()
///                 ActivityIndicator()
///                 ActivityIndicator()
///             }
///             .disabled(!isAnimating)
///         }
///     }
/// }
///
/// struct ActivityIndicator: UIViewRepresentable {
///     typealias Context = UIViewRepresentableContext<Self>
///     typealias UIViewType = UIActivityIndicatorView
///
///     public func makeUIView(context: Context) -> UIViewType {
///         UIActivityIndicatorView(style: .medium) // create the instance of the view
///     }
///
///     public func updateUIView(_ uiView: UIViewType, context: Context) {
///         // Check if the environment specifies that the view should be enabled, and if the view is inactive.
///         if context.environment.isEnabled && !uiView.isAnimating {
///             uiView.startAnimating() // Animate
///         }
///
///         // Check if the environment specifies that the view should be disabled, and if the view is active.
///         if !context.environment.isEnabled && uiView.isAnimating {
///             uiView.stopAnimating() // Stop animating
///         }
///     }
/// }
/// ```
///
/// A single `View/disabled(_:)` modifier on the `VStack` can now become responsible for enabling/disabling the activity indicators inside the stack. This also allows parent views, that aren't aware of `ExampleView`'s implementation, to control whether views within it are enabled or disabled.
///
/// ### Implementing UIKit delegates for a `UIViewRepresentable`
///
/// UIKit views often require delegates to communicate events and pass data back and forth with their view controllers. Since SwiftUI is all about modularity and componentization, there is no concept of a "view controller". View representables use the concept of a 'coordinator' to port views reliant on the delegate pattern.
///
/// For example, here is an example port of `UISearchBar`:
///
/// ```
/// struct SearchBar: UIViewRepresentable {
///     class Coordinator: NSObject, UISearchBarDelegate {
///         @Binding var text: String
///
///         init(text: Binding<String>) {
///             _text = text
///         }
///
///         func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
///             self.text = searchText // set the binding's value to the latest search bar text
///         }
///     }
///
///     let placeholder: String
///
///     @Binding var text: String
///
///     func makeCoordinator() -> Coordinator {
///         Coordinator(text: self.$text) // create an instance of Coordinator
///     }
///
///     func makeUIView(context: Context) -> UISearchBar {
///         let searchBar = UISearchBar(frame: .zero)
///
///         searchBar.placeholder = placeholder
///         searchBar.delegate = context.coordinator
///
///         return searchBar
///     }
///
///     func updateUIView(_ uiView: UISearchBar, context: Context) {
///         uiView.text = text // set the search bar's text to the value of the binding
///     }
/// }
/// ```
///
/// A search bar is a good example of a complex UIKit view. It is a control responsible for text input with multiple lifecycle events, and it uses the delegate pattern to inform the observer whenever these events occur. In SwiftUI, data is passed using bindings, and there is no concept of a delegate.
///
/// The `Coordinator` is the glue between a SwiftUI-style binding-pattern and a UIKit-style delegate-pattern. A `Coordinator` is a state object created and maintained for the lifetime of a `UIViewRepresentable`, that typically implements the primary delegate for the UIKit view being ported. In this case, the `UIViewType` is `UISearchBar` and its primary delegate type is `UISearchBarDelegate`.
///
/// Text input controls in SwiftUI often take a `Binding<String>` in their initializer, and use it to get/set the latest text entered by the user via control. It's extremely important to note that bindings are bidirectional, because SwiftUI ports of UIKit views must also **get** the latest input from the `Binding`. UIKit patterns typically only require notifying the observer and thus setting the values, but in SwiftUI it is imperative to handle both to be a good SwiftUI citizen.
///
/// Here is example of using the search part port:
///
/// ![UIViewRepresentable Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/UIViewRepresentable-example-4.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var searchText: String = ""
///
///     var body: some View {
///         VStack {
///             SearchBar(placeholder: "Enter something here", text: $searchText)
///
///             Text("Entered text: /\(searchText)")
///         }
///     }
/// }
///
/// struct SearchBar: UIViewRepresentable {
///     class Coordinator: NSObject, UISearchBarDelegate {
///         @Binding var text: String
///
///         init(text: Binding<String>) {
///             &#x5f;text = text
///         }
///
///         func searchBar(&#x5f; searchBar: UISearchBar, textDidChange searchText: String) {
///             self.text = searchText // set the binding's value to the latest search bar text
///         }
///     }
///
///     let placeholder: String
///
///     @Binding var text: String
///
///     func makeCoordinator() -> Coordinator {
///         Coordinator(text: self.$text) // create an instance of Coordinator
///     }
///
///     func makeUIView(context: Context) -> UISearchBar {
///         let searchBar = UISearchBar(frame: .zero)
///
///         searchBar.placeholder = placeholder
///         searchBar.delegate = context.coordinator
///
///         return searchBar
///     }
///
///     func updateUIView(_ uiView: UISearchBar, context: Context) {
///         uiView.text = text // set the search bar's text to the value of the binding
///     }
/// }
/// ```
///
/// In this example, `SearchBar` is bound to a state variable, `searchText`. To confirm that values are being written as they are input, a `Text` reflects the latest value of the state variable. *Note* that if `searchText`'s initial value is used to set the initial text of the `UISearchBar` represented by `SearchBar`. This means if the initial value of `searchText` was set to `"Bananas 🍌🍌"`, `SearchBar` would have an initial search text of `"Bananas 🍌🍌"` already loaded.
///
/// ### Further notes
///
/// - Creating UIKit views are expensive. That is why they are done once per lifetime of a `UIViewRepresentable`.
/// - Because the *same* `UIViewType` instance is reused as much as possible, `UIViewRepresentable/updateUIView(_:context:)` is responsible for making sure that the parameters passed via the initializer, and the SwiftUI environment, are always in sync with the UIKit view being managed by the representable.
///
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public protocol UIViewRepresentable : View where Self.Body == Never{ }
extension UIViewRepresentable : View where Self.Body == Never {

    /// The type of view to present.
    associatedtype UIViewType : UIView

    /// Creates the view object and configures its initial state.
    ///
    /// You must implement this method and use it to create your view object.
    /// Configure the view using your app's current data and contents of the
    /// `context` parameter. The system calls this method only once, when it
    /// creates your view for the first time. For all subsequent updates, the
    /// system calls the `UIViewRepresentable/updateUIView(_:context:)`
    /// method.
    ///
    /// - Parameter context: A context structure containing information about
    ///   the current state of the system.
    ///
    /// - Returns: Your UIKit view configured with the provided information.
    func makeUIView(context: Self.Context) -> Self.UIViewType { }

    /// Updates the state of the specified view with new information from
    /// SwiftUI.
    ///
    /// When the state of your app changes, SwiftUI updates the portions of your
    /// interface affected by those changes. SwiftUI calls this method for any
    /// changes affecting the corresponding UIKit view. Use this method to
    /// update the configuration of your view to match the new state information
    /// provided in the `context` parameter.
    ///
    /// - Parameters:
    ///   - uiView: Your custom view object.
    ///   - context: A context structure containing information about the current
    ///     state of the system.
    func updateUIView(_ uiView: Self.UIViewType, context: Self.Context) { }

    /// Cleans up the presented UIKit view (and coordinator) in anticipation of
    /// their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view. For example, you might use this method to remove observers
    /// or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiView: Your custom view object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    static func dismantleUIView(_ uiView: Self.UIViewType, coordinator: Self.Coordinator) { }

    /// A type to coordinate with the view.
    associatedtype Coordinator = Void

    /// Creates the custom instance that you use to communicate changes from
    /// your view to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view might affect other parts
    /// of your app. In your implementation, create a custom Swift instance that
    /// can communicate with other parts of your interface. For example, you
    /// might provide an instance that binds its variables to SwiftUI
    /// properties, causing the two to remain synchronized. If your view doesn't
    /// interact with other parts of your app, providing a coordinator is
    /// unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// `UIViewRepresentable/makeUIView(context:)` method. The system provides
    /// your coordinator either directly or as part of a context structure when
    /// calling the other methods of your representable instance.
    func makeCoordinator() -> Self.Coordinator { }

    /// A type alias for the representable's context.
    ///
    /// - SeeAlso: UIViewRepresentableContext
    typealias Context = UIViewRepresentableContext<Self>
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewRepresentable where Self.Coordinator == Void {

    /// Creates the custom instance that you use to communicate changes from
    /// your view to other parts of your SwiftUI interface.
    ///
    /// Implement this method if changes to your view might affect other parts
    /// of your app. In your implementation, create a custom Swift instance that
    /// can communicate with other parts of your interface. For example, you
    /// might provide an instance that binds its variables to SwiftUI
    /// properties, causing the two to remain synchronized. If your view doesn't
    /// interact with other parts of your app, providing a coordinator is
    /// unnecessary.
    ///
    /// SwiftUI calls this method before calling the
    /// `UIViewRepresentable/makeUIView(context:)` method. The system provides
    /// your coordinator either directly or as part of a context structure when
    /// calling the other methods of your representable instance.
    public func makeCoordinator() -> Self.Coordinator { }
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension UIViewRepresentable {

    /// Cleans up the presented UIKit view (and coordinator) in anticipation of
    /// their removal.
    ///
    /// Use this method to perform additional clean-up work related to your
    /// custom view. For example, you might use this method to remove observers
    /// or update other parts of your SwiftUI interface.
    ///
    /// - Parameters:
    ///   - uiView: Your custom view object.
    ///   - coordinator: The custom coordinator instance you use to communicate
    ///     changes back to SwiftUI. If you do not use a custom coordinator, the
    ///     system provides a default instance.
    public static func dismantleUIView(_ uiView: Self.UIViewType, coordinator: Self.Coordinator) { }

    /// Declares the content and behavior of this view.
    public var body: Never { get }
}

/// Contextual information about the state of the system that you use to create
/// and update your UIKit view.
///
/// A `UIViewRepresentableContext` structure contains details about the
/// current state of the system. When creating and updating your view, the
/// system creates one of these structures and passes it to the appropriate
/// method of your custom `UIViewRepresentable` instance. Use the information
/// in this structure to configure your view. For example, use the provided
/// environment values to configure the appearance of your view. Don't create
/// this structure yourself.
///
/// [[uiviewrepresentable-context]]
@available(iOS 13.0, tvOS 13.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public struct UIViewRepresentableContext<Representable> where Representable : UIViewRepresentable {

    /// The view's associated coordinator.
    public let coordinator: Representable.Coordinator

    /// The current transaction.
    public var transaction: Transaction { get }

    /// The current environment.
    ///
    /// Use the environment values to configure the state of your view when
    /// creating or updating it.
    public var environment: EnvironmentValues { get }
}

/// A dynamic data structure for representing a point in a view.
///
/// A unitpoint takes in x and y coordinates measured in points.
///
/// You can customizde the x and y coordinates or you can use a constant.
/// SwiftUI has 10 UnitPoint constants:
/// 1. ``UnitPoint/zero``
/// 2. ``UnitPoint/center``
/// 3. ``UnitPoint/leading``
/// 4. ``UnitPoint/trailing``
/// 5. ``UnitPoint/top``
/// 6. ``UnitPoint/bottom``
/// 7. ``UnitPoint/topleading``
/// 8. ``UnitPoint/toptrailing``
/// 9. ``UnitPoint/bottomleading``
/// 10. ``UnitPoint/bottomtrailing``
///
/// UnitPoints are used commonly in shapes and gradients.
///
/// For example, a ``LinearGradient`` accepts a `UnitPoint` for the startPoint and endPoint parameters.
/// This example uses the constants ``UnitPoint/top`` and ``UnitPoint/bottom``.
///
/// ![LinearGradient Example 1](linear-gradient-example.png)
///
/// ```
/// struct ExampleView: View {
///     let colors: [Color] = [.yellow, .orange]
///
///     var body: some View {
///         Rectangle()
///             .fill(LinearGradient(gradient: Gradient(colors: colors),
///                                  startPoint: .top,
///                                  endPoint: .bottom))
///             .frame(width:100, height:100)
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct UnitPoint : Hashable {

	/// The x coordinate of the point, measured in points.
    public var x: CGFloat

    /// The y coordinate of the point, measured in points.
    public var y: CGFloat

    /// Creates a unit point with x and y values of 0.
    @inlinable public init() { }

    /// Creates a unit point from x and y values.
    ///
    /// - Parameters:
    ///   x: The x coordinate of the unit point.
    ///   y: The y coordinate of the unit point.
    @inlinable public init(x: CGFloat, y: CGFloat) { }

    /// A unit point with x and y values of 0.
    public static let zero: UnitPoint

    /// The unit point at the center of a given view.
    public static let center: UnitPoint

    /// The unit point at the middle of the leading edge of a given view.
    public static let leading: UnitPoint

    /// The unit point at the middle of the trailing edge of a given view.
    public static let trailing: UnitPoint

    /// The unit point at the middle of the top edge of a given view.
    public static let top: UnitPoint

    /// The unit point at the middle of the bottom edge of a given view.
    public static let bottom: UnitPoint

    /// The unit point at the top leading corner of a given view.
    public static let topLeading: UnitPoint

    /// The unit point at the top trailing corner of a given view.
    public static let topTrailing: UnitPoint

    /// The unit point at the bottom leading corner of a given view.
    public static let bottomLeading: UnitPoint

    /// The unit point at the bottom trailing corner of a given view.
    public static let bottomTrailing: UnitPoint

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: UnitPoint, b: UnitPoint) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension UnitPoint : Animatable {

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<CGFloat, CGFloat>

    /// The data to animate.
    public var animatableData: UnitPoint.AnimatableData
}

/// A set of values that indicate the visual size available to the view.
@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public enum UserInterfaceSizeClass {

    /// The compact size class.
    case compact

    /// The regular size class.
    case regular

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: UserInterfaceSizeClass, b: UserInterfaceSizeClass) -> Bool { }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher) { }
}

extension UserInterfaceSizeClass {

    /// Create a size class from its UIUserInterfaceSizeClass equivalent.
    @available(iOS 14.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init?(_ uiUserInterfaceSizeClass: UIUserInterfaceSizeClass) { }
}

@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UserInterfaceSizeClass : Equatable {
}

@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension UserInterfaceSizeClass : Hashable {
}

/// A view that arranges children vertically.
///
/// `VStack` is a vertical stack of views.
///
///  ![VStack Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/vstack-example-1.png)
///
///     struct ExampleView: View {
///         var body: some View {
///             VStack {
///                 Text("🍌🍌")
///                 Text("🍏🍏")
///                 Text("🍑🍑")
///             }
///         }
///     }
///
/// Modify your stack's alignment or spacing with the built in initializer.
///
/// ![VStack Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/vstack-example-2.png)
///
///     struct ExampleView: View {
///         var body: some View {
///             VStack(spacing: 32) {
///                 Text("🍌🍌")
///                 Text("🍏🍏")
///                 Text("🍑🍑")
///             }
///         }
///     }
///
/// Learn more about the properties of each alignment choice via the `HorizontalAlignment` struct.
///
/// `VStack` uses a `ViewBuilder` to construct the content.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct VStack<Content> : View where Content : View {

    /// Creates an instance with the given spacing and horizontal alignment.
    ///
    /// - Parameters:
    ///   - alignment: The guide for aligning the subviews in this stack. It has
    ///     the same horizontal screen coordinate for all children.
    ///   - spacing: The distance between adjacent subviews, or `nil` if you
    ///     want the stack to choose a default distance for each pair of
    ///     subviews.
    ///   - content: A view builder that creates the content of this stack.
    @inlinable public init(alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, @ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// A type that can serve as the animatable data of an animatable type.
///
/// `VectorArithmetic` extends the `AdditiveArithmetic` protocol with scalar
/// multiplication and a way to query the vector magnitude of the value. Use
/// this type as the `animatableData` associated type of a type that conforms to
/// the `Animatable` protocol.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol VectorArithmetic : AdditiveArithmetic{ }
extension VectorArithmetic : AdditiveArithmetic {

    /// Multiplies each component of this value by the given value.
    mutating func scale(by rhs: Double) { }

    /// Returns the dot-product of this vector arithmetic instance with itself.
    var magnitudeSquared: Double { get }
}

/// An alignment position along the horizontal axis.
///
/// Use this structure in the initializers of 3 structures:
/// - ``HStack``
/// - ``LazyHStack``
/// - ``LazyHGrid``
///
/// See those pages for more on how to construct them.
///
/// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
/// view modifier. See that page for more on adding alignment
/// guides to views.
///
/// There are 5 possible vertical alignments:
/// 1. ``VerticalAlignment/top``
/// 2. ``VerticalAlignment/center``
/// 3. ``VerticalAlignment/bottom``
/// 4. ``VerticalAlignment/firstTextBaseline``
/// 5. ``VerticalAlignment/lastTextBaseline``
///
/// See the example below.
///
/// ```
/// struct VerticallyAlignedView: View {
///     var body: some View {
///         HStack(alignment: VerticalAlignment.top) { //Try changing this value
///             Rectangle()
///                 .fill(Color.red)
///                 .frame(width: 50, height: 2)
///
///             VStack {
///                 Text("Align 1")
///                 Text("Align 2")
///             }
///             .font(.largeTitle)
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct VerticalAlignment : Equatable {

    /// Creates an instance with the given identifier.
    ///
    /// In addition to the 5 out-of-the-box vertical alignments,
    /// top, center, and bottom, firstTextBaseline, and lastTextBaseline,
    ///  you can also create your own
    /// custom vertical alignment. Do this by passing this intializer
    /// a ``AlignmentID.Type`` from an ``AlignmentID``.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``HStack``
    /// - ``LazyHStack``
    /// - ``LazyHGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// extension VerticalAlignment {
    ///     private enum WidthBasedAlignment: AlignmentID {
    ///         static func defaultValue(in d: ViewDimensions) -> CGFloat {
    ///             return d.width
    ///         }
    ///     }
    ///     static let width = VerticalAlignment(WidthBasedAlignment.self)
    /// }
    /// ```
    ///
    /// See [this article](https://swiftui-lab.com/alignment-guides/) for help with alignment guides.
    ///
    /// - Parameter id: An identifier that uniquely identifies the vertical
    ///   alignment.
    public init(_ id: AlignmentID.Type) { }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: VerticalAlignment, b: VerticalAlignment) -> Bool { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension VerticalAlignment {

    /// A guide marking the top edge of the view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``HStack``
    /// - ``LazyHStack``
    /// - ``LazyHGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct VerticallyAlignedView: View {
    ///     var body: some View {
    ///         HStack(alignment: .top) {
    ///             Rectangle()
    ///                 .fill(Color.red)
    ///                 .frame(width: 50, height: 2)
    ///
    ///             VStack {
    ///                 Text("Align 1")
    ///                 Text("Align 2")
    ///             }
    ///             .font(.largeTitle)
    ///         }
    ///     }
    /// }
    /// ```
    public static let top: VerticalAlignment

    /// A guide marking the vertical center of the view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``HStack``
    /// - ``LazyHStack``
    /// - ``LazyHGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct VerticallyAlignedView: View {
    ///     var body: some View {
    ///         HStack(alignment: .center) {
    ///             Rectangle()
    ///                 .fill(Color.red)
    ///                 .frame(width: 50, height: 2)
    ///
    ///             VStack {
    ///                 Text("Align 1")
    ///                 Text("Align 2")
    ///             }
    ///             .font(.largeTitle)
    ///         }
    ///     }
    /// }
    /// ```
    public static let center: VerticalAlignment

    /// A guide marking the bottom edge of the view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``HStack``
    /// - ``LazyHStack``
    /// - ``LazyHGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct VerticallyAlignedView: View {
    ///     var body: some View {
    ///         HStack(alignment: .bottom) {
    ///             Rectangle()
    ///                 .fill(Color.red)
    ///                 .frame(width: 50, height: 2)
    ///
    ///             VStack {
    ///                 Text("Align 1")
    ///                 Text("Align 2")
    ///             }
    ///             .font(.largeTitle)
    ///         }
    ///     }
    /// }
    /// ```
    public static let bottom: VerticalAlignment

    /// A guide marking the topmost text baseline view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``HStack``
    /// - ``LazyHStack``
    /// - ``LazyHGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct VerticallyAlignedView: View {
    ///     var body: some View {
    ///         HStack(alignment: .firstTextBaseline) {
    ///             Rectangle()
    ///                 .fill(Color.red)
    ///                 .frame(width: 50, height: 2)
    ///
    ///             VStack {
    ///                 Text("Align 1")
    ///                 Text("Align 2")
    ///             }
    ///             .font(.largeTitle)
    ///         }
    ///     }
    /// }
    /// ```
    public static let firstTextBaseline: VerticalAlignment

    /// A guide marking the bottom-most text baseline in a view.
    ///
    /// Use this in the initializers of 3 structures:
    /// - ``HStack``
    /// - ``LazyHStack``
    /// - ``LazyHGrid``
    ///
    /// See those pages for more on how to construct them.
    ///
    /// This structure is also used in the ``View/alignmentGuide(_:computeValue:)``
    /// view modifier. See that page for more on adding alignment
    /// guides to views.
    ///
    /// ```
    /// struct VerticallyAlignedView: View {
    ///     var body: some View {
    ///         HStack(alignment: .lastTextBaseline) {
    ///             Rectangle()
    ///                 .fill(Color.red)
    ///                 .frame(width: 50, height: 2)
    ///
    ///             VStack {
    ///                 Text("Align 1")
    ///                 Text("Align 2")
    ///             }
    ///             .font(.largeTitle)
    ///         }
    ///     }
    /// }
    /// ```
    public static let lastTextBaseline: VerticalAlignment
}

/// A type that represents part of your app's user interface and provides
/// modifiers that you use to configure views.
///
/// You create custom views by declaring types that conform to the `View`
/// protocol. Implement the required `View/body-swift.property` computed
/// property to provide the content for your custom view.
///
///     struct MyView: View {
///         var body: some View {
///             Text("Hello, World!")
///         }
///     }
///
/// Assemble the view's body by combining one or more of the primitive views
/// provided by SwiftUI, like the `Text` instance in the example above, plus
/// other custom views that you define, into a hierarchy of views.
///
/// The `View` protocol provides a large set of modifiers, defined as protocol
/// methods with default implementations, that you use to position and configure
/// views in the layout of your app. Modifiers typically work by wrapping the
/// view instance on which you call them in another view with the specified
/// characteristics. For example, adding the `View/opacity(_:)` modifier to a
/// text view returns a new view with some amount of transparency:
///
///     Text("Hello, World!")
///         .opacity(0.5) // Display partially transparent text.
///
/// The effects of a modifier typically propagate to any child views that don't
/// explicitly override the modifier. For example, a `VStack` instance on its
/// own acts only to vertically stack other views, and has no text to display.
/// Therefore, a `View/font(_:)` modifier that you apply to the stack has no
/// effect on the stack itself. Yet the font modifier does apply to any of the
/// stack's child views, some of which might display text. On the other hand,
/// you can locally override the stack's modifier by adding another to a
/// specific child view:
///
///     VStack {
///         Text("Title")
///             .font(.headline) // Override the font of this one view.
///         Text("First body line.")
///         Text("Second body line.")
///     }
///     .font(.body) // Set a default for text in the stack.
///
/// You commonly chain modifiers, each wrapping the result of the previous one.
/// For example, you can wrap a text view in an invisible box with a given width
/// using the `View/frame(width:height:alignment:)` modifier to influence its
/// layout, and then use the `View/border(_:width:)` modifier to draw an
/// outline around that:
///
///     Text("Title")
///         .frame(width: 100)
///         .border(Color.gray)
///
/// The order in which you apply modifiers matters. For example, the border that
/// results from the above code outlines the full width of the frame.
///
/// ![A screenshot of a text view displaying the string "Title", outlined by a
/// gray rectangle that's wider than the string it encloses, leaving empty space
/// inside the rectangle on either side of the string. A caption reads, "Apply
/// the frame first."](SwiftUI-View-1.png)
///
/// If you instead apply the border first, it outlines the text view, which
/// never takes more space than it needs to render its contents.
///
///     Text("Title")
///         .border(Color.gray) // Apply the border first this time.
///         .frame(width: 100)
///
/// Wrapping that view in another invisible one with a fixed 100 point width
/// affects the layout of the composite view, but has no effect on the border.
///
/// ![A screenshot of a text view displaying the string "Title", outlined by a
/// gray rectangle that hugs the text. A caption reads, "Apply the border
/// first."](SwiftUI-View-2.png)
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol View { }
extension View {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    associatedtype Body : View

    /// The content and behavior of the view.
    @ViewBuilder var body: Self.Body { get }
}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier to change a date picker style.
    ///
    /// Use this modifier to change the style of a view hierarchy's date pickers.
    ///
    /// There are currently 5 date picker styles:
    /// - ``DefaultDatePickerStyle`` on iOS and macOS
    /// - ``WheelDatePickerStyle`` on iOS
    /// - ``FieldDatePickerStyle`` on macOS
    /// - ``GraphicalDatePickerStyle`` on macOS
    /// - ``StepperFieldDatePickerStyle`` on macOS
    ///
    /// See ``DatePicker`` and ``DatePickerStyle`` for more.
    ///
    /// Use the modifier like this:
    ///
    ///     struct ExampleView: View {
    ///         @State private var selectedDate = Date()
    ///
    ///         var body: some View {
    ///             DatePicker(selection: $selectedDate) {
    ///                 Text("Date")
    ///             }
    ///             .datePickerStyle(WheelDatePickerStyle())
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - style: The desired date picker style, conforming to ``DatePickerStyle``.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func datePickerStyle<S>(_ style: S) -> some View where S : DatePickerStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that presents a sheet when a given value is not nil.
    ///
    /// Use this modifier to present a sheet over the current view when you need to pass the sheet a value.
    /// The sheet will be presented only when the binding value you pass it is not nil.
    ///
    /// If your sheet doesn't need an `item` parameter, use
    /// ``View/sheet(isPresented:onDismiss:content)`` instead.
    ///
    ///
    /// For a sheet-like view that takes up the full screen, use
    /// ``View/fullScreenCover(item:onDismiss:content)`` instead.
    ///
    /// Use the modifier like this:
    ///
    ///     struct Item: Identifiable {
    ///         let id = UUID()
    ///         let text: String
    ///     }
    ///
    ///     struct ExampleView: View {
    ///         @State private var item: Item? = nil
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Button("🍌 Sheet") {
    ///                     item = Item(text: "🍌🍌")
    ///                 }
    ///                 Button("🍑 Sheet") {
    ///                     item = Item(text: "🍑🍑")
    ///                 }
    ///             }
    ///             .sheet(item: $item,
    ///                    onDismiss: { print("dismissed!") },
    ///                    content: { ExampleSheet(item: $0) })
    ///         }
    ///     }
    ///
    ///     struct ExampleSheet: View {
    ///         let item: Item
    ///         @Environment (\.presentationMode) var presentationMode
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Text(item.text)
    ///                 Button("Tap to Dismiss") {
    ///                     presentationMode.wrappedValue.dismiss()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - item: A binding value passed to `content` to build the sheet. The sheet will show
    ///   when this value is not `nil`.
    ///   - onDismiss: A function that runs when the sheet disappears.
    ///   - content: A view builder closure that takes in the `item` and returns the sheet.
    public func sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View { }


    /// A view modifier that presents a sheet when a given condition is true.
    ///
    ///     struct ExampleView: View {
    ///         @State private var showSheet = false
    ///
    ///         var body: some View {
    ///             Button("Open sesame 📬") {
    ///                 showSheet = true
    ///             }
    ///             .sheet(isPresented: $showCover,
    ///                    onDismiss: { print("dismissed!") },
    ///                    content: { ExampleSheet() })
    ///         }
    ///     }
    ///
    ///     struct ExampleSheet: View {
    ///         @Environment(\.presentationMode) var presentationMode
    ///
    ///         var body: some View {
    ///             Button("CLOSE 📪") {
    ///                 presentationMode.wrappedValue.dismiss()
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the sheet is presented.
    ///   - onDismiss: A closure executed when the sheet dismisses.
    ///   - content: A closure returning the content of the sheet.
    public func sheet<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping () -> Content) -> some View where Content : View { }

}

@available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
@available(macOS, unavailable)
extension View {

    /// A view modifier that presents a sheet overlaid over the full screen.
    ///
    /// Use this modifier to present a full screen view over the current view. The "full screen cover" enters
    /// and exits the screen from the bottom.
    ///
    /// If your full screen cover does not need a parameter, use
    /// ``View/fullScreenCover(isPresented:onDismiss:content:)`` instead.
    ///
    /// For a cover view that does not take up the full screen, use
    /// ``View/sheet(item:onDismiss:content:)`` instead.
    ///
    /// Use the modifier like this:
    ///
    ///     struct Item: Identifiable {
    ///         let id = UUID()
    ///         let text: String
    ///     }
    ///
    ///     struct ContentView: View {
    ///         @State private var item: Item? = nil
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Button("🍌 Sheet") {
    ///                     item = Item(text: "🍌🍌")
    ///                 }
    ///                 Button("🍑 Sheet") {
    ///                     item = Item(text: "🍑🍑")
    ///                 }
    ///            }
    ///              .fullScreenCover(item: $item,
    ///                     onDismiss: { print("dismissed!") },
    ///                     content: { ExampleSheet(item: $0) })
    ///         }
    ///     }
    ///
    ///     struct ExampleSheet: View {
    ///         let item: Item
    ///         @Environment (\.presentationMode) var presentationMode
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Text(item.text)
    ///                 Button("Tap to Dismiss") {
    ///                     presentationMode.wrappedValue.dismiss()
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - item: A binding value passed to `content` to build the full screen cover. The full screen
    ///   cover will show when the value is not `nil`.
    ///   - onDismiss: A function that runs when the sheet disappears.
    ///   - content: A view builder closure that takes in the `item` and returns the full screen cover.
    public func fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View { }


    /// A view modifier that presents a sheet overlaid over the full screen without a custom parameter.
    ///
    /// Use this modifier to present a full screen view over the current view. The "full screen cover" enters
    /// and exits the screen from the bottom.
    ///
    /// If your full screen cover needs a custom parameter, use
    /// ``View/fullScreenCover(item:onDismiss:content:)`` instead.
    ///
    /// For a cover view that does not take up the full screen, use
    /// ``View/sheet(item:onDismiss:content:)`` instead.
    ///
    /// Use the modifier like this:
    ///
    ///     struct ExampleView: View {
    ///         @State private var showCover: Bool = false
    ///
    ///         var body: some View {
    ///             Button("Open sesame 📬") {
    ///                 showCover = true
    ///             }
    ///             .fullScreenCover(isPresented: $showCover,
    ///                 onDismiss: { print("dismissed!") },
    ///                 content: { ExampleSheet() })
    ///         }
    ///     }
    ///
    ///     struct ExampleSheet: View {
    ///         @Environment(\.presentationMode) var presentationMode
    ///
    ///         var body: some View {
    ///             Button("CLOSE 📪") {
    ///                 presentationMode.wrappedValue.dismiss()
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the modal view is presented.
    ///   - onDismiss: A closure executed when the modal view dismisses.
    ///   - content: A closure returning the content of the modal view.
    public func fullScreenCover<Content>(isPresented: Binding<Bool>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping () -> Content) -> some View where Content : View { }

}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 14.0, *)
extension View {

    /// A view modifier that calls a function after a long press.
    ///
    /// Use this modifier to call a function when the user long presses on a view.
    ///
    /// Use the modifier like this:
    ///
    ///     struct ExampleView: View {
    ///         @State private var pressed = false
    ///         @State private var longPressed = false
    ///
    ///         var body: some View {
    ///             Text(longPressed ? "✅" : "Press me")
    ///                 .font(.title)
    ///                 .background(pressed ? Color.green : Color.clear)
    ///                 .onLongPressGesture(minimumDuration: 1.0,
    ///                     maximumDistance: 5,
    ///                     pressing: { pressing in pressed = pressing },
    ///                     perform: { longPressed.toggle() })
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - minimumDuration: How long it takes to detect a long press.
    ///   - maximumDistance: How far the user can drag before the long press is canceled.
    ///   - pressing: A closure takes in whether the view is being pressed.
    ///   - action: A closure called when the long press happens.
    @available(tvOS, unavailable)
    public func onLongPressGesture(minimumDuration: Double = 0.5, maximumDistance: CGFloat = 10, pressing: ((Bool) -> Void)? = nil, perform action: @escaping () -> Void) -> some View { }

}

extension View {

    /// A view modifier that disables autocorrection.
    ///
    /// Use this modifier when the  autocorrection in a text field would
    /// make it more difficult for the user to input information. Some examples of where this
    /// might be the case include:
    /// - proper names
    /// - street addresses
    ///
    /// - Note: If the user has turned *off* autocorrection in their device settings, there is no way
    /// to use this modifier to force autocorrection to turn *on*.
    ///
    /// In the example below, disabling autocorrection allows the user to enter their
    /// text without the autocorrection system offering suggestions or
    /// attempting to override their input.
    ///
    ///     struct ExampleView: View {
    ///         @State private var address1 = ""
    ///         @State private var address2 = ""
    ///
    ///         var body: some View {
    ///             TextField("1234 Main St.", text: $address1)
    ///                 .disableAutocorrection(true)
    ///             TextField("Label this address", text: $address2)
    ///                 .disableAutocorrection(false)
    ///         }
    ///     }
    ///
    /// - Parameter disable: Whether autocorrection is disabled for the view.
    @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
    @available(watchOS, unavailable)
    public func disableAutocorrection(_ disable: Bool?) -> some View { }

}

@available(iOS 14.0, tvOS 14.0, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that sets the tab view page dots style.
    ///
    /// Use this modifier when your ``TabView`` uses the ``PageTabViewStyle``.
    /// You can pass this modifier an instance of any type that conforms to the
    /// ``IndexViewStyle`` protocol.
    ///
    /// This changes the style of the page dots.
    ///
    /// See ``IndexViewStyle`` and ``PageIndexViewStyle``for more info on
    /// the parameter.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         TabView {
    ///             Text("Page 1️⃣")
    ///             Color.pink
    ///         }
    ///         .tabViewStyle(PageTabViewStyle())
    ///         .indexViewStyle(PageIndexViewStyle(backgroundDisplayMode: .always)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter style: The ``IndexViewStyle`` style to apply to this view.
    public func indexViewStyle<S>(_ style: S) -> some View where S : IndexViewStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the item provider used for drag and drop.
    ///
    /// Use this modifier to set the item provider when dragging and dropping a view. This is most
    /// commonly used on larger screen sizes like iPad and Mac.
    ///
    /// The example below uses system images in a ``List`` view to drag and drop onto the Photos
    /// app.
    ///
    ///     struct ContentView: View {
    ///         var body: some View {
    ///             List {
    ///                 Label("Mustache", systemImage: "mustache")
    ///                     .itemProvider {
    ///                         NSItemProvider(object:  UIImage(systemName: "mustache")!)
    ///                     }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter action: A function that returns an NSItemProvider.
    @inlinable public func itemProvider(_ action: (() -> NSItemProvider?)?) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Disable a list item's delete action.
    ///
    /// Use this modifier to disable a list item's delete action. When a list is editable, swiping left
    /// on it will expose a red "DELETE" button. To disable this feature on specific items in the list,
    /// use this modifier.
    ///
    /// In the following example, only the first item can be deleted.
    ///
    ///     struct Item: Identifiable {
    ///         let id = UUID()
    ///         let name: String
    ///         let undeletable: Bool
    ///     }
    ///
    ///     class Model: ObservableObject {
    ///         @Published var rows: [Item] = [
    ///             Item(name: "Swipe ⬅️ to delete me", undeletable: false),
    ///             Item(name: "Try deleting me, you can't 😊", undeletable: true),
    ///         ]
    ///     }
    ///
    ///     struct ExampleView: View {
    ///         @ObservedObject private var model = Model()
    ///
    ///         var body: some View {
    ///             List {
    ///                 ForEach(model.rows) { item in
    ///                     Text(item.name)
    ///                         .deleteDisabled(item.undeletable)
    ///                 }
    ///                 .onDelete { offsets in
    ///                     model.rows.remove(atOffsets: offsets)
    ///                 }
    ///             }
    ///        }
    ///     }
    ///
    /// - Parameter isDisabled: Whether the view's delete functionality is disabled.
    @inlinable public func deleteDisabled(_ isDisabled: Bool) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Disable a list item's "move" action.
    ///
    /// Use this modifier to disable a list item's move action. When enabled, putting a list into edit mode
    /// will expose 3 lines on the right side. The user will then be able to move the row around in the list.
    /// To disable this feature on specific items in the list, use this modifier.
    ///
    /// In the following example, only the first item can be moved.
    ///
    ///     struct Item: Identifiable {
    ///         let id = UUID()
    ///         let name: String
    ///         let unmovable: Bool
    ///     }
    ///
    ///     class Model: ObservableObject {
    ///         @Published var rows: [Item] = [
    ///             Item(name: "Move me! ↕️", unmovable: false),
    ///             Item(name: "I'm fixed as a rock 🗿", unmovable: true)
    ///         ]
    ///     }
    ///
    ///     struct ContentView: View {
    ///         @ObservedObject private var model = Model()
    ///
    ///         var body: some View {
    ///             NavigationView {
    ///                 List {
    ///                     ForEach(model.rows) { item in
    ///                         Text(item.name)
    ///                             .moveDisabled(item.unmovable)
    ///                     }
    ///                     .onMove { source, destination in
    ///                         model.rows.move(fromOffsets: source,
    ///                                         toOffset: destination)
    ///                     }
    ///                 }
    ///                 .navigationBarItems(trailing: EditButton())
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter isDisabled: Whether the view's move functionality is disabled.
    @inlinable public func moveDisabled(_ isDisabled: Bool) -> some View { }

}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Make a view draggable by providing dragged info.
    ///
    /// Use this modifier to add the appropriate gestures for
    /// drag and drop to a view. When a dragging begins, a rendering of
    /// the view is generated and used as the preview image.
    ///
    /// In the following simple example, the image view can be dragged.
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             Image(systemName: "mustache")
    ///                 .onDrag {
    ///                     NSItemProvider(object: UIImage(systemName: "mustache")!)
    ///                 }
    ///         }
    ///     }
    ///
    /// - Parameter data: A function that returns an
    /// [NSItemProvider](https://developer.apple.com/documentation/foundation/nsitemprovider)
    /// object storing draggable data from a view.
    ///
    /// - Returns: A view that can be used as the source of drag and drop.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func onDrag(_ data: @escaping () -> NSItemProvider) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an accessibility action to this view.
    public func accessibilityAction(_ actionKind: AccessibilityActionKind = .default, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a custom accessibility action to the view and all subviews.
    public func accessibilityAction(named name: Text, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds a custom accessibility action to the view and all subviews.
    public func accessibilityAction(named nameKey: LocalizedStringKey, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a custom accessibility action to the view and all subviews.
    public func accessibilityAction<S>(named name: S, _ handler: @escaping () -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the style for the tab view within the the current environment.
    ///
    /// [[tabview-style]]
    ///
    /// - Parameter style: The style to apply to this tab view.
    public func tabViewStyle<S>(_ style: S) -> some View where S : TabViewStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for buttons within this view to a button style with a
    /// custom appearance and custom interaction behavior.
    ///
    /// ![DefaultButtonStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/buttonstyle-plain-border-default-example-1.png)
    ///
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///              VStack {
    ///                  Button("Plain Banana🍌🍌") { tap() }
    ///                      .buttonStyle(PlainButtonStyle())
    ///
    ///                  Button("Borderless Banana🍌🍌") { tap() }
    ///                      .buttonStyle(BorderlessButtonStyle())
    ///
    ///                  Button("Default Banana🍌🍌") { tap() }
    ///                      .buttonStyle(DefaultButtonStyle())
    ///              }
    ///              .font(.title2)
    ///          }
    ///
    ///          func tap() {}
    ///      }
    public func buttonStyle<S>(_ style: S) -> some View where S : PrimitiveButtonStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that calls a function whenever a value is received by a publisher.
    ///
    /// ```
    /// struct ReceiverView: View {
    ///     let timer = Timer.publish(every: 1.0, on: .main, in: .default).autoconnect()
    ///
    ///     @State var time = ""
    ///     var body: some View {
    ///         Text(time)
    ///             .onReceive(timer) { t in time = String(describing: t) }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - publisher: The publisher to subscribe to.
    ///   - action: The action to perform when an event is emitted by
    ///     `publisher`. The event emitted by publisher is passed as a
    ///     parameter to `action`.
    ///
    /// - Returns: A view that triggers `action` when `publisher` emits an
    ///   event.
    @inlinable public func onReceive<P>(_ publisher: P, perform action: @escaping (P.Output) -> Void) -> some View where P : Publisher, P.Failure == Never { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that applies a modifier to a view and returns a new view.
    ///
    /// Whenever you reuse a bunch of view modifiers together, it's a good idea
    /// to encapsulate them by creating a new ``ViewModifier``. Then, call that
    /// new modifier using this.
    ///
    /// Use this modifier to combine a `View` and a `ViewModifier`, to
    /// create a new view. For example, if you create a view modifier for
    /// a new kind of caption with blue text surrounded by a rounded rectangle:
    ///
    ///     struct BorderedCaption: ViewModifier {
    ///         func body(content: Content) -> some View {{}
    ///             content
    ///                 .font(.caption2)
    ///                 .padding(10)
    ///                 .overlay(
    ///                     RoundedRectangle(cornerRadius: 15)
    ///                         .stroke(lineWidth: 1)
    ///                 )
    ///                 .foregroundColor(Color.blue)
    ///         }
    ///     }
    ///
    /// You can use `modifier(_:)` to extend `View` to create new modifier
    /// for applying the `BorderedCaption` defined above:
    ///
    ///     extension View {
    ///         func borderedCaption() -> some View {{}
    ///             modifier(BorderedCaption())
    ///         }
    ///     }
    ///
    /// Then you can apply the bordered caption to any view:
    ///
    ///     Image(systemName: "bus")
    ///         .resizable()
    ///         .frame(width:50, height:50)
    ///     Text("Downtown Bus")
    ///         .borderedCaption()
    ///
    /// ![A screenshot showing the image of a bus with a caption reading
    /// Downtown Bus. A view extension, using custom a modifier, renders the
    ///  caption in blue text surrounded by a rounded
    ///  rectangle.](SwiftUI-View-ViewModifier.png)
    ///
    /// - Parameter modifier: The modifier to apply to this view.
    @inlinable public func modifier<T>(_ modifier: T) -> ModifiedContent<Self, T> { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets whether this view should ignore the system Smart Invert setting.
    ///
    /// Use this modifier to suppress Smart Invert in a view that shouldn't
    /// be inverted. Or pass an `active` argument of `false` to begin following
    /// the Smart Invert setting again when it was previously disabled.
    ///
    /// - Parameter active: A true value ignores the system Smart Invert
    ///   setting. A false value follows the system setting.
    @inlinable public func accessibilityIgnoresInvertColors(_ active: Bool = true) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that enables/disables user interaction.
    ///
    /// ```
    /// struct HitDisabledView: View {
    ///     var body: some View {
    ///         Button("Can't touch this 🎶") { /*this never happens*/ }
    ///             .allowsHitTesting(false)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter enabled: A boolean for whether the view allows user interaction.
    @inlinable public func allowsHitTesting(_ enabled: Bool) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Perform an action when a view appears.
    ///
    /// This is an extremely useful modifier for setting up any actions needed
    /// when the page first is loaded.
    ///
    /// ```
    /// struct AppearedView: View {
    ///     var body: some View {
    ///         Text("If you're reading this 🍌 was printed")
    ///             .onAppear { print("🍌") }
    ///     }
    /// }
    /// ```
    ///
    /// Whenever a view is rendered, even a previously rendered child view, `onAppear` will run. For example:
    ///
    /// ![On Appear Again](on-appear.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var bananaCount: Int = 0
    ///     @State var showBanana: Bool = true
    ///
    ///     var body: some View {
    ///         Text("We've created: \(bananaCount) bananas")
    ///
    ///         Toggle("Banana Toggle", isOn: $showBanana)
    ///
    ///         if showBanana {
    ///             Text("🍌🍌")
    ///                 .onAppear {
    ///                     bananaCount += 1
    ///                 }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter action: The action to perform. If `action` is `nil`, the
    ///   call has no effect.
    ///
    /// - Returns: A view that triggers `action` when this view appears.
    @inlinable public func onAppear(perform action: (() -> Void)? = nil) -> some View { }


    /// A view modifier that performs an action when the view disappears.
    ///
    /// ```
    /// struct DisappearingView: View {
    ///     var body: some View {
    ///         Text("When you close this 🍌 WILL be printed")
    ///             .onDisappear { print("🍌") }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter action: The action to perform. If `action` is `nil`, the
    ///   call has no effect.
    ///
    /// - Returns: A view that triggers `action` when this view disappears.
    @inlinable public func onDisappear(perform action: (() -> Void)? = nil) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View where Self : Equatable {

    /// A view modifier that prevents the view from updating its child view when its new value is the
    /// same as its old value.
    ///
    /// Use this modifier as an easier way of creating an ``EquatableView``.
    ///
    /// This line:
    ///
    /// ```
    /// EquatableView(content: Text("☮️"))
    /// ```
    ///
    /// is equal to this line:
    ///
    /// ```
    /// Text("☮️").equatable()
    /// ```
    ///
    /// For more info on equatable views, check out ``EquatableView``.
    /// For an in-depth overview of when to use equatable views, check out this
    /// fantastic article: [The Mystery Behind View Equality](https://swiftui-lab.com/equatableview/).
    @inlinable public func equatable() -> EquatableView<Self> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 14.0, *)
@available(watchOS, introduced: 6.0, deprecated: 7.0)
extension View {

    /// A view modifier that provides right click (macOS) or long hold (iOS) menu items.
    ///
    /// Use contextual menus to add actions that change depending on the user's
    /// current focus and task.
    ///
    /// The following example creates a `Text` view with a contextual menu.
    /// Note that the actions invoked by the menu selection could be coded
    /// directly inside the button closures or, as shown below, invoked via
    /// function references.
    ///
    /// ```
    /// struct ContextMenuView: View {
    ///     var body: some View {
    ///         Text("Favorite Card Suit")
    ///             .contextMenu {
    ///                 Button("♥️ - Hearts", action: { })
    ///                 Button("♣️ - Clubs", action: { })
    ///                 Button("♠️ - Spades", action: { })
    ///                 Button("♦️ - Diamonds", action: { })
    ///             }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter menuItems: A `contextMenu` that contains one or more menu items.
    /// - Returns: A view that adds a contextual menu to this view.
    public func contextMenu<MenuItems>(@ViewBuilder menuItems: () -> MenuItems) -> some View where MenuItems : View { }

}

@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use `contextMenu(menuItems:)` instead.")
@available(tvOS, unavailable)
@available(watchOS, introduced: 6.0, deprecated: 7.0)
extension View {

    /// A deprecated view modifier that attaches a context menu and its children to the view.
    ///
    /// Use `contextMenu(_:)` to attach a contextual menu struct and its
    /// children to the view. This modifier allows for the contextual menu to be
    /// conditionally available by passing `nil` as the value for `contextMenu`.
    ///
    /// In the example below a `ContextMenu` that contains four menu items is
    /// created and is passed into the `contextMenu(_:)` modifier. The
    /// attachment of context menu is controlled by the Boolean value
    /// `shouldShowMenu` which is `true`, enabling the contextual menu.
    ///
    /// Note that the actions invoked by the menu selection could be coded
    /// directly inside the button closures or, as shown below, invoked via
    /// function references.
    ///
    ///     func selectHearts() {
    ///         // Act on hearts selection.
    ///     }
    ///     func selectClubs() { ... }
    ///     func selectSpades() { ... }
    ///     func selectDiamonds() { ... }
    ///
    ///     let menuItems = ContextMenu {
    ///         Button("♥️ - Hearts", action: selectHearts)
    ///         Button("♣️ - Clubs", action: selectClubs)
    ///         Button("♠️ - Spades", action: selectSpades)
    ///         Button("♦️ - Diamonds", action: selectDiamonds)
    ///     }
    ///
    ///     struct ContextMenuMenuItems: View {
    ///         private var shouldShowMenu = true
    ///         var body: some View {
    ///             VStack {
    ///                 Text("Favorite Card Suit")
    ///                     .padding()
    ///                     .contextMenu(shouldShowMenu ? menuItems : nil)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter contextMenu: A context menu container for views that you
    ///   present as menu items in a contextual menu.
    ///
    /// - Returns: A view that adds a contextual menu to this view.
    public func contextMenu<MenuItems>(_ contextMenu: ContextMenu<MenuItems>?) -> some View where MenuItems : View { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that sets the style for menus.
    ///
    /// To set a specific style for all menu instances within a view, use the
    /// `menuStyle(_:)` modifier. Pass an instance of a struct that
    /// conforms to the ``MenuStyle`` protocol.
    ///
    /// Existing menu styles include:
    /// - ``DefaultMenuButtonStyle``
    /// - ``BorderlessMenuButtonStyle``
    /// - ``BorderedMenuButtonStyle`` (on macOS)
    ///
    /// The ``MenuStyle`` protocol also supports custom structures.
    ///
    /// ```
    /// struct ButtonStyleView: View {
    ///     var body: some View {
    ///         Menu("PDF") {
    ///             Button("Open in Preview", action: { })
    ///             Button("Save as PDF", action: { })
    ///         }
    ///         .menuStyle(ButtonMenuStyle())
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter style: Your desired ``MenuStyle``.
    /// - Returns: A view with styled menus.
    public func menuStyle<S>(_ style: S) -> some View where S : MenuStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that connects a gesture to the view, with lower priority than existing gestures.
    ///
    /// Use this modifier to attach a gesture to a view.
    ///
    /// Make sure that your first parameter conforms to the ``Gesture`` protocol. For
    /// more information about the second parameter, check out ``GestureMask``.
    ///
    /// - Note: If the view already has gestures defined, they will override any
    /// gesture attached using this view modifier. To attach a gesture with a
    /// higher priority than gestures already attached to the view, use
    /// ``View/highPriorityGesture(_:including:)``. To attach
    /// a gesture with the same priority as gestures already attached to the view, use
    /// ``View/simultaneousGesture(_:including:)``.
    ///
    /// ```
    /// struct DoubleTapView: View {
    ///     let g = TapGesture(count: 2).onEnded { print("2️⃣") }
    ///     var body: some View {
    ///         Text("Double tap me 👇")
    ///             .gesture(g)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - gesture: The gesture to connect to the view.
    ///   - mask: The ``GestureMask`` to use.
    public func gesture<T>(_ gesture: T, including mask: GestureMask = .all) -> some View where T : Gesture { }


    /// A view modifier that connects a gesture to the view, with higher priority than existing gestures.
    ///
    /// Use this modifier to attach a gesture to a view. Using this modifier will ensure
    /// that the gesture is not overridden by any gestures already defined
    /// in the view.
    ///
    /// Make sure that your first parameter conforms to the ``Gesture`` protocol. For
    /// more information about the second parameter, check out ``GestureMask``.
    ///
    /// - Note: This modifier will override any gestures already defined in
    /// the view. If you would prefer gestures already defined in the view override
    /// the gesture defined here, use
    /// ``View/gesture(_:including:)`` instead. If you would
    /// rather that all gestures be executed simultaneously, use
    /// ``View/simultaneousGesture(_:including:)``.
    ///
    /// ```
    /// struct DoubleTapView: View {
    ///     let g = TapGesture(count: 2).onEnded { print("2️⃣") }
    ///     var body: some View {
    ///         ZStack {
    ///             Text("Double tap me 👇")
    ///                 .onTapGesture { /*this never happens*/ }
    ///         }
    ///         .highPriorityGesture(g)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - gesture: The gesture to connect to the view.
    ///   - mask: The ``GestureMask`` to use.
    public func highPriorityGesture<T>(_ gesture: T, including mask: GestureMask = .all) -> some View where T : Gesture { }


    /// A view modifier that connects a gesture to the view, with equal priority to existing gestures.
    ///
    /// Use this modifier to attach a gesture to a view. Using this modifier will ensure
    /// that the gesture is not overridden by any gestures already defined
    /// in the view.
    ///
    /// Make sure that your first parameter conforms to the ``Gesture`` protocol. For
    /// more information about the second parameter, check out ``GestureMask``.
    ///
    /// - Note: This modifier will not override any gestures already defined in
    /// the view. If you would prefer gestures already defined in the view override
    /// the gesture defined here, use
    /// ``View/gesture(_:including:)`` instead. If you would instead
    /// prefer that this gesture override gestures already defined in the view,
    /// use ``View/highPriorityGesture(_:including:)``.
    ///
    /// ```
    /// struct DoubleTapView: View {
    ///     let g = TapGesture(count: 2).onEnded { print("2️⃣") }
    ///     var body: some View {
    ///         ZStack {
    ///             Text("Double tap me 👇")
    ///                 .onTapGesture { print("1️⃣") }
    ///         }
    ///         .simultaneousGesture(g)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - gesture: The gesture to connect to the view.
    ///   - mask: The ``GestureMask`` to use.
    public func simultaneousGesture<T>(_ gesture: T, including mask: GestureMask = .all) -> some View where T : Gesture { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that presents a system interface for allowing the user to import an existing
    /// file.
    ///
    /// In order for the interface to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCompletion` will not be
    /// called.
    ///
    /// - Note: Changing `allowedContentTypes` while the file importer is
    ///   presented will have no immediate effect, however will apply the next
    ///   time it is presented.
    ///
    /// ```
    /// import SwiftUI
    /// import UniformTypeIdentifiers
    ///
    /// struct ContentView: View {
    ///     @State private var showImporter = false
    ///     @State private var textInFile = ""
    ///
    ///     var body: some View {
    ///         Button("Import File 📁") {
    ///             showImporter = true
    ///         }
    ///         .fileImporter(isPresented: $showImporter,
    ///                       allowedContentTypes: [.plainText]) { result in
    ///
    ///              switch result {
    ///              case .failure(let error):
    ///                  print("Error selecting file: \(error.localizedDescription:)")
    ///              case .success(let url):
    ///                 do {
    ///                     if url.startAccessingSecurityScopedResource() {
    ///                         textInFile = try String(contentsOf: url)
    ///                         url.stopAccessingSecurityScopedResource()
    ///                     }
    ///                 } catch let error {
    ///                     print("Error reading file \(error.localizedDescription)")
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    ///
    /// ```
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - allowedContentTypes: The list of supported content types which can
    ///     be imported.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], onCompletion: @escaping (Result<URL, Error>) -> Void) -> some View { }


    /// A view modifier that presents a system interface for allowing the user to import multiple
    /// files.
    ///
    /// In order for the interface to appear, `isPresented` must be `true`. When
    /// the operation is finished, `isPresented` will be set to `false` before
    /// `onCompletion` is called. If the user cancels the operation,
    /// `isPresented` will be set to `false` and `onCompletion` will not be
    /// called.
    ///
    /// - Note: Changing `allowedContentTypes` or `allowsMultipleSelection`
    ///   while the file importer is presented will have no immediate effect,
    ///   however will apply the next time it is presented.
    ///
    /// ```
    /// import SwiftUI
    /// import UniformTypeIdentifiers
    ///
    /// struct ContentView: View {
    ///     @State private var showImporter = false
    ///     @State private var textInFiles = [String]()
    ///
    ///     var body: some View {
    ///         Button("Import Files 📁📂") {
    ///             showImporter = true
    ///         }
    ///         .fileImporter(isPresented: $showImporter,
    ///                       allowedContentTypes: [.plainText],
    ///                       allowsMultipleSelection: true) { result in
    ///
    ///              switch result {
    ///              case .failure(let error):
    ///                  print("Error selecting file: \(error.localizedDescription:)")
    ///              case .success(let urls):
    ///                 textInFiles = []
    ///                 for url in urls {
    ///                     do {
    ///                         if url.startAccessingSecurityScopedResource() {
    ///                             textInFiles.append(try String(contentsOf: url))
    ///                             url.stopAccessingSecurityScopedResource()
    ///                         }
    ///                     } catch let error {
    ///                         print("Error reading file \(error.localizedDescription)")
    ///                     }
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    ///
    /// ```
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - allowedContentTypes: The list of supported content types which can
    ///     be imported.
    ///   - allowsMultipleSelection: Whether the importer allows the user to
    ///     select more than one file to import.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileImporter(isPresented: Binding<Bool>, allowedContentTypes: [UTType], allowsMultipleSelection: Bool, onCompletion: @escaping (Result<[URL], Error>) -> Void) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for buttons within this view to a button style with a
    /// custom appearance and standard interaction behavior.
    ///
    /// ![DefaultButtonStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/buttonstyle-plain-border-default-example-1.png)
    ///
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///              VStack {
    ///                  Button("Plain Banana🍌🍌") { tap() }
    ///                      .buttonStyle(PlainButtonStyle())
    ///
    ///                  Button("Borderless Banana🍌🍌") { tap() }
    ///                      .buttonStyle(BorderlessButtonStyle())
    ///
    ///                  Button("Default Banana🍌🍌") { tap() }
    ///                      .buttonStyle(DefaultButtonStyle())
    ///              }
    ///              .font(.title2)
    ///          }
    ///
    ///          func tap() {}
    ///      }
    public func buttonStyle<S>(_ style: S) -> some View where S : ButtonStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

	/// Use this to transform the value of an existing anchor preference.
	///
	/// - Parameters:
	///   - key: The key type of the preference key.
	///   - value: The anchor you provide to the transform closure.
	///   - transform: A closure that takes an existing preference value and anchor value,
	///   and can update the existing preference with the given value.
    @inlinable public func transformAnchorPreference<A, K>(key _: K.Type = K.self, value: Anchor<A>.Source, transform: @escaping (inout K.Value, Anchor<A>) -> Void) -> some View where K : PreferenceKey { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// A view modifier that replaces content with a smart placeholder.
    ///
    /// Use this modifier to add a redaction reason to a view hierarchy. Redaction
    /// reasons often update the appearance of the view. Currently,
    /// there is only 1 redaction reason: ``RedactionReasons.placeholder``.
    /// Adding this reason to the view will replace the view with a placeholder graphic.
    ///
    /// Adding a redaction is an additive process: any redaction
    /// provided will be added to the reasons provided by the parent.
    ///
    /// ```
    /// struct RedactedView: View {
    ///     var body: some View {
    ///         Label("Taylor Swift", systemImage: "person.fill")
    ///         Label("Kanye West", systemImage: "person.fill")
    ///             .redacted(reason: .placeholder)
    ///     }
    /// }
    /// ```
    ///
    /// Your child view can also read the redacted reason from its environment:
    ///
    /// ```
    /// struct RedactedView: View {
    ///     var body: some View {
    ///         ChildView()
    ///             .redacted(reason: .placeholder)
    ///     }
    /// }
    ///
    /// struct ChildView: View {
    ///     @Environment(\.redactionReasons) var redactionReasons
    ///     var redacted: Bool { redactionReasons.contains(.placeholder) }
    ///
    ///     var body: some View {
    ///         if !redacted {
    ///             Text("If you're reading this I'm not redacted")
    ///         }
    ///     }
    /// }
    /// ```
    /// - Parameter reason: The reason for redacting the content.
    public func redacted(reason: RedactionReasons) -> some View { }


    /// A view modifier that removes all redaction reasons from a view.
    ///
    /// ```
    /// struct UnredactedView: View {
    ///     var body: some View {
    ///         ChildView()
    ///             .redacted(reason: .placeholder)
    ///     }
    /// }
    ///
    /// struct ChildView: View {
    ///     var body: some View {
    ///         Text("You can't redact me 😎")
    ///             .unredacted()
    ///     }
    /// }
    /// ```
    public func unredacted() -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

	/// Places a view behind the current view.
	///
	/// The layout of the original view will be unchanged from this. Its original
	/// size and location will stay the same.
	///
	/// If you would like to place a view in front of your current view instead,
	/// you can use the `overlay(_:alignment:)` function.
    ///
    /// ```
    /// struct OverlayView: View {
    ///     var body: some View {
    ///         Text("I have a floral background")
    ///             .background(Text("🌸🌹🌺💐"))
    ///     }
    /// }
    /// ```
	///
	/// - Parameters:
	///   - background: The view to place behind.
	///   - alignment: Where to align the behind view relative to the current view. Defaults to center.
	///
	/// - SeeAlso: overlay(_:alignment:)
    @inlinable public func background<Background>(_ background: Background, alignment: Alignment = .center) -> some View where Background : View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

	/// A view modifier that places a view in front of the current view.
	///
	/// The layout of the original view will be unchanged from this. Its original
	/// size and location will stay the same.
	///
	/// If you would like to place a view behind your current view instead,
	/// you can use the `background(_:alignment:)` function.
    ///
    /// ```
    /// struct OverlayView: View {
    ///     var body: some View {
    ///         Text("I'm covered by clouds")
    ///             .overlay(Text("🌤⛅️☁️🌦"))
    ///     }
    /// }
    /// ```
	///
	/// - Parameters:
	///   - overlay: The view to place in front.
	///   - alignment: Where to align the in-front view relative to the current view. Defaults to center.
	///
	/// - SeeAlso: background(_:alignment:)
    @inlinable public func overlay<Overlay>(_ overlay: Overlay, alignment: Alignment = .center) -> some View where Overlay : View { }


    /// A view modifier that adds a border to the view with the specified style and width.
    ///
    /// Use `border(_:width:)` to draw a border of a specified width around the
    /// view's frame. By default, the border appears inside the bounds of this
    /// view. In this example, the four-point wide border covers the text:
    ///
    /// ```
    /// struct BorderView: View {
    ///     var body: some View {
    ///         Text("Purple border inside the view bounds")
    ///             .border(Color.purple, width: 4)
    ///     }
    /// }
    /// ```
    ///
    /// To place a border around the outside of this view, apply padding of the
    /// same width before adding the border:
    ///
    /// ```
    /// struct PaddedBorderView {
    ///     var body: some View {
    ///         Text("Purple border outside the view bounds.")
    ///             .padding(4)
    ///             .border(Color.purple, width: 4)
    ///     }
    /// }
    /// ```
    ///
    /// A border doesn't have to be a plain color - it can be any ``ShapeStyle``, for example,
    /// a ``LinearGradient``:
    ///
    /// ```
    /// struct GradientBorderView {
    ///     var body: some View {
    ///         Text("Gradient border.")
    ///             .border(LinearGradient(gradient: Gradient(color: [.purple, .pink]),
    ///                                    startPoint: .top,
    ///                                    endPoint: .bottom), width: 4)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - content: The border style.
    ///   - width: The thickness of the border; if not provided, the default is
    ///     1 pixel.
    ///
    /// - Returns: A view that adds a border with the specified style and width
    ///   to this view.
    @inlinable public func border<S>(_ content: S, width: CGFloat = 1) -> some View where S : ShapeStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that constrains this view's dimensions to the specified aspect ratio.
    ///
    /// Use `aspectRatio(_:contentMode:)` to constrain a view's dimensions to an
    /// aspect ratio specified by a [CGFloat](https://developer.apple.com/documentation/coregraphics/cgfloat)
    /// using the specified content mode.
    ///
    /// If this view is resizable, the resulting view will have `aspectRatio` as
    /// its aspect ratio. In this example, the purple ellipse has a 3:4
    /// width-to-height ratio, and scales to fit its frame:
    ///
    /// ```
    /// struct EllipseView: View {
    ///     var body: some View {
    ///         Ellipse()
    ///             .fill(Color.purple)
    ///             .aspectRatio(0.75, contentMode: .fit) // 3:4 aspect ratio -> 3/4 = 0.75
    ///             .frame(width: 200, height: 200)
    ///             .border(Color(white: 0.75))
    ///     }
    /// ```
    ///
    /// - Parameters:
    ///   - aspectRatio: The ratio of width to height to use for the resulting
    ///     view. Use `nil` to maintain the current aspect ratio in the
    ///     resulting view.
    ///   - contentMode: A flag that indicates whether this view fits or fills
    ///     the parent context.
    ///
    /// - Returns: A view that constrains this view's dimensions to the aspect
    ///   ratio of the given size using `contentMode` as its scaling algorithm.
    @inlinable public func aspectRatio(_ aspectRatio: CGFloat? = nil, contentMode: ContentMode) -> some View { }


    /// A view modifier that constrains this view's dimensions to the aspect ratio of the given size.
    ///
    /// Use `aspectRatio(_:contentMode:)` to contstrain a view's dimentsions to
    /// an aspect ratio specified by a [CGSize](https://developer.apple.com/documentation/coregraphics/cgsize).
    ///
    /// If this view is resizable, the resulting view uses `aspectRatio` as its
    /// own aspect ratio. In this example, the purple ellipse has a 3:4
    /// width-to-height ratio, and scales to fill its frame:
    ///
    /// ```
    /// struct EllipseView: View {
    ///     var body: some View {
    ///         Ellipse()
    ///             .fill(Color.purple)
    ///             .aspectRatio(CGSize(width: 3, height: 4), contentMode: .fill)
    ///             .frame(width: 200, height: 200)
    ///             .border(Color(white: 0.75))
    ///     }
    /// ```
    ///
    /// - Parameters:
    ///   - aspectRatio: A size that specifies the ratio of width to height to
    ///     use for the resulting view.
    ///   - contentMode: A flag indicating whether this view should fit or fill
    ///     the parent context.
    ///
    /// - Returns: A view that constrains this view's dimensions to
    ///   `aspectRatio`, using `contentMode` as its scaling algorithm.
    @inlinable public func aspectRatio(_ aspectRatio: CGSize, contentMode: ContentMode) -> some View { }


    /// A view modifier that scales this view to fit its parent.
    ///
    /// Use `scaledToFit()` to scale this view to fit its parent, while
    /// maintaining the view's aspect ratio as the view scales.
    ///
    /// ```
    /// struct FitView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .fill(Color.pink)
    ///             .scaledToFit()
    ///             .frame(width: 300, height: 150)
    ///             .border(Color(white: 0.75))
    ///     }
    /// }
    /// ```
    ///
    /// This method is equivalent to calling
    /// `View/aspectRatio(_:contentMode:)-5ehx6` with a `nil` aspectRatio and
    /// a content mode of `ContentMode/fit`.
    ///
    /// - Returns: A view that scales this view to fit its parent, maintaining
    ///   this view's aspect ratio.
    @inlinable public func scaledToFit() -> some View { }


    /// A view modifier that scales this view to fill its parent.
    ///
    /// Use `scaledToFill()` to scale this view to fill its parent, while
    /// maintaining the view's aspect ratio as the view scales:
    ///
    /// ```
    /// struct FillView: View {
    ///     var body: some View {
    ///         Circle()
    ///             .fill(Color.pink)
    ///             .scaledToFill()
    ///             .frame(width: 300, height: 150)
    ///             .border(Color(white: 0.75))
    ///     }
    /// }
    /// ```
    ///
    /// This method is equivalent to calling
    /// `View/aspectRatio(_:contentMode:)-5ehx6` with a `nil` aspectRatio and
    /// a content mode of `ContentMode/fill`.
    ///
    /// - Returns: A view that scales this view to fill its parent, maintaining
    ///   this view's aspect ratio.
    @inlinable public func scaledToFill() -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that fixes this view at its ideal size in the specified dimensions.
    ///
    /// This function behaves like `View/fixedSize()`, except with
    /// `fixedSize(horizontal:vertical:)` the fixing of the axes can be
    /// optionally specified in one or both dimensions. For example, if you
    /// horizontally fix a text view before wrapping it in the frame view,
    /// you're telling the text view to maintain its ideal _width_. The view
    /// calculates this to be the space needed to represent the entire string.
    ///
    /// ```
    /// struct FixedSizeView: View {
    ///     var body: some View {
    ///         Text("A single line of text, too long to fit in a box.")
    ///             .fixedSize(horizontal: true, vertical: false)
    ///             .frame(width: 200, height: 200)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// This can result in the view exceeding the parent's bounds, which may or
    /// may not be the effect you want.
    ///
    /// - Parameters:
    ///   - horizontal: A Boolean value that indicates whether to fix the width
    ///     of the view.
    ///   - vertical: A Boolean value that indicates whether to fix the height
    ///     of the view.
    ///
    /// - Returns: A view that fixes this view at its ideal size in the
    ///   dimensions specified by `horizontal` and `vertical`.
    @inlinable public func fixedSize(horizontal: Bool, vertical: Bool) -> some View { }


    /// A view modifier that fixes this view at its ideal size.
    ///
    /// During the layout of the view hierarchy, each view proposes a size to
    /// each child view it contains. If the child view doesn't need a fixed size
    /// it can accept and conform to the size offered by the parent.
    ///
    /// For example, a `Text` view placed in an explicitly sized frame wraps
    /// and truncates its string to remain within its parent's bounds:
    ///
    /// ```
    /// struct FixedSizeView: View {
    ///     var body: some View {
    ///         Text("A single line of text, too long to fit in a box.")
    ///             .frame(width: 200, height: 200)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// The `fixedSize()` modifier can be used to create a view that maintains
    /// the *ideal size* of its children both dimensions:
    ///
    /// ```
    /// struct FixedSizeView: View {
    ///     var body: some View {
    ///         Text("A single line of text, too long to fit in a box.")
    ///             .fixedSize()
    ///             .frame(width: 200, height: 200)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// This can result in the view exceeding the parent's bounds, which may or
    /// may not be the effect you want.
    ///
    /// You can think of `fixedSize()` as the creation of a *counter proposal*
    /// to the view size proposed to a view by its parent. The ideal size of a
    /// view, and the specific effects of `fixedSize()` depends on the
    /// particular view and how you have configured it.
    ///
    /// To create a view that fixes the view's size in either the horizontal or
    /// vertical dimensions, see `View/fixedSize(horizontal:vertical:)`.
    ///
    /// - Returns: A view that fixes this view at its ideal size.
    @inlinable public func fixedSize() -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

  /// Sets the color of the text displayed by this view.
  ///
  /// Use this method to change the color of the text rendered by a text view.
  ///
  /// For example, you can change the color of Banana🍌🍌 to yellow and Apple🍎🍎 to red.
  ///
  /// ![foregroundColor Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/text-foregroundColor-example-1.png)
  ///
  ///     struct ExampleView: View {
  ///        var body: some View {
  ///            VStack {
  ///                Text("Banana🍌🍌")
  ///                    .foregroundColor(.yellow)
  ///                Text("Apple 🍎🍎")
  ///                    .foregroundColor(.red)
  ///                Text("Peach 🍑🍑")
  ///                    .foregroundColor(.orange)
  ///            }
  ///            .font(.largeTitle)
  ///        }
  ///     }
  ///
  ///
  ///
  /// - Parameter color: The color to use when displaying this text.
  /// - Returns: A text view that uses the color value you supply.
    @inlinable public func foregroundColor(_ color: Color?) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for pickers within this view.
    public func pickerStyle<S>(_ style: S) -> some View where S : PickerStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Pads this view using the edges and padding amount you specify.
    ///
    /// Use `padding(_:)` to add a specified amount of padding to one or more
    /// edges of the view. For example, you can add padding of specific amounts
    /// to specified edges of a view:
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Text("20 point padding on the left and bottom edges.")
    ///                 .padding(EdgeInsets(top: 0, leading: 20, bottom: 20, trailing: 0))
    ///                 .border(Color.gray)
    ///             Text("Unpadded text")
    ///                 .border(Color.yellow)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// To pad selected outside edges of a view with an amount you specify, see
    /// `View/padding(_:_:)`. To pad all outside edges of a view with an
    /// amount you specify, see `View/padding(_:)-9f33x`.
    ///
    /// - Parameter insets: The edges and amounts to inset.
    ///
    /// - Returns: A view that pads this view using the specified edge insets
    ///   with specified amount of padding.
    @inlinable public func padding(_ insets: EdgeInsets) -> some View { }


    /// A view that pads this view inside the specified edge insets with a
    /// system-calculated amount of padding.
    ///
    /// Use `padding(_:)` to add a system-calculated amount of padding inside
    /// one or more of the view's edges by passing either a single edge name, or
    /// an `OptionSet` describing which edges should be padded. For example you
    /// can add padding to the bottom of a text view:
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Text("Text padded on the bottom edge.")
    ///                 .padding(.bottom)
    ///                 .border(Color.gray)
    ///             Text("Unpadded text")
    ///                 .border(Color.yellow)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// To pad the view's insets, which affects the amount of padding _inside_
    /// the edges of the view, see `View/padding(_:)-6pgqq`. To pad all
    /// outside edges of a view with an amount you specify, see
    /// `View/padding(_:)-9f33x`.
    ///
    /// - Parameters:
    ///   - edges: The set of edges along which to pad this view; if `nil` the
    ///     specified or system-calculated mount is applied to all edges.
    ///   - length: The amount to inset this view on the specified edges. If
    ///     `nil`, the amount is the system-default amount.
    ///
    /// - Returns: A view that pads this view using the specified edge insets
    ///   with specified amount of padding.
    @inlinable public func padding(_ edges: Edge.Set = .all, _ length: CGFloat? = nil) -> some View { }


    /// Pads the view along all edges by the specified amount.
    ///
    /// Use `padding(_:)` to add a specific amount of padding around all edges
    /// of the view.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Text("Text padded by 10 points on each edge.")
    ///                 .padding(10.0)
    ///                 .border(Color.gray)
    ///             Text("Unpadded text")
    ///                 .border(Color.yellow)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter length: The amount to pad this view on each edge.
    ///
    /// - Returns: A view that pads this view by the amount you specify.
    @inlinable public func padding(_ length: CGFloat) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that translates this view horizontally and vertically by a CGSize.
    ///
    /// Use `offset(_:)` to to shift the displayed contents by the amount
    /// specified in the `offset` parameter.
    ///
    /// The original dimensions of the view aren't changed by offsetting the
    /// contents; in the example below the gray border drawn by this view
    /// surrounds the original position of the text:
    ///
    /// ```
    /// struct OffsetView: View {
    ///     var body: some View {
    ///         Text("Offset by passing CGSize()")
    ///             .border(Color.green)
    ///             .offset(CGSize(width: 20, height: 25))
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter offset: The distance to offset this view.
    ///
    /// - Returns: A view that offsets this view by `offset`.
    @inlinable public func offset(_ offset: CGSize) -> some View { }


    /// A view modifier this view by the specified horizontal and vertical CGFloats.
    ///
    /// Use `offset(x:y:)` to to shift the displayed contents by the amount
    /// specified in the `x` and `y` parameters.
    ///
    /// The original dimensions of the view aren't changed by offsetting the
    /// contents; in the example below the gray border drawn by this view
    /// surrounds the original position of the text:
    ///
    /// ```
    /// struct OffsetView: View {
    ///     var body: some View {
    ///         Text("Offset by passing horizontal & vertical distance")
    ///             .border(Color.green)
    ///             .offset(x: 20, y: 50)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - x: The horizontal distance to offset this view.
    ///   - y: The vertical distance to offset this view.
    ///
    /// - Returns: A view that offsets this view by `x` and `y`.
    @inlinable public func offset(x: CGFloat = 0, y: CGFloat = 0) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the view's horizontal alignment.
    ///
    /// Use `alignmentGuide(_:computeValue:)` to calculate specific offsets
    /// to reposition views in relationship to one another. You can return a
    /// constant or can use the `ViewDimensions` argument to the closure to
    /// calculate a return value.
    ///
    /// In the example below, the `HStack` is offset by a constant of 50
    /// points to the right of center:
    ///
    ///     VStack {
    ///         Text("Today's Weather")
    ///             .font(.title)
    ///             .border(Color.gray)
    ///         HStack {
    ///             Text("🌧")
    ///             Text("Rain & Thunderstorms")
    ///             Text("⛈")
    ///         }
    ///         .alignmentGuide(HorizontalAlignment.center) { _ in  50 }
    ///         .border(Color.gray)
    ///     }
    ///     .border(Color.gray)
    ///
    /// Changing the alignment of one view may have effects on surrounding
    /// views. Here the offset values inside a stack and its contained views is
    /// the difference of their absolute offsets.
    ///
    /// ![A view showing the two emoji offset from a text element using a
    /// horizontal alignment guide.](SwiftUI-View-HAlignmentGuide.png)
    ///
    /// - Parameters:
    ///   - g: A `HorizontalAlignment` value at which to a base the offset.
    ///   - computeValue: A closure that returns the offset value to apply to
    ///     this view.
    ///
    /// - Returns: A view modified with respect to its horizontal alignment
    ///   according to the computation performed in the method's closure.
    @inlinable public func alignmentGuide(_ g: HorizontalAlignment, computeValue: @escaping (ViewDimensions) -> CGFloat) -> some View { }


    /// Sets the view's vertical alignment.
    ///
    /// Use `alignmentGuide(_:computeValue:)` to calculate specific offsets
    /// to reposition views in relationship to one another. You can return a
    /// constant or can use the `ViewDimensions` argument to the closure to
    /// calculate a return value.
    ///
    /// In the example below, the weather emoji are offset 20 points from the
    /// vertical center of the `HStack`.
    ///
    ///     VStack {
    ///         Text("Today's Weather")
    ///             .font(.title)
    ///             .border(Color.gray)
    ///
    ///         HStack {
    ///             Text("🌧")
    ///                 .alignmentGuide(VerticalAlignment.center) { _ in -20 }
    ///             Text("Rain & Thunderstorms")
    ///                 .border(Color.gray)
    ///             Text("⛈")
    ///                 .alignmentGuide(VerticalAlignment.center) { _ in 20 }
    ///                 .border(Color.gray)
    ///         }
    ///     }
    ///
    /// Changing the alignment of one view may have effects on surrounding
    /// views. Here the offset values inside a stack and its contained views is
    /// the difference of their absolute offsets.
    ///
    /// ![A view showing the two emoji offset from a text element using a
    /// vertical alignment guide.](SwiftUI-View-VAlignmentGuide.png)
    ///
    /// - Parameters:
    ///   - g: A `VerticalAlignment` value at which to a base the offset.
    ///   - computeValue: A closure that returns the offset value to apply to
    ///     this view.
    ///
    /// - Returns: A view modified with respect to its vertical alignment
    ///   according to the computation performed in the method's closure.
    @inlinable public func alignmentGuide(_ g: VerticalAlignment, computeValue: @escaping (ViewDimensions) -> CGFloat) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that positions the center of this view at the specified point in its parent's
    /// coordinate space.
    ///
    /// Use the `position(_:)` modifier to place the center of a view at a
    /// specific coordinate in the parent view using a [CGPoint](https://developer.apple.com/documentation/coregraphics/cgpoint)
    /// to specify the `x`
    /// and `y` offset.
    ///
    /// ```
    /// struct PositionView: View {
    ///     var body: some View {
    ///         Text("Position by passing a CGPoint()")
    ///             .position(CGPoint(x: 175, y: 100))
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter position: The point at which to place the center of this
    ///   view.
    ///
    /// - Returns: A view that fixes the center of this view at `position`.
    @inlinable public func position(_ position: CGPoint) -> some View { }


    /// A view modifier that positions the center of this view at the specified coordinates in its
    /// parent's coordinate space.
    ///
    /// Use the `position(x:y:)` modifier to place the center of a view at a
    /// specific coordinate in the parent view using an `x` and `y` offset.
    ///
    /// ```
    /// struct PositionView: View {
    ///     var body: some View {
    ///         Text("Position by passing the x and y coordinates")
    ///             .position(x: 175, y: 100)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - x: The x-coordinate at which to place the center of this view.
    ///   - y: The y-coordinate at which to place the center of this view.
    ///
    /// - Returns: A view that fixes the center of this view at `x` and `y`.
    @inlinable public func position(x: CGFloat = 0, y: CGFloat = 0) -> some View { }

}

@available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use ignoresSafeArea(_:edges:) instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Use ignoresSafeArea(_:edges:) instead.")
@available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use ignoresSafeArea(_:edges:) instead.")
@available(watchOS, introduced: 6.0, deprecated: 100000.0, message: "Use ignoresSafeArea(_:edges:) instead.")
extension View {

    /// Changes the view's proposed area to extend outside the screen's safe
    ///
    /// **DEPRECATED**: use ``View/ignoresSafeArea(_:edges:)`` instead.
    ///
    /// Use `edgesIgnoringSafeArea(_:)` to change the area proposed for this
    /// view so that — were the proposal accepted — this view could extend
    /// outside the safe area to the bounds of the screen for the specified
    /// edges.
    ///
    /// For example, you can propose that a text view ignore the safe area's top
    /// inset:
    ///
    ///     VStack {
    ///         Text("This text is outside of the top safe area.")
    ///             .edgesIgnoringSafeArea([.top])
    ///             .border(Color.purple)
    ///         Text("This text is inside VStack.")
    ///             .border(Color.yellow)
    ///     }
    ///     .border(Color.gray)
    ///
    /// ![A screenshot showing a view whose bounds exceed the safe area of the
    /// screen.](SwiftUI-View-edgesIgnoringSafeArea.png)
    ///
    /// Depending on the surrounding view hierarchy, SwiftUI may not honor an
    /// `edgesIgnoringSafeArea(_:)` request. This can happen, for example, if
    /// the view is inside a container that respects the screen's safe area. In
    /// that case you may need to apply `edgesIgnoringSafeArea(_:)` to the
    /// container instead.
    ///
    /// - Parameter edges: The set of the edges in which to expand the size
    ///   requested for this view.
    ///
    /// - Returns: A view that may extend outside of the screen's safe area
    ///   on the edges specified by `edges`.
    @inlinable public func edgesIgnoringSafeArea(_ edges: Edge.Set) -> some View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// A view modifier that expands the view out of its safe area.
    ///
    /// Use this modifier to extend your content beyond the safe area.
    ///
    /// There are two parameters: the safe area regions to ignore, and the edges that
    /// you would like to ignore those safe areas.
    ///
    /// The first parameter is of type ``SafeAreaRegions``. The options are:
    /// - `.container`: The navigation bar and bottom bar on iPhone X+.
    /// - `.keyboard`: The software keyboard area.
    /// - `.all`: All safe areas
    ///
    /// The second parameter has edge options:
    /// - `.leading`
    /// - `.trailing`
    /// - `.top`
    /// - `.bottom`
    ///
    /// ```
    /// struct SafeAreaIgnoringView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Color.pink
    ///             Text("I am everywhere")
    ///         }
    ///         .ignoresSafeArea(.all, edges: [.top, .bottom])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - regions: the kinds of rectangles removed from the safe area
    ///     that should be ignored (i.e. added back to the safe area
    ///     of the new child view.
    ///   - edges: the edges of the view that may be outset, any edges
    ///     not in this set will be unchanged, even if that edge is
    ///     abutting a safe area listed in `regions`.
    ///
    /// - Returns: a new view with its safe area expanded.
    ///
    @inlinable public func ignoresSafeArea(_ regions: SafeAreaRegions = .all, edges: Edge.Set = .all) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the environment value of the specified key path to the given value.
    ///
    /// Use this modifier to set one of the writable properties of the
    /// `EnvironmentValues` structure, including custom values that you
    /// create. For example, you can set the value associated with the
    /// `EnvironmentValues/truncationMode` key:
    ///
    ///     MyView()
    ///         .environment(\.truncationMode, .head)
    ///
    /// You then read the value inside `MyView` or one of its descendants
    /// using the `Environment` property wrapper:
    ///
    ///     struct MyView: View {
    ///         @Environment(\.truncationMode) var truncationMode: Text.TruncationMode
    ///
    ///         var body: some View { ... }
    ///     }
    ///
    /// SwiftUI provides dedicated view modifiers for setting most
    /// environment values, like the `View/truncationMode(_:)`
    /// modifier which sets the `EnvironmentValues/truncationMode` value:
    ///
    ///     MyView()
    ///         .truncationMode(.head)
    ///
    /// Prefer the dedicated modifier when available, and offer your own when
    /// defining custom environment values, as described in
    /// `EnvironmentKey`.
    ///
    /// The `View/environment(_:_:)` modifier affects the given view,
    /// as well as that view's descendant views. It has no effect
    /// outside the view hierarchy on which you call it.
    ///
    /// - Parameters:
    ///   - keyPath: A key path that indicates the property of the
    ///     `EnvironmentValues` structure to update.
    ///   - value: The new value to set for the item specified by `keyPath`.
    ///
    /// - Returns: A view that has the given value set in its environment.
    @inlinable public func environment<V>(_ keyPath: WritableKeyPath<EnvironmentValues, V>, _ value: V) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that controls the display order of overlapping views.
    ///
    /// Use `zIndex(_:)` when you want to control the front-to-back ordering of
    /// views.
    ///
    /// In this example there are two overlapping rotated rectangles. The
    /// frontmost is represented by the larger index value.
    ///
    /// ```
    /// struct ZIndexView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Rectangle()
    ///                 .fill(Color.yellow)
    ///                 .frame(width: 100, height: 100, alignment: .center)
    ///                 .zIndex(1) // Top layer.
    ///
    ///             Rectangle()
    ///                 .fill(Color.red)
    ///                 .frame(width: 100, height: 100, alignment: .center)
    ///                 .rotationEffect(.degrees(45))
    ///                 // Here a zIndex of 0 is the default making
    ///                 // this the bottom layer.
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter value: A relative front-to-back ordering for this view; the
    ///   default is `0`.
    @inlinable public func zIndex(_ value: Double) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that applies an affine transformation to this view's rendered output.
    ///
    /// Use `transformEffect(_:)` to rotate, scale, translate, or skew the
    /// output of the view according to the provided
    /// [CGAffineTransform](https://developer.apple.com/documentation/coregraphics/cgaffinetransform).
    ///
    /// In the example below, the text is rotated at -30˚ on the `y` axis.
    ///
    /// ```
    /// struct TransformView: View {
    ///     let transform = CGAffineTransform(rotationAngle: -30 * (.pi / 180))
    ///
    ///     var body: some View {
    ///         Text("Projection effect using transforms")
    ///             .transformEffect(transform)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter transform: A
    /// [CGAffineTransform](https://developer.apple.com/documentation/coregraphics/cgaffinetransform).
    @inlinable public func transformEffect(_ transform: CGAffineTransform) -> some View { }

}

extension View {

    /// A view modifier that presents an action sheet that is passed a value.
    ///
    /// Use this modifier when your action sheet needs a passed value.
    /// The action will show when the value is not `nil`, and will set the
    /// value back to `nil` when it's dismissed.
    ///
    ///
    /// For more info on how to build an action sheet, check out ``ActionSheet``.
    /// To learn about action sheet's different buttons, see ``ActionSheet/Button``.
    ///
    /// ```
    /// struct Emoji: Identifiable {
    ///     let id = UUID()
    ///     let name: String
    /// }
    ///
    /// struct ContentView: View {
    ///     @State private var selection: Emoji?
    ///
    ///     var body: some View {
    ///         VStack {
    ///             Button("Eat 🍌") { selection = Emoji(name: "🍌") }
    ///             Button("Eat 🍑") { selection = Emoji(name: "🍑") }
    ///         }
    ///         .actionSheet(item: $selection) { selection in
    ///             let confirm = ActionSheet.Button.default(Text("Confirm \(selection.name)") { /*action here*/ }
    ///             let cancel = ActionSheet.Button.cancel(Text("Cancel")) { /*action here*/ }
    ///             let buttons = [save, cancel]
    ///
    ///             return ActionSheet(title: Text("Food alert!"),
    ///                                message: Text("You have made a selection"),
    ///                                buttons: buttons)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the action
    ///     sheet. When representing a non-`nil` item, the system uses
    ///     `content` to create an action sheet representation of the item.
    ///     If the identity changes, the system dismisses a currently-presented
    ///     action sheet and replace it with a new one.
    ///   - content: A closure returning the action sheet to present.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    @available(macOS, unavailable)
    public func actionSheet<T>(item: Binding<T?>, content: (T) -> ActionSheet) -> some View where T : Identifiable { }


    /// A view modifier that presents an action sheet when a given condition is true.
    ///
    /// For more info on how to build an action sheet, check out ``ActionSheet``.
    /// To learn about action sheet's different buttons, see ``ActionSheet/Button``.
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State private var showActionSheet = false
    ///
    ///     var body: some View {
    ///         Button("Eat 🍌") { showActionSheet = true }
    ///             .actionSheet(isPresented: $showActionSheet) {
    ///                 let confirm = ActionSheet.Button.default(Text("Confirm") { /*action here*/ }
    ///                 let cancel = ActionSheet.Button.cancel(Text("Cancel")) { /*action here*/ }
    ///                 let buttons = [save, cancel]
    ///
    ///                 return ActionSheet(title: Text("Food alert!"),
    ///                                message: Text("You have made a selection"),
    ///                                buttons: buttons)
    ///             }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the action sheet should be
    ///     shown.
    ///   - content: A closure returning the `ActionSheet` to present.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    @available(macOS, unavailable)
    public func actionSheet(isPresented: Binding<Bool>, content: () -> ActionSheet) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the accent color for this view and the views it contains.
    ///
    /// Use `accentColor(_:)` when you want to apply a broad theme color to
    /// your app's user interface. Some styles of controls use the accent color
    /// as a default tint color.
    ///
    /// On macOS, customization of the accent color is only applied if the
    /// "Multicolor" accent color is selected in System Preferences.
    ///
    /// In the example below, the outer `VStack` contains two child views, the
    /// first is a `VStack` containing a default accented button. The second
    /// `VStack` contains a button and a slider both of which adopt the purple
    /// accent color of their containing view. Note that the `Text` element
    /// used as a label alongside the `Slider` retains its default color.
    ///
    /// ```
    /// struct AccentColorView: View {
    ///     @State var sliderValue = 0.5
    ///
    ///     var body: some View {
    ///         VStack {
    ///             VStack {
    ///                 Button(action: { }) {
    ///                     Text("Regular Button")
    ///                 }
    ///             }
    ///             VStack {
    ///                 Button(action: { }) {
    ///                     Text("Accented Button")
    ///                 }
    ///                 Slider(value: $sliderValue) {
    ///                     Text("Accented Slider")
    ///                 }
    ///             }
    ///             .accentColor(.purple)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// Apply colors in lightmode & darkmode with `accentcolor`.
    ///
    /// Light Mode:
    /// ![Light Primary](color-primary-light.png)
    ///
    /// Dark Mode:
    /// ![Dark Primary](color-primary-dark.png)
    ///
    /// Code:
    ///
    ///    struct ExampleView: View {
    ///        var body: some View {
    ///            Text("Bananas 🍌🍌")
    ///                .accentColor(.primary)
    ///        }
    ///    }
    ///
    /// - Parameter accentColor: The color to use as an accent color. If `nil`,
    ///   the accent color continues to be inherited
    @available(iOS 13.0, macOS 11.0, tvOS 13.0, watchOS 6.0, *)
    @inlinable public func accentColor(_ accentColor: Color?) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Prevent view interaction.
    ///
    /// Disable interaction on a view.
    ///
    /// ![Disabled Example](disabled-example.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var isDisabled = false
    ///     var body: some View {
    ///         Toggle("Disable The Banana", isOn: $isDisabled)
    ///
    ///         Button("Banana 🍌🍌") { }
    ///             .disabled(isDisabled)
    ///     }
    /// }
    /// ```
    ///
    /// Another example:
    ///
    /// ```
    /// struct CantTouchThisView: View {
    ///     var body: some View {
    ///         Button(Text("Can't touch this 🎶")) { }
    ///             .disabled(true)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter disabled: A Boolean value that determines whether users can
    ///   interact with this view.
    ///
    /// - Returns: A view that controls whether users can interact with this
    ///   view.
    @inlinable public func disabled(_ disabled: Bool) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that rotates this view's rendered output around the specified point.
    ///
    /// Use `rotationEffect(_:anchor:)` to rotate the view by a specific amount.
    ///
    /// In the example below, the text is rotated by 22˚.
    ///
    /// ```
    /// struct RotationView: View {
    ///     var body: some View {
    ///         Text("Rotation by passing an angle in degrees")
    ///             .rotationEffect(.degrees(22))
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - angle: The angle at which to rotate the view.
    ///   - anchor: The location with a default of `UnitPoint/center` that
    ///     defines a point at which the rotation is anchored.
    @inlinable public func rotationEffect(_ angle: Angle, anchor: UnitPoint = .center) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that scales this view's rendered output by the given vertical and horizontal
    /// size amounts, relative to an anchor point.
    ///
    /// Use `scaleEffect(_:anchor:)` to scale a view by applying a scaling
    /// transform of a specific size, specified by `scale`.
    ///
    /// ```
    /// struct ScaleView: View {
    ///     var body: some View {
    ///         Image(systemName: "envelope.badge.fill")
    ///             .resizable()
    ///             .frame(width: 100, height: 100, alignment: .center)
    ///             .foregroundColor(Color.red)
    ///             .scaleEffect(CGSize(x: 0.9, y: 1.3), anchor: .leading)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - scale: A [CGSize](https://developer.apple.com/documentation/CoreGraphics/CGSize) that
    ///     represents the horizontal and vertical amount to scale the view.
    ///   - anchor: The point with a default of `UnitPoint/center` that
    ///     defines the location within the view from which to apply the
    ///     transformation.
    @inlinable public func scaleEffect(_ scale: CGSize, anchor: UnitPoint = .center) -> some View { }


    /// A view modifier that this view's rendered output by the given amount in both the
    /// horizontal and vertical directions, relative to an anchor point.
    ///
    /// Use `scaleEffect(_:anchor:)` to apply a horizontally and vertically
    /// scaling transform to a view.
    ///
    /// ```
    /// struct ScaleView: View {
    ///     var body: some View {
    ///         Image(systemName: "envelope.badge.fill")
    ///             .resizable()
    ///             .frame(width: 100, height: 100, alignment: .center)
    ///             .foregroundColor(Color.red)
    ///             .scaleEffect(2, anchor: .leading)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - s: The amount to scale the view in the view in both the horizontal
    ///     and vertical directions.
    ///   - anchor: The anchor point with a default of `UnitPoint/center` that
    ///     indicates the starting position for the scale operation.
    @inlinable public func scaleEffect(_ s: CGFloat, anchor: UnitPoint = .center) -> some View { }


    /// A view modifier that scales this view's rendered output by the given horizontal and vertical
    /// amounts, relative to an anchor point.
    ///
    /// Use `scaleEffect(x:y:anchor:)` to apply a scaling transform to a view by
    /// a specific horizontal and vertical amount.
    ///
    /// ```
    /// struct ScaleView: View {
    ///     var body: some View {
    ///         Image(systemName: "envelope.badge.fill")
    ///             .resizable()
    ///             .frame(width: 100, height: 100, alignment: .center)
    ///             .foregroundColor(Color.red)
    ///             .scaleEffect(x: 0.5, y: 0.5, anchor: .bottomTrailing)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - x: An amount that represents the horizontal amount to scale the
    ///     view. The default value is `1.0`.
    ///   - y: An amount that represents the vertical amount to scale the view.
    ///     The default value is `1.0`.
    ///   - anchor: The anchor point that indicates the starting position for
    ///     the scale operation.
    @inlinable public func scaleEffect(x: CGFloat = 1.0, y: CGFloat = 1.0, anchor: UnitPoint = .center) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that applies a Gaussian blur to this view.
    ///
    /// Use `blur(radius:opaque:)` to apply a gaussian blur effect to the
    /// rendering of this view.
    ///
    /// The example below shows two `Text` views, the first with no blur
    /// effects, the second with `blur(radius:opaque:)` applied with the
    /// `radius` set to `2`. The larger the radius, the more diffuse the
    /// effect.
    ///
    ///     struct BlurView: View {
    ///         var body: some View {
    ///             VStack {
    ///                 Text("This is some text.")
    ///                 Text("This is some blurry text.")
    ///                     .blur(radius: 2.0)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - radius: The radial size of the blur. A blur is more diffuse when its
    ///     radius is large.
    ///   - opaque: A Boolean value that indicates whether the blur renderer
    ///     permits transparency in the blur output. Set to `true` to create an
    ///     opaque blur, or set to `false` to permit transparency.
    @inlinable public func blur(radius: CGFloat, opaque: Bool = false) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Brightenen the view by the specified amount.
    ///
    /// Use `brightness(_:)` to brighten the intensity of the colors in a view.
    /// The example below shows a series of red squares, with their brightness
    /// increasing from 0 (fully red) to 100% (white) in 20% increments.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             ForEach(0..<6) { idx in
    ///                 RoundedRectangle(cornerRadius: 10.0)
    ///                     .fill(Color.yellow)
    ///                     .brightness(Double(idx)*0.2)
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter amount: A value between 0 (no effect) and 1 (full white
    ///   brightening) that represents the intensity of the brightness effect.
    ///
    /// - Returns: A view that brightens this view by the specified amount.
    @inlinable public func brightness(_ amount: Double) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that inverts the colors in this view.
    ///
    /// The `colorInvert()` modifier inverts all of the colors in a view so that
    /// each color displays as its complementary color. For example, blue
    /// converts to yellow, and white converts to black.
    ///
    /// In the example below, two red squares each have an interior green
    /// circle. The inverted square shows the effect of the square's colors:
    /// complimentary colors for red and green — teal and purple.
    ///
    ///     struct InnerCircleView: View {
    ///         var body: some View {
    ///             Circle()
    ///                 .fill(Color.green)
    ///                 .frame(width: 40, height: 40, alignment: .center)
    ///         }
    ///     }
    ///
    ///     struct ColorInvert: View {
    ///         var body: some View {
    ///             HStack {
    ///                 Color.red.frame(width: 100, height: 100, alignment: .center)
    ///                     .overlay(InnerCircleView(), alignment: .center)
    ///                     .overlay(Text("Normal")
    ///                                  .font(.callout),
    ///                              alignment: .bottom)
    ///                     .border(Color.gray)
    ///
    ///                 Spacer()
    ///
    ///                 Color.red.frame(width: 100, height: 100, alignment: .center)
    ///                     .overlay(InnerCircleView(), alignment: .center)
    ///                     .colorInvert()
    ///                     .overlay(Text("Inverted")
    ///                                  .font(.callout),
    ///                              alignment: .bottom)
    ///                     .border(Color.gray)
    ///             }
    ///             .padding(50)
    ///         }
    ///     }
    ///
    /// - Returns: A view that inverts its colors.
    @inlinable public func colorInvert() -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that adds a color multiplication effect to this view.
    ///
    /// The following example shows two versions of the same image side by side;
    /// at left is the original, and at right is a duplicate with the
    /// `colorMultiply(_:)` modifier applied with `Color/purple`.
    ///
    ///     struct InnerCircleView: View {
    ///         var body: some View {
    ///             Circle()
    ///                 .fill(Color.green)
    ///                 .frame(width: 40, height: 40, alignment: .center)
    ///         }
    ///     }
    ///
    ///     struct ColorMultiply: View {
    ///         var body: some View {
    ///             HStack {
    ///                 Color.red.frame(width: 100, height: 100, alignment: .center)
    ///                     .overlay(InnerCircleView(), alignment: .center)
    ///                     .overlay(Text("Normal")
    ///                                  .font(.callout),
    ///                              alignment: .bottom)
    ///                     .border(Color.gray)
    ///
    ///                 Spacer()
    ///
    ///                 Color.red.frame(width: 100, height: 100, alignment: .center)
    ///                     .overlay(InnerCircleView(), alignment: .center)
    ///                     .colorMultiply(Color.purple)
    ///                     .overlay(Text("Multiply")
    ///                                 .font(.callout),
    ///                              alignment: .bottom)
    ///                     .border(Color.gray)
    ///             }
    ///             .padding(50)
    ///         }
    ///     }
    ///
    /// - Parameter color: The color to bias this view toward.
    ///
    /// - Returns: A view with a color multiplication effect.
    @inlinable public func colorMultiply(_ color: Color) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the contrast and separation between similar colors in this view.
    ///
    /// Apply contrast to a view to increase or decrease the separation between
    /// similar colors in the view.
    ///
    /// In the example below, the `contrast(_:)` modifier is applied to a set of
    /// red squares each containing a contrasting green inner circle. At each
    /// step in the loop, the `contrast(_:)` modifier changes the contrast of
    /// the circle/square view in 20% increments. This ranges from -20% contrast
    /// (yielding inverted colors — turning the red square to pale-green and the
    /// green circle to mauve), to neutral-gray at 0%, to 100% contrast
    /// (bright-red square / bright-green circle). Applying negative contrast
    /// values, as shown in the -20% square, will apply contrast in addition to
    /// inverting colors.
    ///
    ///     struct CircleView: View {
    ///         var body: some View {
    ///             Circle()
    ///                 .fill(Color.green)
    ///                 .frame(width: 25, height: 25, alignment: .center)
    ///         }
    ///     }
    ///
    ///     struct Contrast: View {
    ///         var body: some View {
    ///             HStack {
    ///                 ForEach(-1..<6) {
    ///                     Color.red.frame(width: 50, height: 50, alignment: .center)
    ///                         .overlay(CircleView(), alignment: .center)
    ///                         .contrast(Double($0) * 0.2)
    ///                         .overlay(Text("\(Double($0) * 0.2 * 100, specifier: "%.0f")%")
    ///                                      .font(.callout),
    ///                                  alignment: .bottom)
    ///                         .border(Color.gray)
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter amount: The intensity of color contrast to apply. negative
    ///   values invert colors in addition to applying contrast.
    ///
    /// - Returns: A view that applies color contrast to this view.
    @inlinable public func contrast(_ amount: Double) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that adds a grayscale effect to this view.
    ///
    /// A grayscale effect reduces the intensity of colors in this view.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             ForEach(0..<6) { idx in
    ///                 RoundedRectangle(cornerRadius: 10.0)
    ///                     .fill(Color.yellow)
    ///                     .greyscale(Double(idx)*0.2 - 0.01)
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter amount: The intensity of grayscale to apply from 0.0 to less
    ///   than 1.0. Values closer to 0.0 are more colorful, and values closer to
    ///   1.0 are less colorful.
    ///
    /// - Returns: A view that adds a grayscale effect to this view.
    @inlinable public func grayscale(_ amount: Double) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Applies a hue rotation effect.
    ///
    /// Use hue rotation effect to shift all of the colors in a view according
    /// to the angle you specify.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             ForEach(0..<6) { idx in
    ///                 RoundedRectangle(cornerRadius: 10.0)
    ///                     .fill(Color.yellow)
    ///                     .hueRotation(Angle(degrees: Double(idx)*360/12))
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter angle: The hue rotation angle to apply to the colors in this
    ///   view.
    ///
    /// - Returns: A view that applies a hue rotation effect to this view.
    @inlinable public func hueRotation(_ angle: Angle) -> some View { }

}

@available(iOS 13.0, macOS 11.0, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the preferred color scheme for this presentation.
    ///
    /// The color scheme applies to the nearest enclosing presentation, such as
    /// a popover or window. Views may read the color scheme using the
    /// `colorScheme` environment value.
    ///
    /// In the example below the presentation containing the `VStack` has its
    /// color scheme set to `ColorScheme/dark`:
    ///
    /// ```
    /// struct DarkView: View {
    ///     VStack {
    ///         Button(action: { }) {
    ///             Text(" Button")
    ///         }
    ///         HStack {
    ///             Text("Slider").accentColor(Color.green)
    ///             Slider(value: $sliderValue, in: -100...100, step: 0.1)
    ///         }
    ///     }
    ///     .preferredColorScheme(.dark)
    /// }
    /// ```
    ///
    /// - Parameter colorScheme: The color scheme for this view.
    ///
    /// - Returns: A view that wraps this view and sets the color scheme.
    @inlinable public func preferredColorScheme(_ colorScheme: ColorScheme?) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that adds a luminance to alpha effect to this view.
    ///
    /// The `luminanceToAlpha()` modifier creates a semitransparent mask out of
    /// the view to which you you apply. The dark regions in a view become
    /// transparent, and the bright regions become opaque black. Medium
    /// brightness regions become a partially opaque gray color.
    ///
    /// The example below shows two views: the first is a red square with an
    /// overlaid green circle; the second is a copy of the first view with where
    /// the `luminanceToAlpha()` modifier's masking operation transforms the
    /// view's brightness levels into an equivalent grayscale version of the
    /// first view:
    ///
    ///     struct LuminanceCircleView: View {
    ///         var body: some View {
    ///             Circle()
    ///                 .fill(Color.green)
    ///                 .frame(width: 40, height: 40, alignment: .center)
    ///         }
    ///     }
    ///
    ///     struct LuminanceToAlpha: View {
    ///         var body: some View {
    ///             HStack {
    ///                 Color.red.frame(width: 60, height: 60, alignment: .center)
    ///                     .overlay(LuminanceCircleView(), alignment: .center)
    ///                     .padding()
    ///
    ///                 Color.red.frame(width: 60, height: 60, alignment: .center)
    ///                     .overlay(LuminanceCircleView(), alignment: .center)
    ///                     .luminanceToAlpha()
    ///             }
    ///         }
    ///     }
    ///
    /// - Returns: A view that applies a luminance to alpha effect to this view.
    @inlinable public func luminanceToAlpha() -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that adjusts the color saturation of the view.
    ///
    /// Use color saturation to increase or decrease the intensity of colors in
    /// a view.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             ForEach(0..<6) { idx in
    ///                 RoundedRectangle(cornerRadius: 10.0)
    ///                     .fill(Color.yellow)
    ///                     .saturation(Double(idx)*0.2)
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - SeeAlso: `View/contrast(_:)`
    /// - Parameter amount: The amount of saturation to apply to this view.
    ///
    /// - Returns: A view that adjusts the saturation of this view.
    @inlinable public func saturation(_ amount: Double) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that adds a transition to this view when it appears and disappears.
    ///
    /// Use this modifier to apply an effect to a view, such as a fade, scale, or slide
    /// when the view appears and disappears from the screen.
    ///
    /// The transition is only one part of the equation - a timer curve (animation)
    /// must also be specified. There are two ways to specify the associated animation:
    /// 1. With ``View/animation(_:)``.
    /// 2. Explicitly, using ``withAnimation(_:_:)``.
    ///
    /// See ``AnyTransition`` for more on how to create a transition.
    ///
    /// ### Using animation(_:)
    ///
    /// ```
    /// struct ImplicitTransitionView: View {
    ///     @State var showBanana = false
    ///
    ///     var body: some View {
    ///         Button("Toggle") { showBanana.toggle() }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .animation(.easeInOut)
    ///                 .transition(.slide)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Using withAnimation(_:_:)
    ///
    /// ![Slide transition](with-animation-2.gif)
    ///
    /// ```
    /// struct ExplicitTransitionView: View {
    ///     @State var showBanana = false
    ///
    ///     var body: some View {
    ///         Button("Toggle") {
    ///             withAnimation(.easeInOut) { show.toggle() }
    ///         }
    ///         if showBanana {
    ///             Text("🍌")
    ///                 .transition(.slide)
    ///         }
    ///     }
    /// }
    /// ```
    @inlinable public func transition(_ t: AnyTransition) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the transparency of a view.
    ///
    /// Apply opacity to reveal views that are behind another view or to
    /// de-emphasize a view.
    ///
    /// When applying the `opacity(_:)` modifier to a view that has already had
    /// its opacity transformed, the modifier multiplies the effect of the
    /// underlying opacity transformation.
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             ForEach(0..<6) { idx in
    ///                 RoundedRectangle(cornerRadius: 10.0)
    ///                     .fill(Color.yellow)
    ///                     .opacity(Double(idx)*0.2)
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter opacity: A value between 0 (fully transparent) and 1 (fully
    ///   opaque).
    ///
    /// - Returns: A view that sets the transparency of this view.
    @inlinable public func opacity(_ opacity: Double) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that applies the given animation to this view when the specified value
    /// changes.
    ///
    /// Use this modifier to when you only want to animate a particular @``State``
    /// property instead of animating all of them.
    ///
    /// To animate all properties associated with a ``View``, use
    /// ``View/animation(_:)`` instead.
    ///
    /// ```
    /// struct MovementView: View {
    ///     @State var moveFlag = false
    ///     @State var transportFlag = false
    ///
    ///     var body: some View {
    ///         Button("Move the banana") { moveFlag.toggle() }
    ///         Button("Transport the banana") { transportFlag.toggle() }
    ///         Text("🍌")
    ///             .offset(x: moveFlag ? 0 : 50)
    ///             .offset(x: transportFlag ? 0 : 50)
    ///             .animation(.easeInOut, value: moveFlag)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - animation: The animation to apply. If `animation` is `nil`, the view
    ///     doesn't animate.
    ///   - value: A value to monitor for changes.
    ///
    /// - Returns: A view that applies `animation` to this view whenever `value`
    ///   changes.
    @inlinable public func animation<V>(_ animation: Animation?, value: V) -> some View where V : Equatable { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the unique tag value of this view.
    ///
    /// Use `tag(_:)` to differentiate between a number of views for the purpose
    /// of selecting controls like pickers and lists. Tag values can be of any
    /// type that conforms to the <doc://com.apple.documentation/documentation/Swift/Hashable>
    /// protocol.
    ///
    /// [[tabview-tag]]
    ///
    /// In the example below, the `ForEach` loop in the `Picker` view
    /// builder iterates over the `Flavor` enumeration. It extracts the text raw
    /// value of each enumeration element for use as the row item label and uses
    /// the enumeration item itself as input to the `tag(_:)` modifier.
    /// The tag identifier can be any value that conforms to the
    /// <doc://com.apple.documentation/documentation/Swift/Hashable> protocol:
    ///
    ///     struct FlavorPicker: View {
    ///         enum Flavor: String, CaseIterable, Identifiable {
    ///             var id: String { self.rawValue }
    ///             case vanilla, chocolate, strawberry
    ///         }
    ///
    ///         @State private var selectedFlavor: Flavor? = nil
    ///         var body: some View {
    ///             Picker("Flavor", selection: $selectedFlavor) {
    ///                 ForEach(Flavor.allCases) {
    ///                     Text($0.rawValue).tag($0)
    ///                 }
    ///             }
    ///         }
    ///     }
    ///
    /// - SeeAlso: `List`, `Picker`, `Hashable`
    /// - Parameter tag: A <doc://com.apple.documentation/documentation/Swift/Hashable> value
    ///   to use as the view's tag.
    ///
    /// - Returns: A view with the specified tag set.
    @inlinable public func tag<V>(_ tag: V) -> some View where V : Hashable { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the blend mode for compositing this view with overlapping views.
    ///
    /// Use `blendMode(_:)` to combine overlapping views and use a different
    /// visual effect to produce the result. The `BlendMode` enumeration
    /// defines many possible effects.
    ///
    /// Test `blendMode(_:)` with images. To use the following example, drag in the following two photos and label them "ocean" and "space".
    ///
    /// ![New York](ocean.jpg)
    ///
    /// ![Space](space.jpg)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Image("ocean")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///
    ///             Image("space")
    ///                 .resizable()
    ///                 .scaledToFit()
    ///                 .blendMode(.softLight)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter blendMode: The `BlendMode` for compositing this view.
    ///
    /// - Returns: A view that applies `blendMode` to this view.
    @inlinable public func blendMode(_ blendMode: BlendMode) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Places a custom background view behind a list row item.
    ///
    /// Use `listRowBackground(_:)` to place a custom background view behind a
    /// list row item.
    ///
    /// [[list-row-background]]
    ///
    /// In the example below, the `Flavor` enumeration provides content for list
    /// items. The SwiftUI `List` builder iterates over the `Flavor`
    /// enumeration and extracts the raw value of each of its elements using the
    /// resulting text to create each list row item. After the list builder
    /// finishes, the `listRowBackground(_:)` modifier places the view you
    /// supply behind each of the list row items.
    ///
    ///     struct ListRowBackground: View {
    ///
    ///         enum Flavor: String, CaseIterable, Identifiable {
    ///             var id: String { self.rawValue }
    ///             case vanilla, chocolate, strawberry
    ///         }
    ///
    ///         var body: some View {
    ///             List(Flavor.allCases, id: \.self) {
    ///                 Text($0.rawValue)
    ///             }
    ///             .listRowBackground(Image(systemName: "sparkles"))
    ///         }
    ///     }
    ///
    /// - Parameter view: The `View` to use as the background behind the list
    ///   row view.
    ///
    /// - Returns: A list row view with `view` as its background view.
    @inlinable public func listRowBackground<V>(_ view: V?) -> some View where V : View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modiier that composites this view's contents into an offscreen image before final
    /// display.
    ///
    /// The `drawingGroup(opaque:colorMode:)` modifier flattens a subtree of
    /// views into a single view before rendering it.
    ///
    /// In the example below, the contents of the view are composited to a
    /// single bitmap; the bitmap is then displayed in place of the view:
    ///
    /// ```
    /// struct DrawingGroupView: View {
    ///     var body: some View {
    ///         VStack {
    ///             ZStack {
    ///                 Text("DrawingGroup")
    ///                     .foregroundColor(.black)
    ///                     .padding(20)
    ///                     .background(Color.red)
    ///                 Text("DrawingGroup")
    ///                     .blur(radius: 2)
    ///             }
    ///             .font(.largeTitle)
    ///             .compositingGroup()
    ///             .opacity(1.0)
    ///         }
    ///         .background(Color.white)
    ///         .drawingGroup()
    ///      }
    ///  }
    ///  ```
    ///
    /// - Note: Views backed by native platform views may not render into the
    ///   image. Instead, they log a warning and display a placeholder image to
    ///   highlight the error.
    ///
    /// - Parameters:
    ///   - opaque: A Boolean value that indicates whether the image is opaque.
    ///     The default is `false`; if set to `true`, the alpha channel of the
    ///     image must be `1`.
    ///   - colorMode: One of the working color space and storage formats
    ///     defined in `ColorRenderingMode`. The default is
    ///     `ColorRenderingMode/nonLinear`.
    ///
    /// - Returns: A view that composites this view's contents into an offscreen
    ///   image before display.
    public func drawingGroup(opaque: Bool = false, colorMode: ColorRenderingMode = .nonLinear) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that wraps this view in a compositing group.
    ///
    /// A compositing group makes compositing effects in this view's ancestor
    /// views, such as opacity and the blend mode, take effect before this view
    /// is rendered.
    ///
    /// Use `compositingGroup()` to apply effects to a parent view before
    /// applying effects to this view.
    ///
    /// In the example below the `compositingGroup()` modifier separates the
    /// application of effects into stages. It applies the `View/opacity(_:)`
    /// effect to the VStack before the `blur(radius:)` effect is applied to the
    /// views inside the enclosed `ZStack`. This limits the scope of the
    /// opacity change to the outermost view.
    ///
    /// ```
    /// struct CompositingGroup {
    ///     var body: some View {
    ///         VStack {
    ///             ZStack {
    ///                 Text("CompositingGroup")
    ///                     .foregroundColor(.black)
    ///                     .padding(20)
    ///                     .background(Color.red)
    ///                 Text("CompositingGroup")
    ///                     .blur(radius: 2)
    ///             }
    ///             .font(.largeTitle)
    ///             .compositingGroup()
    ///             .opacity(0.9)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Returns: A view that wraps this view in a compositing group.
    @inlinable public func compositingGroup() -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the device for a preview.
    ///
    /// If you set the preview device to `nil`, as it is by default, Xcode
    /// automatically chooses an appropriate device based on your target.
    ///
    /// You can get a list of supported values, like "iPhone 11",
    /// "iPad Pro (11-inch)", and "Apple Watch Series 5 - 44mm" by using the
    /// `xcrun` command in the Terminal app:
    ///
    ///     % xcrun simctl list devicetypes
    ///
    /// Additionally, the following values are supported for macOS platform
    /// development:
    ///  - "Mac"
    ///  - "Mac Catalyst"
    ///
    /// See ``PreviewDevice`` for the full list of supported devices.
    ///
    /// The following example changes the device preview to iPhone SE
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         Text("Preview on iPhone SE 📱")
    ///     }
    /// }
    ///
    /// struct ContentView_Previews: PreviewProvider {
    ///     static var previews: some View {
    ///         ContentView()
    ///             .previewDevice(rawValue: "iPhone SE")
    ///     }
    /// }
    /// ```
    ///
    ///- Parameter value: The device to display the preview on.
    @inlinable public func previewDevice(_ value: PreviewDevice?) -> some View { }


    /// A view modifier that sets the size for a Xcode preview.
    ///
    /// There are 3 different Xcode ``PreviewLayout`` types:
    /// 1. ``PreviewLayout/device``:  Adds the view to the center of the specified preview device.
    /// 2. ``PreviewLayout/sizeThatFits``: Fits a container around the previewed view.
    /// 3.  ``PreviewLayout/fixed(width:height:)``: Adds the view to a fixed size container.
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         Text("➡️This box fits me snugly⬅️")
    ///     }
    /// }
    ///
    /// struct ContentView_Previews: PreviewProvider {
    ///     static var previews: some View {
    ///         ContentView()
    ///             .previewLayout(.sizeThatFits)
    ///     }
    /// }
    /// ```
    ///
    /// The default value is `PreviewLayout/device`.
    @inlinable public func previewLayout(_ value: PreviewLayout) -> some View { }


    /// A view modifier that sets a custom name in the Xcode preview.
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         Text("My name is 🍌")
    ///     }
    /// }
    ///
    /// struct ContentView_Previews: PreviewProvider {
    ///     static var previews: some View {
    ///         ContentView()
    ///             .previewDisplayName("🍌")
    ///     }
    /// }
    /// ```
    ///
    /// The default value is `nil`.
    ///
    /// - Parameter value: The preview name to display.
    @inlinable public func previewDisplayName(_ value: String?) -> some View { }


    /// A view modifier that declares a context for the Xcode preview.
    ///
    /// There is currently only one type of preview context:
    /// ``WidgetPreviewContext``. Its initializer takes a ``WidgetFamily``.
    ///
    /// There are 3 types of `WidgetFamily` variables:
    /// 1. `systemSmall`
    /// 2. `systemMedium`
    /// 3. `systemLarge`
    ///
    /// The example below is pulled from Apple's widget boilerplate.
    /// To pull this up yourself, go to *File > New > Target* and search
    /// for "WidgetExtension". This target is named "PreviewContextTest"
    ///
    /// ```
    /// struct PreviewContextTest_Previews: PreviewProvider {
    ///     static var previews: some View {
    ///         PreviewContextTestEntryView(entry: SimpleEntry(date: Date()))
    ///             .previewContext(WidgetPreviewContext(family: .systemSmall))
    ///     }
    /// }
    /// ```
    ///
    /// For more on getting started with widgets, check out
    /// [this tutorial](https://www.raywenderlich.com/11303363-getting-started-with-widgets).
    ///
    /// - Parameter value: The context for the preview; the default is `nil`.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    @inlinable public func previewContext<C>(_ value: C) -> some View where C : PreviewContext { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

	/// A view modifier that sets the value of a preference for a specified anchor.
    ///
    /// Anchor preferences are a type of view preference. Anchor
    /// preferences primarily pass layout data to the parent view, things
    /// like bounds and coordinates.
    ///
    /// If you are not familiar with view preferences, see
    /// [this article](https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/)
    /// for more.
    ///
    /// For more info on anchor preferences specifically, see
    /// [this article](https://swiftwithmajid.com/2020/03/18/anchor-preferences-in-swiftui/)
    ///
    /// ```
    /// struct BoundsPreferenceKey: PreferenceKey {
    ///     typealias Value = Anchor<CGRect>?
    ///
    ///     static var defaultValue: Value = nil
    ///
    ///     static func reduce(value: inout Value, nextValue: () -> Value) {
    ///         value = nextValue()
    ///     }
    /// }
    ///
    /// struct ContentView: View {
    ///     var body: some View {
    ///         Text("I have a box 📦 around me")
    ///             .anchorPreference(key: BoundsPreferenceKey.self, value: .bounds) { $0 }
    ///         .overlayPreferenceValue(BoundsPreferenceKey.self) { preferences in
    ///             GeometryReader { geometry in
    ///                 preferences.map {
    ///                     Rectangle()
    ///                         .stroke()
    ///                         .frame(
    ///                             width: geometry[$0].width,
    ///                             height: geometry[$0].height
    ///                         )
    ///                         .offset(
    ///                             x: geometry[$0].minX,
    ///                             y: geometry[$0].minY
    ///                         )
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
	///
	/// - Parameters:
	///   - key: The key type of the preference key.
	///   - value: The anchor you provide to transform closure.
	///   - transform: A closure that takes an existing preference value and anchor value,
	///   and can update the existing preference with the given value.
    @inlinable public func anchorPreference<A, K>(key _: K.Type = K.self, value: Anchor<A>.Source, transform: @escaping (Anchor<A>) -> K.Value) -> some View where K : PreferenceKey { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets a clipping shape for this view.
    ///
    /// Use `clipShape(_:style:)` to clip the view to the provided shape. By
    /// applying a clipping shape to a view, you preserve the parts of the view
    /// covered by the shape, while eliminating other parts of the view. The
    /// clipping shape itself isn't visible.
    ///
    /// For example, this code applies a circular clipping shape to a `Text`
    /// view:
    ///
    /// ```
    /// struct ClippedShapeView: View {
    ///     var body: some View {
    ///         Text("Clipped text in a circle")
    ///             .frame(width: 175, height: 100)
    ///             .foregroundColor(Color.white)
    ///             .background(Color.black)
    ///             .clipShape(Circle())
    ///     }
    /// }
    /// ```
    ///
    /// The resulting view shows only the portion of the text that lies within
    /// the bounds of the circle.
    ///
    /// - Parameters:
    ///   - shape: The clipping shape to use for this view. The `shape` fills
    ///     the view's frame, while maintaining its aspect ratio.
    ///   - style: The fill style to use when rasterizing `shape`.
    ///
    /// - Returns: A view that clips this view to `shape`, using `style` to
    ///   define the shape's rasterization.
    @inlinable public func clipShape<S>(_ shape: S, style: FillStyle = FillStyle()) -> some View where S : Shape { }


    /// A view modifier that clips this view to its bounding rectangular frame.
    ///
    /// Use the `clipped(antialiased:)` modifier to hide any content that
    /// extends beyond the layout bounds of the shape.
    ///
    /// By default, a view's bounding frame is used only for layout, so any
    /// content that extends beyond the edges of the frame is still visible.
    ///
    /// ```
    /// struct CippedView: View {
    ///     var body: some View {
    ///         Text("This long text string is clipped")
    ///             .fixedSize()
    ///             .frame(width: 175, height: 100)
    ///             .clipped()
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter antialiased: A Boolean value that indicates whether the
    ///   rendering system applies smoothing to the edges of the clipping
    ///   rectangle.
    ///
    /// - Returns: A view that clips this view to its bounding frame.
    @inlinable public func clipped(antialiased: Bool = false) -> some View { }


    /// A view modifier that clips this view to its bounding frame,
    /// with the specified corner radius.
    ///
    /// By default, a view's bounding frame only affects its layout, so any
    /// content that extends beyond the edges of the frame remains visible. Use
    /// `cornerRadius(_:antialiased:)` to hide any content that extends beyond
    /// these edges while applying a corner radius.
    ///
    /// The following code applies a corner radius of 25 to a text view:
    ///
    /// ```
    /// struct CornerRadiusView: View {
    ///     var body: some View {
    ///         Text("Rounded Corners")
    ///             .frame(width: 175, height: 75)
    ///             .foregroundColor(Color.white)
    ///             .background(Color.black)
    ///             .cornerRadius(25)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter antialiased: A Boolean value that indicates whether the
    ///   rendering system applies smoothing to the edges of the clipping
    ///   rectangle.
    ///
    /// - Returns: A view that clips this view to its bounding frame with the
    ///   specified corner radius.
    @inlinable public func cornerRadius(_ radius: CGFloat, antialiased: Bool = true) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that adds a shadow to this view.
    ///
    /// Shadow has four possible arguments.
    ///
    /// Create a shadow with just a radius:
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 10)
    ///             .fill(Color.yellow)
    ///             .shadow(radius: 10)
    ///             .padding()
    ///     }
    /// }
    /// ```
    ///
    /// Modify the color:
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 10)
    ///             .fill(Color.yellow)
    ///             .shadow(color: .red, radius: 10)
    ///             .padding()
    ///     }
    /// }
    /// ```
    ///
    /// Modify the x offset:
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 10)
    ///             .fill(Color.yellow)
    ///             .shadow(color: .red, radius: 10, x: 20)
    ///             .padding()
    ///     }
    /// }
    /// ```
    ///
    /// Modify the x & y offset:
    ///
    /// ```
    /// struct ContentView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 10)
    ///             .fill(Color.yellow)
    ///             .shadow(color: .red, radius: 10, x: 20, y: 20)
    ///             .padding()
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - color: The shadow's color.
    ///   - radius: The shadow's size.
    ///   - x: A horizontal offset you use to position the shadow relative to
    ///     this view.
    ///   - y: A vertical offset you use to position the shadow relative to this
    ///     view.
    ///
    /// - Returns: A view that adds a shadow to this view.
    @inlinable public func shadow(color: Color = Color(.sRGBLinear, white: 0, opacity: 0.33), radius: CGFloat, x: CGFloat = 0, y: CGFloat = 0) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the style for toggles within this view.
    ///
    /// To set a specific style for all toggle instances within a view, use the
    /// `View/toggleStyle(_:)` modifier, as follows:
    ///
    /// ```
    /// struct StyledToggleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Toggle("Vibrate on Ring", isOn: $vibrateOnRing)
    ///             Toggle("Vibrate on Silent", isOn: $vibrateOnSilent)
    ///         }
    ///         .toggleStyle(SwitchToggleStyle())
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter style: The style to set.
    public func toggleStyle<S>(_ style: S) -> some View where S : ToggleStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets this view's color scheme.
    ///
    /// **This has been deprecated. Use ``View/preferredColorScheme(_:)``
    /// instead.**
    ///
    /// - Parameter colorScheme: The color scheme for this view.
    ///
    /// - Returns: A view that sets this view's color scheme.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "preferredColorScheme(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "preferredColorScheme(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "preferredColorScheme(_:)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, renamed: "preferredColorScheme(_:)")
    @inlinable public func colorScheme(_ colorScheme: ColorScheme) -> some View { }


    /// A view modifier that scales images within the view according to one of the relative sizes
    /// available including small, medium, and large images sizes.
    ///
    /// The example below shows the relative scaling effect. The system renders
    /// the image at a relative size based on the available space and
    /// configuration options of the image it is scaling.
    ///
    /// ```
    /// struct ImageScaleView: View {
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 Image(systemName: "heart.fill")
    ///                     .imageScale(.small)
    ///                 Text("Small")
    ///             }
    ///             HStack {
    ///                 Image(systemName: "heart.fill")
    ///                     .imageScale(.medium)
    ///                 Text("Medium")
    ///             }
    ///
    ///             HStack {
    ///                 Image(systemName: "heart.fill")
    ///                     .imageScale(.large)
    ///                 Text("Large")
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter scale: One of the relative sizes provided by the image scale
    ///   enumeration.
    @available(macOS 11.0, *)
    @inlinable public func imageScale(_ scale: Image.Scale) -> some View { }


    /// A view modifier that sets the default font for text in this view.
    ///
    /// Use `font(_:)` to apply a specific font to all of the text in a view.
    ///
    /// The example below shows the effects of applying fonts to individual
    /// views and to view hierarchies. Font information flows down the view
    /// hierarchy as part of the environment, and remains in effect unless
    /// overridden at the level of an individual view or view container.
    ///
    /// Here, the outermost `VStack` applies a 16-point system font as a
    /// default font to views contained in that `VStack`. Inside that stack,
    /// the example applies a `Font/largeTitle` font to just the first text
    /// view; this explicitly overrides the default. The remaining stack and the
    /// views contained with it continue to use the 16-point system font set by
    /// their containing view:
    ///
    /// ```
    /// struct FontView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Text("Font applied to a text view.")
    ///                 .font(.largeTitle)
    ///
    ///             VStack {
    ///                 Text("These 2 text views have the same font")
    ///                 Text("applied to their parent hierarchy")
    ///             }
    ///         }
    ///         .font(.system(size: 16, weight: .light, design: .default))
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter font: The default font to use in this view.
    ///
    /// - Returns: A view with the default font set to the value you supply.
    @inlinable public func font(_ font: Font?) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that positions this view within an invisible frame
    /// with the specified size.
    ///
    /// Use this method to specify a fixed size for a view's width, height, or
    /// both. If you only specify one of the dimensions, the resulting view
    /// assumes this view's sizing behavior in the other dimension.
    ///
    /// For example, the following code lays out an ellipse in a fixed 200 by
    /// 100 frame. Because a shape always occupies the space offered to it by
    /// the layout system, the first ellipse is 200x100 points. The second
    /// ellipse is laid out in a frame with only a fixed height, so it occupies
    /// that height, and whatever width the layout system offers to its parent.
    ///
    /// ```
    /// struct EllipseFrameView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Ellipse()
    ///                 .fill(Color.purple)
    ///                 .frame(width: 200, height: 100)
    ///             Ellipse()
    ///                 .fill(Color.blue)
    ///                 .frame(height: 100)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// `The alignment` parameter specifies this view's alignment within the
    /// frame.
    ///
    /// ```
    /// struct TextFrameView
    ///     var body: some View {
    ///         Text("Hello world!")
    ///             .frame(width: 200, height: 30, alignment: .topLeading)
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// In the example above, the text is positioned at the top, leading corner
    /// of the frame. If the text is taller than the frame, its bounds may
    /// extend beyond the bottom of the frame's bounds.
    ///
    /// - Parameters:
    ///   - width: A fixed width for the resulting view. If `width` is `nil`,
    ///     the resulting view assumes this view's sizing behavior.
    ///   - height: A fixed height for the resulting view. If `height` is `nil`,
    ///     the resulting view assumes this view's sizing behavior.
    ///   - alignment: The alignment of this view inside the resulting view.
    ///     `alignment` applies if this view is smaller than the size given by
    ///     the resulting frame.
    ///
    /// - Returns: A view with fixed dimensions of `width` and `height`, for the
    ///   parameters that are non-`nil`.
    @inlinable public func frame(width: CGFloat? = nil, height: CGFloat? = nil, alignment: Alignment = .center) -> some View { }


    /// Positions this view within an invisible frame.
    ///
    /// **This does nothing and was only implemented so people who
    /// don't know what they're doing don't have their programs
    /// always breaking.**
    ///
    /// Use `SwiftUI/View/frame(width:height:alignment:)` or
    /// `SwiftUI/View/frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:)`
    /// instead.
    @available(*, deprecated, message: "Please pass one or more parameters.")
    @inlinable public func frame() -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that positions this view within an invisible frame
    /// having the specified size constraints.
    ///
    /// Always specify at least one size characteristic when calling this
    /// method. Pass `nil` or leave out a characteristic to indicate that the
    /// frame should adopt this view's sizing behavior, constrained by the other
    /// non-`nil` arguments.
    ///
    /// The size proposed to this view is the size proposed to the frame,
    /// limited by any constraints specified, and with any ideal dimensions
    /// specified replacing any corresponding unspecified dimensions in the
    /// proposal.
    ///
    /// If no minimum or maximum constraint is specified in a given dimension,
    /// the frame adopts the sizing behavior of its child in that dimension. If
    /// both constraints are specified in a dimension, the frame unconditionally
    /// adopts the size proposed for it, clamped to the constraints. Otherwise,
    /// the size of the frame in either dimension is:
    ///
    /// - If a minimum constraint is specified and the size proposed for the
    ///   frame by the parent is less than the size of this view, the proposed
    ///   size, clamped to that minimum.
    /// - If a maximum constraint is specified and the size proposed for the
    ///   frame by the parent is greater than the size of this view, the
    ///   proposed size, clamped to that maximum.
    /// - Otherwise, the size of this view.
    ///
    /// The ideal width and height parameters can be enforced using the
    /// ``View/fixedSize()`` modifier.
    ///
    /// Play with the numbers in the following example to see how then
    /// child view responds
    ///
    /// ```
    /// struct CustomFrameView: View {
    ///     var body: some View {
    ///         ZStack {
    ///             Rectangle()
    ///                 .frame(minWidth: 50.0, idealWidth: 100.0, maxWidth: 200.0,
    ///                        minHeight: 50.0, idealHeight: 100.0, maxHeight: 200.0)
    ///         }
    ///         .frame(width: 150.0, height: 150.0)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - minWidth: The minimum width of the resulting frame.
    ///   - idealWidth: The ideal width of the resulting frame.
    ///   - maxWidth: The maximum width of the resulting frame.
    ///   - minHeight: The minimum height of the resulting frame.
    ///   - idealHeight: The ideal height of the resulting frame.
    ///   - maxHeight: The maximum height of the resulting frame.
    ///   - alignment: The alignment of this view inside the resulting frame.
    ///     Note that most alignment values have no apparent effect when the
    ///     size of the frame happens to match that of this view.
    ///
    /// - Returns: A view with flexible dimensions given by the call's non-`nil`
    ///   parameters.
    @inlinable public func frame(minWidth: CGFloat? = nil, idealWidth: CGFloat? = nil, maxWidth: CGFloat? = nil, minHeight: CGFloat? = nil, idealHeight: CGFloat? = nil, maxHeight: CGFloat? = nil, alignment: Alignment = .center) -> some View { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that sets the style for group boxes within this view.
    ///
    /// Use this method to change the style of your ``GroupBox``.
    ///
    /// There is currently one pre-built style, called
    /// ``DefaultGroupBoxStyle``, and the protocol
    /// ``GroupBoxStyle`` lets you creat your own custom styles.
    ///
    /// See ``GroupBoxStyle`` for info on creating custom group box styles.
    ///
    ///
    ///
    /// - Parameter style: The style to apply to boxes within this view.
    public func groupBoxStyle<S>(_ style: S) -> some View where S : GroupBoxStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
extension View {

    /// A view modifier that sets the tab bar item associated with this view.
    ///
    /// Use `tabItem(_:)` to configure a view as a tab bar item in a
    /// `TabView`. The example below adds two views as tabs in a `TabView`:
    ///
    ///     struct View1: View {
    ///         var body: some View {
    ///             Text("View 1")
    ///         }
    ///     }
    ///
    ///     struct View2: View {
    ///         var body: some View {
    ///             Text("View 2")
    ///         }
    ///     }
    ///
    ///     struct TabItem: View {
    ///         var body: some View {
    ///             TabView {
    ///                 View1()
    ///                     .tabItem {
    ///                         Image(systemName: "list.dash")
    ///                         Text("Menu")
    ///                     }
    ///
    ///                 View2()
    ///                     .tabItem {
    ///                         Image(systemName: "square.and.pencil")
    ///                         Text("Order")
    ///                     }
    ///             }
    ///         }
    ///     }
    ///
    /// [[tabview-tabitem]]
    ///
    /// - Parameter label: The tab bar item to associate with this view.
    public func tabItem<V>(@ViewBuilder _ label: () -> V) -> some View where V : View { }

}

@available(iOS 13.0, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that presents a popover using the given item as a data source for the
    /// popover's content.
    ///
    /// If your popover doesn't require a passed-in parameter, use
    /// ``View/popover(isPresented:attachmentAnchor:arrowEdge:content:)``
    /// instead.
    ///
    /// On iPhone, this modifier is very similar to
    /// ``View/sheet(item:onDismiss:content:)``.
    /// However, on iPad, these two modifiers are different.
    ///
    /// ```
    /// struct Item: Identifiable {
    ///     let id = UUID()
    ///     let text: String
    /// }
    ///
    /// struct BaseView: View {
    ///     @State private var item: Item? = nil
    ///
    ///     var body: some View {
    ///         VStack {
    ///             Button("🍌 Popover") {
    ///                 item = Item(text: "🍌🍌")
    ///             }
    ///             Button("🍑 Popover") {
    ///                 item = Item(text: "🍑🍑")
    ///             }
    ///         }
    ///         .popover(item: $item,
    ///                  attachmentAnchor: .rect(.bounds),
    ///                  arrowEdge: .leading,
    ///                  content: { ExamplePopover(item: $0) })
    ///     }
    /// }
    ///
    /// struct ExamplePopover: View {
    ///     let item: item
    ///     @Environment(\.presentationMode) var presentationMode
    ///
    ///     var body: some View {
    ///         VStack {
    ///             Text(item.text)
    ///             Button("Tap to dismiss") {
    ///                 presentationMode.wrappedValue.dismiss()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the popover.
    ///     When representing a non-`nil` item, the system uses `content` to
    ///     create a popover representation of the item.
    ///     If the identity changes, the system dismisses a
    ///     currently-presented popover and replace it by a new popover.
    ///   - attachmentAnchor: The positioning anchor which defines where the
    ///     popover is attached.
    ///   - arrowEdge: The edge of the `attachmentAnchor` where the popover's
    ///     arrow is located.
    ///   - content: A closure returning the content of the popover.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func popover<Item, Content>(item: Binding<Item?>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge = .top, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View { }


    /// Presents a popover when a given condition is true.
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State private var showPopover = FalseContent
    ///
    ///     var body: some View {
    ///         Button("Open sesame 📬") { showPopover = true }
    ///             .popover(isPresented: $showPopover,
    ///                      attachmentAnchor: .rect(.bounds),
    ///                      arrowEdge: .leading,
    ///                      content: { ExamplePopover() })
    ///     }
    /// }
    ///
    /// struct ExamplePopover: View {
    ///     @Environment(\.presentationMode) var presentationMode
    ///
    ///     var body: some View { x
    ///         Button("CLOSE 📪") {
    ///             presentationMode.wrappedValue.dismiss()
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the popover is presented.
    ///   - attachmentAnchor: The positioning anchor which defines where the
    ///     popover is attached.
    ///   - arrowEdge: The edge of the `attachmentAnchor` where the popover's
    ///     arrow is located.
    ///   - content: A closure returning the content of the popover.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func popover<Content>(isPresented: Binding<Bool>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge = .top, @ViewBuilder content: @escaping () -> Content) -> some View where Content : View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the style for labels within this view.
    ///
    /// Use this modifier to set a specific style for all labels within a view:
    ///
    ///     VStack {
    ///         Label("Fire", systemImage: "flame.fill")
    ///         Label("Lightning", systemImage: "bolt.fill")
    ///     }
    ///     .labelStyle(MyCustomLabelStyle())
    ///
    public func labelStyle<S>(_ style: S) -> some View where S : LabelStyle { }

}

@available(iOS 13.4, macOS 10.15, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that adds an action to perform when the user moves the pointer over or away
    /// from the view's frame.
    ///
    /// Calling this method defines a region for detecting pointer movement with
    /// the size and position of this view.
    ///
    /// ```
    /// struct HoverView: View {
    ///     @State private var isHovering = false
    ///
    ///     var body: some View {
    ///         Text(isHovering ? "HOVERING 🛸" : "👉 Come here 👈")
    ///             .onHover { hovering in
    ///                 isHovering = hovering
    ///             }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter action: The action to perform whenever the pointer enters or
    ///   exits this view's frame. If the pointer is in the view's frame, the
    ///   `action` closure passes `true` as a parameter; otherwise, `false`.
    ///
    /// - Returns: A view that triggers `action` when the pointer enters or
    ///   exits this view's frame.
    @inlinable public func onHover(perform action: @escaping (Bool) -> Void) -> some View { }

}

@available(iOS 13.4, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that adds a pointer hover effect to the view.
    ///
    /// Use this modifier on iPadOS only.
    ///
    /// - Note: The system may fall back to a more appropriate effect.
    @available(iOS 13.4, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func hoverEffect(_ effect: HoverEffect = .automatic) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that hides this view.
    ///
    /// Hidden views are invisible and can't receive or respond to interactions.
    ///
    /// ```
    /// struct PartiallyHiddenView: View {
    ///     var body: some View {
    ///         Text("The invisible man hides below")
    ///         Text("🧔")
    ///             .hidden()
    ///     }
    /// }
    /// ```
    ///
    /// - Returns: A hidden view.
    @inlinable public func hidden() -> some View { }

}

extension View {

    /// A view modifier that sets the keyboard type for this view.
    ///
    /// Use `keyboardType(_:)` to specify the keyboard type to use for text
    /// entry. A number of different keyboard types are available to meet
    /// specialized input needs, such as entering email addresses or phone
    /// numbers.
    ///
    /// The example below presents a `TextField` to input an email address.
    /// Setting the text field's keyboard type to `.emailAddress` ensures the
    /// user can only enter correctly formatted email addresses.
    ///
    /// ```
    /// struct EmailView: View {
    ///     @State var emailAddress = ""
    ///
    ///     var body: some View {
    ///         TextField("someone@example.com", text: $emailAddress)
    ///             .keyboardType(.emailAddress)
    ///     }
    /// }
    /// ```
    ///
    /// There are several different kinds of specialized keyboard types
    /// available though the
    /// [UIKeyboardType](https://developer.apple.com/documentation/uikit/uikeyboardtype)
    /// enumeration. To
    /// specify the default system keyboard type, use `.default`.
    ///
    /// - Parameter type: One of the keyboard types defined in the
    /// `UIKeyboardType` enumeration.
    @available(iOS 13.0, tvOS 13.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public func keyboardType(_ type: UIKeyboardType) -> some View { }

}

extension View {

    /// A view modifier that sets whether to apply auto-capitalization to this view.
    ///
    /// Use `autocapitalization(_:)` when you need to automatically capitalize
    /// words, sentences, or other text like proper nouns.
    ///
    /// In example below, as the user enters text each word is automatically
    /// capitalized:
    ///
    /// ```
    /// struct NameView: View {
    ///     @State var fullName = ""
    ///
    ///     var body: some View {
    ///         TextField("Last, First", text: $fullName)
    ///             .autocapitalization(UITextAutocapitalizationType.words)
    ///     }
    /// }
    /// ```
    ///
    /// The
    /// [UITextAutocapitalizationType](https://developer.apple.com/documentation/uikit/uitextautocapitalizationtype)
    /// enumeration defines the available capitalization modes. The default is
    /// [sentences](https://developer.apple.com/documentation/uikit/uitextautocapitalizationtype/sentences).
    ///
    /// - Parameter style: One of the autocapitalization modes defined in the
    /// `UITextAutocapitalizationType` enumeration.
    @available(iOS 13.0, tvOS 13.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public func autocapitalization(_ style: UITextAutocapitalizationType) -> some View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Defines a group of views with synchronized geometry using an
    /// identifier and namespace that you provide.
    ///
    /// This method sets the geometry of each view in the group from the
    /// inserted view with `isSource = true` (known as the "source" view),
    /// updating the values marked by `properties`.
    ///
    /// If inserting a view in the same transaction that another view
    /// with the same key is removed, the system will interpolate their
    /// frame rectangles in window space to make it appear that there
    /// is a single view moving from its old position to its new
    /// position. The usual transition mechanisms define how each of
    /// the two views is rendered during the transition (e.g. fade
    /// in/out, scale, etc), the `matchedGeometryEffect()` modifier
    /// only arranges for the geometry of the views to be linked, not
    /// their rendering.
    ///
    /// If the number of currently-inserted views in the group with
    /// `isSource = true` is not exactly one results are undefined, due
    /// to it not being clear which is the source view.
    ///
    /// - Parameters:
    ///   - id: The identifier, often derived from the identifier of
    ///     the data being displayed by the view.
    ///   - namespace: The namespace in which defines the `id`. New
    ///     namespaces are created by adding an `@Namespace()` variable
    ///     to a `View` type and reading its value in the view's body
    ///     method.
    ///   - properties: The properties to copy from the source view.
    ///   - anchor: The relative location in the view used to produce
    ///     its shared position value.
    ///   - isSource: True if the view should be used as the source of
    ///     geometry for other views in the group.
    ///
    /// - Returns: A new view that defines an entry in the global
    ///   database of views synchronizing their geometry.
    ///
    @inlinable public func matchedGeometryEffect<ID>(id: ID, in namespace: Namespace.ID, properties: MatchedGeometryProperties = .frame, anchor: UnitPoint = .center, isSource: Bool = true) -> some View where ID : Hashable { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an action to perform when the specified preference key's value
    /// changes.
    ///
    /// - Parameters:
    ///   - key: The key to monitor for value changes.
    ///   - action: The action to perform when the value for `key` changes. The
    ///     `action` closure passes the new value as its parameter.
    ///
    /// - Returns: A view that triggers `action` when the value for `key`
    ///   changes.
    @inlinable public func onPreferenceChange<K>(_ key: K.Type = K.self, perform action: @escaping (K.Value) -> Void) -> some View where K : PreferenceKey, K.Value : Equatable { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 7.0, *)
extension View {

    /// Sets the style for navigation views within this view.
    ///
    /// [[navigation-view-style]]
    @available(watchOS 7.0, *)
    public func navigationViewStyle<S>(_ style: S) -> some View where S : NavigationViewStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for lists within this view.
    ///
    /// [[list-style]]
    public func listStyle<S>(_ style: S) -> some View where S : ListStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Applies a transformation to a preference value.
    @inlinable public func transformPreference<K>(_ key: K.Type = K.self, _ callback: @escaping (inout K.Value) -> Void) -> some View where K : PreferenceKey { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets whether this view flips its contents horizontally when the layout
    /// direction is right-to-left.
    ///
    /// Use `flipsForRightToLeftLayoutDirection(_:)` when you need the system to
    /// horizontally flip the contents of the view to support right-to-left
    /// layout.
    ///
    /// In the example below, the text flips horizontally when the layout system
    /// is right-to-left:
    ///
    /// ```
    /// struct HebrewView: View {
    ///     var body: some View {
    ///         Text("שָׁלוֹם")
    ///          .flipsForRightToLeftLayoutDirection(true)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter enabled: A Boolean value that indicates whether this view
    ///   flips its content horizontally when the layout direction is
    ///   right-to-left.
    ///
    /// - Returns: A view that conditionally flips its contents horizontally
    ///   when the layout direction is right-to-left.
    @inlinable public func flipsForRightToLeftLayoutDirection(_ enabled: Bool) -> some View { }

}

extension View {

    /// A view modifier that sets the text content type for this view, which the system uses to
    /// offer suggestions while the user enters text on an iOS or tvOS device.
    ///
    /// Use ``View/textContentType(_:)`` to set the content type for this view.
    ///
    /// Available content type values can be found in the
    /// [UITextContentType](https://developer.apple.com/documentation/uikit/uitextcontenttype)
    /// page.
    ///
    /// This example configures the `TextField` for the entry of email
    /// addresses:
    ///
    /// ```
    /// struct EmailView: View {
    ///     @State private var emailAddress = ""
    ///
    ///     var body: some View {
    ///         TextField("billjames2@icloud.com", text: $emailAddress)
    ///             .textContentType(.emailAddress)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter textContentType: One of the content types available in the
    ///   `UITextContentType` enumeration that identify the semantic meaning
    ///     expected for a text-entry area. These include support for email
    ///     addresses, location names, URLs, and telephone numbers to name
    ///     just a few.
    @available(iOS 13.0, tvOS 13.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    @inlinable public func textContentType(_ textContentType: UITextContentType?) -> some View { }

}

extension View {

    /// A view modifier that hides the labels of any controls contained within this view.
    ///
    /// Use `labelsHidden()` when it would not be appropriate to show a
    /// label near controls in the context of your user interface.
    ///
    /// Although the labels are not visually laid out alongside the controls,
    /// the control's label text is still often required, because it is used
    /// for other purposes including accessibility. This example shows two
    /// controls where the first control’s label is hidden.
    ///
    /// In the example below, one of the toggles has its label hidden:
    ///
    /// ```
    /// struct TogglesView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Toggle(isOn: $toggle1) {
    ///                 Text("Toggle1")
    ///             }
    ///             .labelsHidden()
    ///
    ///             Toggle(isOn: $toggle2) {
    ///                 Text("Toggle2")
    ///             }
    ///         }
    ///     }
    /// }
    ///
    /// - Note: This modifier does not work for all labels. It applies to
    ///   labels that are external/separate from the rest of the control's
    ///   interface like `Toggle`, but not to controls like a bordered button
    ///   where the label is inside the button's border.
    public func labelsHidden() -> some View { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// A view modifier that defines a keyboard shortcut and assigns it to the modified control.
    ///
    /// Pressing the control's shortcut while the control is anywhere in the
    /// frontmost window or scene, or anywhere in the macOS main menu, is
    /// equivalent to direct interaction with the control to perform its primary
    /// action.
    ///
    /// The target of a keyboard shortcut is resolved in a leading-to-trailing,
    /// depth-first traversal of one or more view hierarchies. On macOS, the
    /// system looks in the key window first, then the main window, and then the
    /// command groups; on other platforms, the system looks in the active
    /// scene, and then the command groups.
    ///
    /// If multiple controls are associated with the same shortcut, the first
    /// one found is used.
    ///
    /// ```
    /// struct ShortcutView: View {
    ///     var body: some View {
    ///         Button("Click or press command+ctrl+P to print 🍌") { print("🍌") }
    ///             .keyboardShortcut(KeyEquivalent("P"), modifiers: [.command, .control])
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - key: A key of type `KeyEquivalent`.
    ///   - modifiers: The modifier or function keys to use for the shortcut.
    public func keyboardShortcut(_ key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View { }


    /// A view modifier that assigns a keyboard shortcut to the modified control.
    ///
    /// Pressing the control's shortcut while the control is anywhere in the
    /// frontmost window or scene, or anywhere in the macOS main menu, is
    /// equivalent to direct interaction with the control to perform its primary
    /// action.
    ///
    /// The target of a keyboard shortcut is resolved in a leading-to-trailing
    /// traversal of one or more view hierarchies. On macOS, the system looks in
    /// the key window first, then the main window, and then the command groups;
    /// on other platforms, the system looks in the active scene, and then the
    /// command groups.
    ///
    /// If multiple controls are associated with the same shortcut, the first
    /// one found is used.
    ///
    /// ```
    /// struct ShortcutView: View {
    ///     var body: some View {
    ///         Button("Click or press command+ctrl+P to print 🍌") { print("🍌") }
    ///             .keyboardShortcut(KeyboardShortcut(KeyEquivalent("P"), modifiers: [.command, .control])))
    ///     }
    /// }
    /// ```
    ///
    /// You can also use ``KeyboardShortcut`` actions directly:
    ///
    /// ```
    /// struct KeyboardShortcutView: View {
    ///     var body: some View {
    ///         Text("Press ENTER to save or ESC to cancel.")
    ///         HStack {
    ///             Button("Cancel") { print("cancel") }
    ///                 .keyboardShortcut(.cancelAction)
    ///             Button("Save") { print("save") }
    ///                 .keyboardShortcut(.defaultAction)
    ///         }
    ///     }
    /// }
    /// ```
    public func keyboardShortcut(_ shortcut: KeyboardShortcut) -> some View { }

}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
extension View {

    /// Hides the navigation bar for this view.
    ///
    /// Use `navigationBarHidden(_:)` to hide the navigation bar. This modifier
    /// only takes effect when this view is inside of and visible within a
    /// `NavigationView`.
    ///
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    ///   navigation bar.
    @available(macOS, unavailable)
    public func navigationBarHidden(_ hidden: Bool) -> some View { }


    /// A view modifier that sets the title in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:)` to set the title of the navigation bar.
    /// This modifier only takes effect when this view is inside of and visible
    /// within a `NavigationView`.
    ///
    /// The example below shows setting the title of the navigation bar using a
    /// `Text` view:
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle(Text("Today's Flavors"))
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter title: A description of this view to display in the
    ///   navigation bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    public func navigationBarTitle(_ title: Text) -> some View { }


    /// A view modifier that sets the title of this view's navigation bar with a localized string.
    ///
    /// Use `navigationBarTitle(_:)` to set the title of the navigation bar
    /// using a `LocalizedStringKey` that will be used to search for a
    /// matching localized string in the application's localizable strings
    /// assets.
    ///
    /// This modifier only takes effect when this view is inside of and visible
    /// within a `NavigationView`.
    ///
    /// In the example below, a string constant is used to access a
    /// `LocalizedStringKey` that will be resolved at run time to provide a
    /// title for the navigation bar. If the localization key cannot be
    /// resolved, the text of the key name will be used as the title text.
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle("Today's Flavors")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter titleKey: A key to a localized description of this view to
    ///   display in the navigation bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    public func navigationBarTitle(_ titleKey: LocalizedStringKey) -> some View { }


    /// A view modifier that sets the title of this view's navigation bar with a string.
    ///
    /// Use `navigationBarTitle(_:)` to set the title of the navigation bar
    /// using a `String`. This modifier only takes effect when this view is
    /// inside of and visible within a `NavigationView`.
    ///
    /// In the example below, text for the navigation bar title is provided
    /// using a string:
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         let text = "Today's Flavors"
    ///         var body: some View {
    ///             NavigationView {
    ///                 List(items, id: \.self) {
    ///                     Text($0)
    ///                 }
    ///                 .navigationBarTitle(text)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter title: A title for this view to display in the navigation
    ///   bar.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    @available(watchOS, introduced: 6.0, deprecated: 100000.0, renamed: "navigationTitle(_:)")
    public func navigationBarTitle<S>(_ title: S) -> some View where S : StringProtocol { }


    /// A view modifier that sets the title and display mode in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:displayMode:)` to set the title of the
    /// navigation bar for this view and specify a display mode for the title
    /// from one of the `NavigationBarItem/TitleDisplayMode` styles. This
    /// modifier only takes effect when this view is inside of and visible
    /// within a `NavigationView`.
    ///
    /// [[navigation-title-display-mode]]
    ///
    /// In the example below, text for the navigation bar title is provided
    /// using a `Text` view. The navigation bar title's
    /// `NavigationBarItem/TitleDisplayMode` is set to `.inline` which places
    /// the navigation bar title in the bounds of the navigation bar.
    ///
    ///     struct FlavorView: View {
    ///        let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                     "Pistachio"]
    ///        var body: some View {
    ///             NavigationView {
    ///                  List(items, id: \.self) {
    ///                      Text($0)
    ///                  }
    ///                 .navigationBarTitle(Text("Today's Flavors", displayMode: .inline)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - title: A title for this view to display in the navigation bar.
    ///   - displayMode: The style to use for displaying the navigation bar title.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func navigationBarTitle(_ title: Text, displayMode: NavigationBarItem.TitleDisplayMode) -> some View { }


    /// A view modifier that sets the title and display mode in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:displayMode:)` to set the title of the
    /// navigation bar for this view and specify a display mode for the title
    /// from one of the `NavigationBarItem/TitleDisplayMode` styles. This
    /// modifier only takes effect when this view is inside of and visible
    /// within a `NavigationView`.
    ///
    /// [[navigation-title-display-mode]]
    ///
    /// In the example below, text for the navigation bar title is provided
    /// using a string. The navigation bar title's
    /// `NavigationBarItem/TitleDisplayMode` is set to `.inline` which places
    /// the navigation bar title in the bounds of the navigation bar.
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         var body: some View {
    ///             NavigationView {
    ///                  List(items, id: \.self) {
    ///                      Text($0)
    ///                  }
    ///                 .navigationBarTitle("Today's Flavors", displayMode: .inline)
    ///             }
    ///         }
    ///     }
    ///
    /// If the `titleKey` can't be found, the title uses the text of the key
    /// name instead.
    ///
    /// - Parameters:
    ///   - titleKey: A key to a localized description of this view to display
    ///     in the navigation bar.
    ///   - displayMode: The style to use for displaying the navigation bar
    ///     title.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func navigationBarTitle(_ titleKey: LocalizedStringKey, displayMode: NavigationBarItem.TitleDisplayMode) -> some View { }


    /// A view modifier that sets the title and display mode in the navigation bar for this view.
    ///
    /// Use `navigationBarTitle(_:, displayMode)` to set the title of the
    /// navigation bar for this view and specify a display mode for the
    /// title from one of the `NavigationBarItem.Title.DisplayMode`
    /// styles. This modifier only takes effect when this view is inside of and
    /// visible within a `NavigationView`.
    ///
    /// In the example below, `navigationBarTitle(_:, displayMode)` uses a
    /// string to provide a title for the navigation bar. Setting the title's
    /// `displaymode` to `.inline` places the navigation bar title within the
    /// bounds of the navigation bar.
    ///
    /// In the example below, text for the navigation bar title is provided using
    /// a string. The navigation bar title's `displayMode` is set to
    /// `.inline` which places the navigation bar title in the bounds of the
    /// navigation bar.
    ///
    ///     struct FlavorView: View {
    ///         let items = ["Chocolate", "Vanilla", "Strawberry", "Mint Chip",
    ///                      "Pistachio"]
    ///         let title = "Today's Flavors"
    ///         var body: some View {
    ///             NavigationView {
    ///                  List(items, id: \.self) {
    ///                      Text($0)
    ///                  }
    ///                 .navigationBarTitle(title, displayMode: .inline)
    ///             }
    ///         }
    ///     }
    ///
    /// ![A screenshot of a navigation bar, showing the title within the bounds
    ///  of the navigation bar]
    /// (SwiftUI-navigationBarTitle-stringProtocol.png)
    ///
    /// - Parameters:
    ///   - title: A title for this view to display in the navigation bar.
    ///   - displayMode: The way to display the title.
    @available(iOS, introduced: 14.0, deprecated: 100000.0, message: "Use navigationTitle(_:) with navigationBarTitleDisplayMode(_:)")
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func navigationBarTitle<S>(_ title: S, displayMode: NavigationBarItem.TitleDisplayMode) -> some View where S : StringProtocol { }


    /// A view modifier that hides the navigation bar back button for the view.
    ///
    /// Use `navigationBarBackButtonHidden(_:)` to hide the back button for this
    /// view.
    ///
    /// This modifier only takes effect when this view is inside of and visible
    /// within a `NavigationView`.
    ///
    /// - Note: When applying this modifier, your navigation view will also
    /// lose the ability to swipe back.
    ///
    /// ```
    /// struct TrapDoorView: View {
    ///     var body: some View {
    ///         NavigationView {
    ///             NavigationLink(destination: NoReturnView(),
    ///                            label { Text("Tap to fall into the trap door 🚪") })
    ///         }
    ///     }
    /// }
    ///
    /// struct NoReturnView: View {
    ///     var body: some View {
    ///         Text("Ha! You cannot return.")
    ///             .navigationBarBackButtonHidden(true)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter hidesBackButton: A Boolean value that indicates whether to
    ///   hide the back button.
    @available(macOS, unavailable)
    public func navigationBarBackButtonHidden(_ hidesBackButton: Bool) -> some View { }

}

extension View {

    /// Modifies this view by injecting a value that you provide for use by
    /// other views whose state depends on the focused view hierarchy.
    ///
    /// - Parameters:
    ///   - keyPath: The key path to associate `value` with when adding
    ///     it to the existing table of exported focus values.
    ///   - value: The focus value to export.
    /// - Returns: A modified representation of this view.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public func focusedValue<Value>(_ keyPath: WritableKeyPath<FocusedValues, Value?>, _ value: Value) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that sets the alignment of multiline text in this view.
    ///
    /// Use `multilineTextAlignment(_:)` to select an alignment for all of the
    /// text in this view or view hierarchy.
    ///
    /// In the example below, the contents of the `Text` view are center
    /// aligned. This also applies to the interpolated newline placed in the
    /// middle of the text since "multiple lines" refers to all of the text
    /// inside the view, regardless of any internal formatting or inclusion of
    /// interpolated text.
    ///
    /// ```
    /// struct MultilineTextView: View {
    ///     var body: some View {
    ///         Text("This is a block of text that will show up in a text element as multiple lines.\("\n") Here we have chosen to center this text.")
    ///             .frame(width: 200, height: 200, alignment: .leading)
    ///             .multilineTextAlignment(.center)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter alignment: A value that you use to left-, right-, or
    ///   center-align the text within a view.
    ///
    /// - Returns: A view that aligns the lines of multiline `Text` instances
    ///   it contains.
    @inlinable public func multilineTextAlignment(_ alignment: TextAlignment) -> some View { }


    /// A view modifier that sets the truncation mode for lines of text that are too long to fit in
    /// the available space.
    ///
    /// Use the `truncationMode(_:)` modifier to determine whether text in a
    /// long line is truncated at the beginning, middle, or end. Truncation is
    /// indicated by adding an ellipsis (…) to the line when removing text to
    /// indicate to readers that text is missing.
    ///
    /// In the example below, the bounds of text view constrains the amount of
    /// text that the view displays and the `truncationMode(_:)` specifies from
    /// which direction and where to display the truncation indicator:
    ///
    /// ```
    /// struct TruncatedTextView: View {
    ///     var body: some View {
    ///         Text("This is a block of text that will show up in a text element as multiple lines. The text will fill the available space, and then, eventually, be truncated.")
    ///             .frame(width: 150, height: 150)
    ///             .truncationMode(.tail)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter mode: The truncation mode that specifies where to truncate
    ///   the text within the text view, if needed. You can truncate at the
    ///   beginning, middle, or end of the text view.
    ///
    /// - Returns: A view that truncates text at different points in a line
    ///   depending on the mode you select.
    @inlinable public func truncationMode(_ mode: Text.TruncationMode) -> some View { }


    /// A view modifier that sets the amount of space between lines of text in this view.
    ///
    /// Use `lineSpacing(_:)` to set the amount of spacing from the bottom of
    /// one line to the top of the next for text elements in the view.
    ///
    /// In the `Text` view in the example below, 10 points separate the bottom
    /// of one line to the top of the next as the text field wraps inside this
    /// view. Applying `lineSpacing(_:)` to a view hierarchy applies the line
    /// spacing to all text elements contained in the view.
    ///
    /// ```
    /// struct SpacedTextView: View {
    ///     var body: some View {
    ///         Text("This is a string in a TextField with 10 point spacing applied between the bottom of one line and the top of the next.")
    ///             .frame(width: 200, height: 200, alignment: .leading)
    ///             .lineSpacing(10)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter lineSpacing: The amount of space between the bottom of one
    ///   line and the top of the next line in points.
    @inlinable public func lineSpacing(_ lineSpacing: CGFloat) -> some View { }


    /// A view modifier whether text in this view can compress the space between characters
    /// when necessary to fit text in a line.
    ///
    /// Use `allowsTightening(_:)` to enable the compression of inter-character
    /// spacing of text in a view to try to fit the text in the view's bounds.
    ///
    /// In the example below, two identically configured text views show the
    /// effects of `allowsTightening(_:)` on the compression of the spacing
    /// between characters:
    ///
    /// ```
    /// struct TightenedTextView: View {
    ///     var body: some View {
    ///         VStack {
    ///             Text("This is a wide text element")
    ///                 .font(.body)
    ///                 .frame(width: 200, height: 50, alignment: .leading)
    ///                 .lineLimit(1)
    ///                 .allowsTightening(true)
    ///
    ///             Text("This is a wide text element")
    ///                 .font(.body)
    ///                 .frame(width: 200, height: 50, alignment: .leading)
    ///                 .lineLimit(1)
    ///                 .allowsTightening(false)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter flag: A Boolean value that indicates whether the space
    ///   between characters compresses when necessary.
    ///
    /// - Returns: A view that can compress the space between characters when
    ///   necessary to fit text in a line.
    @inlinable public func allowsTightening(_ flag: Bool) -> some View { }


    /// A view modifier that sets the maximum number of lines that text can occupy in this view.
    ///
    /// Use `lineLimit(_:)` to cap the number of lines that an individual text
    /// element can display.
    ///
    /// The line limit applies to all `Text` instances within a hierarchy. For
    /// example, an `HStack` with multiple pieces of text longer than three
    /// lines caps each piece of text to three lines rather than capping the
    /// total number of lines across the `HStack`.
    ///
    /// In the example below, the `lineLimit(_:)` operator limits the very long
    /// line in the `Text` element to the 2 lines that fit within the view's
    /// bounds:
    ///
    /// ```
    /// struct LimitedTextView: View {
    ///     var body: some View {
    ///         Text("This is a long string that demonstrates the effect of SwuiftUI's lineLimit(:_) operator.")
    ///             .frame(width: 200, height: 200, alignment: .leading)
    ///             .lineLimit(2)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter number: The line limit. If `nil`, no line limit applies.
    ///
    /// - Returns: A view that limits the number of lines that `Text`
    ///   instances display.
    @inlinable public func lineLimit(_ number: Int?) -> some View { }


    /// A view modifier that sets the minimum amount that text in this view scales down to fit in the
    /// available space.
    ///
    /// Use the `minimumScaleFactor(_:)` modifier if the text you place in a
    /// view doesn't fit and it's okay if the text shrinks to accommodate. For
    /// example, a label with a minimum scale factor of `0.5` draws its text in
    /// a font size as small as half of the actual font if needed.
    ///
    /// In the example below, the `HStack` contains a `Text` label with a
    /// line limit of `1`, that is next to a `TextField`. To allow the label
    /// to fit into the available space, the `minimumScaleFactor(_:)` modifier
    /// shrinks the text as needed to fit into the available space.
    ///
    /// ```
    /// struct LimitedScaleTextView: View {
    ///     var body: some View {
    ///         HStack {
    ///             Text("This is a long label that will be scaled to fit:")
    ///                 .lineLimit(1)
    ///                 .minimumScaleFactor(0.5)
    ///             TextField("My Long Text Field", text: $myTextField)
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter factor: A fraction between 0 and 1 (inclusive) you use to
    ///   specify the minimum amount of text scaling that this view permits.
    ///
    /// - Returns: A view that limits the amount of text downscaling.
    @inlinable public func minimumScaleFactor(_ factor: CGFloat) -> some View { }


    /// A view modifier that sets a transform for the case of the text contained in this view when
    /// displayed.
    ///
    /// The default value is `nil`, displaying the text without any case
    /// changes.
    ///
    /// ```
    /// struct CapsView: View {
    ///     var body: some View {
    ///         Text("This is all caps text!")
    ///             .textCase(.uppercase)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter textCase: One of the `Text/Case` enumerations; the
    ///   default is `nil`.
    /// - Returns: A view that transforms the case of the text.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    @inlinable public func textCase(_ textCase: Text.Case?) -> some View { }

}

@available(iOS 13.0, macOS 10.15, watchOS 6.0, *)
@available(tvOS, unavailable)
extension View {

    /// A view modifier that adds an action to perform when this view recognizes a tap gesture.
    ///
    /// Do not use this modifier in place of ``Button``, ``NavigationLink``,
    /// or other purpose-built controls for acting on tap gestures. Among
    /// other benefits, those controls dim slightly when they are tapped,
    /// while applying this modifier will not add this effect.
    ///
    /// ```
    /// struct TapAndPrintView: View {
    ///     var body: some View {
    ///         Text("Tap me once for a 🍌")
    ///             .onTapGesture { print("🍌") }
    ///         Text("Tap me twice for a 🍑")
    ///             .onTapGesture(count: 2) { print("🍑") }
    ///     }
    /// }
    /// ```
    public func onTapGesture(count: Int = 1, perform action: @escaping () -> Void) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// A view modifier that applies an inset to the rows in a list.
    ///
    /// Use `listRowInsets(_:)` to change the default padding of the content of
    /// list items.
    ///
    /// In the example below, the `Flavor` enumeration provides content for list
    /// items. The SwiftUI `List` builder iterates over the `Flavor`
    /// enumeration and extracts the raw value of each of its elements using the
    /// resulting text to create each list row item. After the list builder
    /// finishes, the `listRowInsets(_:)` modifier changes the edge insets of
    /// each row of the list according to the `EdgeInsets` values you provide.
    ///
    ///     struct ListRowInsets: View {
    ///         enum Flavor: String, CaseIterable, Identifiable {
    ///             var id: String { self.rawValue }
    ///             case vanilla, chocolate, strawberry
    ///         }
    ///
    ///         var body: some View {
    ///             List(Flavor.allCases, id: \.self) {
    ///                 Text($0.rawValue)
    ///             }
    ///             .listRowInsets(EdgeInsets(top: 0, leading: 75, bottom: 0, trailing: 0))
    ///         }
    ///     }
    ///
    /// - Parameter insets: `EdgeInsets` to apply to the edges of the view.
    ///
    /// - Returns: A view that uses the given edge insets when used as a list
    ///   cell.
    @inlinable public func listRowInsets(_ insets: EdgeInsets?) -> some View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Populates the toolbar or navigation bar with items
    /// whose content is the specified views.
    ///
    /// - Parameter content: The views representing the content of the toolbar.
    public func toolbar<Content>(@ViewBuilder content: () -> Content) -> some View where Content : View { }


    /// Populates the toolbar or navigation bar.
    ///
    /// - Parameters:
    ///   - items: The items representing the content of the toolbar.
    ///
    /// `.toolbar(content:)` populates the toolbar or navigation bar. For example:
    ///
    /// ![toolbar Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/toolbar-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         NavigationView {
    ///             Text("Hello, World!")
    ///                 .toolbar {
    ///                     ToolbarItem(id: "bananas") {
    ///                         Text("🍌🍌")
    ///                     }
    ///
    ///                     ToolbarItem(id: "apples") {
    ///                         Text("🍏🍏")
    ///                     }
    ///
    ///                     ToolbarItem(id: "peaches") {
    ///                         Text("🍑🍑")
    ///                     }
    ///                 }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Aligning a toolbar item
    ///
    /// Think of a toolbar in terms of spacers and items.
    ///
    /// For example, this is how a single toolbar item is aligned to the right:
    ///
    /// ![toolbar Example 2](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/toolbar-example-2.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         NavigationView {
    ///             Text("Hello, World!")
    ///                 .toolbar {
    ///                     ToolbarItem(placement: .bottomBar) {
    ///                         Spacer()
    ///                     }
    ///
    ///                     ToolbarItem(placement: .bottomBar) {
    ///                         Text("🍌🍌")
    ///                     }
    ///                 }
    ///         }
    ///     }
    /// }
    /// ```
    public func toolbar<Content>(@ToolbarContentBuilder content: () -> Content) -> some View where Content : ToolbarContent { }


    /// Populates the toolbar or navigation bar.
    ///
    /// - Parameters:
    ///   - id: A unique identifier for this toolbar.
    ///   - content: The content representing the content of the toolbar.
    ///
    /// For example:
    ///
    /// ![toolbar Example 3](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/toolbar-example-3.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         NavigationView {
    ///             Text("Hello, World!")
    ///                 .toolbar {
    ///                     ToolbarItem(id: "bananas") {
    ///                         Text("🍌🍌")
    ///                     }
    ///
    ///                     ToolbarItem(id: "apples") {
    ///                         Text("🍏🍏")
    ///                     }
    ///
    ///                     ToolbarItem(id: "peaches") {
    ///                         Text("🍑🍑")
    ///                     }
    ///                 }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Aligning a toolbar item
    ///
    /// Think of a toolbar in terms of spacers and items.
    ///
    /// For example, this is how a single toolbar item is aligned to the right:
    ///
    /// ![toolbar Example 4](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/toolbar-example-4.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         NavigationView {
    ///             Text("Hello, World!")
    ///                 .toolbar {
    ///                     ToolbarItem(placement: .bottomBar) {
    ///                         Spacer()
    ///                     }
    ///
    ///                     ToolbarItem(placement: .bottomBar) {
    ///                         Text("🍌🍌")
    ///                     }
    ///                 }
    ///         }
    ///     }
    /// }
    /// ```
    public func toolbar<Content>(id: String, @ToolbarContentBuilder content: () -> Content) -> some View where Content : CustomizableToolbarContent { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Specifies whether to hide this view from system accessibility features.
    public func accessibilityHidden(_ hidden: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    public func accessibilityLabel(_ label: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    public func accessibilityValue(_ value: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    public func accessibilityHint(_ hint: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    ///
    /// - Parameter inputLabels: An array of Text elements to use as input labels.
    public func accessibilityInputLabels(_ inputLabels: [Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds the given traits to the view.
    public func accessibilityAddTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Removes the given traits from this view.
    public func accessibilityRemoveTraits(_ traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Uses the specified string to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    public func accessibilityIdentifier(_ identifier: String) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Sets the sort priority order for this view's accessibility element,
    /// relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    public func accessibilitySortPriority(_ sortPriority: Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Specifies the point where activations occur in the view.
    public func accessibilityActivationPoint(_ activationPoint: CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Specifies the unit point where activations occur in the view.
    public func accessibilityActivationPoint(_ activationPoint: UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    public func accessibilityLabel(_ labelKey: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    public func accessibilityLabel<S>(_ label: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    public func accessibilityValue(_ valueKey: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibilityLabel(),
    /// you can provide the current volume setting, like "60%", using accessibilityValue().
    public func accessibilityValue<S>(_ value: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    public func accessibilityHint(_ hintKey: LocalizedStringKey) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    public func accessibilityHint<S>(_ hint: S) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    public func accessibilityInputLabels(_ inputLabelKeys: [LocalizedStringKey]) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibilityLabel()` modifier.
    public func accessibilityInputLabels<S>(_ inputLabels: [S]) -> ModifiedContent<Self, AccessibilityAttachmentModifier> where S : StringProtocol { }
}

extension View {

    /// Specifies whether to hide this view from system accessibility features.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHidden(_:)")
    public func accessibility(hidden: Bool) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a label to the view that describes its contents.
    ///
    /// Use this method to provide an accessibility label for a view that doesn't display text, like an icon.
    /// For example, you could use this method to label a button that plays music with the text "Play".
    /// Don't include text in the label that repeats information that users already have. For example,
    /// don't use the label "Play button" because a button already has a trait that identifies it as a button.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityLabel(_:)")
    public func accessibility(label: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds a textual description of the value that the view contains.
    ///
    /// Use this method to describe the value represented by a view, but only if that's different than the
    /// view's label. For example, for a slider that you label as "Volume" using accessibility(label:),
    /// you can provide the current volume setting, like "60%", using accessibility(value:).
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityValue(_:)")
    public func accessibility(value: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Communicates to the user what happens after performing the view's
    /// action.
    ///
    /// Provide a hint in the form of a brief phrase, like "Purchases the item" or
    /// "Downloads the attachment".
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityHint(_:)")
    public func accessibility(hint: Text) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Sets alternate input labels with which users identify a view.
    ///
    /// Provide labels in descending order of importance. Voice Control
    /// and Full Keyboard Access use the input labels.
    ///
    /// > Note: If you don't specify any input labels, the user can still
    ///   refer to the view using the accessibility label that you add with the
    ///   `accessibility(label:)` modifier.
    ///
    /// - Parameter inputLabels: An array of Text elements to use as input labels.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityInputLabels(_:)")
    public func accessibility(inputLabels: [Text]) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Adds the given traits to the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityAddTraits(_:)")
    public func accessibility(addTraits traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Removes the given traits from this view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityRemoveTraits(_:)")
    public func accessibility(removeTraits traits: AccessibilityTraits) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Uses the specified string to identify the view.
    ///
    /// Use this value for testing. It isn't visible to the user.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityIdentifier(_:)")
    public func accessibility(identifier: String) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Sets a selection identifier for this view's accessibility element.
    ///
    /// Picker uses the value to determine what node to use for the
    /// accessibility value.
    @available(iOS, deprecated, introduced: 13.0)
    @available(macOS, deprecated, introduced: 10.15)
    @available(tvOS, deprecated, introduced: 13.0)
    @available(watchOS, deprecated, introduced: 6)
    public func accessibility(selectionIdentifier: AnyHashable) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Sets the sort priority order for this view's accessibility element,
    /// relative to other elements at the same level.
    ///
    /// Higher numbers are sorted first. The default sort priority is zero.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilitySortPriority(_:)")
    public func accessibility(sortPriority: Double) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Specifies the point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    public func accessibility(activationPoint: CGPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }

    /// Specifies the unit point where activations occur in the view.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(macOS, introduced: 10.15, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    @available(watchOS, introduced: 6, deprecated: 100000.0, renamed: "accessibilityActivationPoint(_:)")
    public func accessibility(activationPoint: UnitPoint) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Binds a view's identity to the given proxy value.
    ///
    /// When the proxy value specified by the `id` parameter changes, the
    /// identity of the view — for example, its state — is reset.
    @inlinable public func id<ID>(_ id: ID) -> some View where ID : Hashable { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Uses the specified preference value from the view to produce another
    /// view as an overlay atop the first view.
    @inlinable public func overlayPreferenceValue<Key, T>(_ key: Key.Type = Key.self, @ViewBuilder _ transform: @escaping (Key.Value) -> T) -> some View where Key : PreferenceKey, T : View { }


    /// Places a new view in the background of the first view, using the values from
    /// the preferences.
    ///
    /// This creates a new view, placed in the background, using the view preferences from the parent.
    /// This will not affect the layout of other views. Using backgroundPreferenceValue
    /// is one of 3 ways for responding to view preferences. For information on
    /// the other ways, see:
    /// - ``View/overlayPreferenceValue(_:_:)``
    /// - ``View/onPreferenceChange(_:_:)``
    ///
    /// For example:
    ///
    /// ![Background preference value example 1](backgroundpreference-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        Text("Bullseye")
    ///            .preference(key: CustomPreferenceKey.self, value: Color.red)
    ///            .backgroundPreferenceValue(CustomPreferenceKey.self) { PreferenceKey in
    ///                Circle().fill(PreferenceKey)
    ///        }
    ///    }
    /// }
    ///
    /// struct CustomPreferenceKey: PreferenceKey {
    ///    static var defaultValue: Color = Color.clear
    ///
    ///    static func reduce(value: inout Color, nextValue: () -> Color) {
    ///        value = nextValue()
    ///    }
    /// }
    /// ```
    @inlinable public func backgroundPreferenceValue<Key, T>(_ key: Key.Type = Key.self, @ViewBuilder _ transform: @escaping (Key.Value) -> T) -> some View where Key : PreferenceKey, T : View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds a modifier for this view that fires an action when a specific
    /// value changes.
    ///
    /// You can use `onChange` to trigger a side effect as the result of a
    /// value changing, such as an `Environment` key or a `Binding`.
    ///
    /// `onChange` is called on the main thread. Avoid performing long-running
    /// tasks on the main thread. If you need to perform a long-running task in
    /// response to `value` changing, you should dispatch to a background queue.
    ///
    /// The new value is passed into the closure. The previous value may be
    /// captured by the closure to compare it to the new value. For example, in
    /// the following code example, `PlayerView` passes both the old and new
    /// values to the model.
    ///
    ///     struct PlayerView : View {
    ///         var episode: Episode
    ///         @State private var playState: PlayState = .paused
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Text(episode.title)
    ///                 Text(episode.showTitle)
    ///                 PlayButton(playState: $playState)
    ///             }
    ///             .onChange(of: playState) { [playState] newState in
    ///                 model.playStateDidChange(from: playState, to: newState)
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - value: The value to check against when determining whether
    ///     to run the closure.
    ///   - action: A closure to run when the value changes.
    ///   - newValue: The new value that failed the comparison check.
    ///
    /// - Returns: A view that fires an action when the specified value changes.
    @inlinable public func onChange<V>(of value: V, perform action: @escaping (V) -> Void) -> some View where V : Equatable { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the style for progress views in this view.
    ///
    /// [[progressview-style]]
    ///
    /// For example, the following code creates a progress view that uses the
    /// "circular" style:
    ///
    ///     ProgressView()
    ///         .progressViewStyle(CircularProgressViewStyle())
    ///
    /// - Parameter style: The progress view style to use for this view.
    public func progressViewStyle<S>(_ style: S) -> some View where S : ProgressViewStyle { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system interface for allowing the user to move an existing
    /// file to a new location.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `file` must not be `nil`. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - file: The `URL` of the file to be moved.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileMover(isPresented: Binding<Bool>, file: URL?, onCompletion: @escaping (Result<URL, Error>) -> Void) -> some View { }


    /// Presents a system interface for allowing the user to move a collection
    /// of existing files to a new location.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `files` must not be empty. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - files: A collection of `URL`s for the files to be moved.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileMover<C>(isPresented: Binding<Bool>, files: C, onCompletion: @escaping (Result<[URL], Error>) -> Void) -> some View where C : Collection, C.Element == URL { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Sets the tint effect associated with specific content in a list.
    ///
    /// The containing list's style will apply that tint as appropriate. watchOS
    /// uses the tint color for its background platter appearance. Sidebars on
    /// iOS and macOS apply the tint color to their `Label` icons, which
    /// otherwise use the accent color by default.
    ///
    /// - Parameter tint: The tint effect to use, or nil to not override the
    ///   inherited tint.
    @inlinable public func listItemTint(_ tint: ListItemTint?) -> some View { }


    /// Sets a fixed tint color associated with specific content in a list.
    ///
    /// This is equivalent to using a tint of `ListItemTint.fixed(_:)` with the
    /// provided `tint` color.
    ///
    /// The containing list's style will apply that tint as appropriate. watchOS
    /// uses the tint color for its background platter appearance. Sidebars on
    /// iOS and macOS apply the tint color to their `Label` icons, which
    /// otherwise use the accent color by default.
    ///
    /// - Parameter color: The color to use to tint the content, or nil to not
    ///   override the inherited tint.
    @inlinable public func listItemTint(_ tint: Color?) -> some View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Links multiple accessibility elements so that the user can quickly
    /// navigate from one element to another, even when the elements are not near
    /// each other in the accessibility hierarchy.
    ///
    /// This can be useful to allow quickly jumping between content in a list and
    /// the same content shown in a detail view, for example. All elements marked
    /// with `accessibilityLinkedGroup` with the same namespace and identifier will be
    /// linked together.
    ///
    /// - Parameters:
    ///   - id: A hashable identifier used to separate sets of linked elements
    ///     within the same namespace. Elements with matching `namespace` and `id`
    ///     will be linked together.
    ///   - namespace: The namespace to use to organize linked accessibility
    ///     elements. All elements marked with `accessibilityLink` in this
    ///     namespace and with the specified `id` will be linked together.
    public func accessibilityLinkedGroup<ID>(id: ID, in namespace: Namespace.ID) -> some View where ID : Hashable { }


    /// Pairs two views, where one is the content and one is the label, for accessibility purposes.
    ///
    /// Use `accessibilityLabeledPair` with a role of `AccessibilityLabeledPairRole.label`
    /// to identify the label, and a role of `AccessibilityLabeledPairRole.content`
    /// to identify the content.
    /// This improves the behavior of accessibility features such as VoiceOver
    /// when navigating such elements, allowing users to better understand the
    /// relationship between them.
    ///
    /// - Parameters:
    ///   - role: Determines whether this element should be used as the label
    ///     in the pair, or the content in the pair.
    ///   - id: The identifier for the label / content pair. Elements with
    ///     matching identifiers within the same namespace will be paired
    ///     together.
    ///   - namespace: The namespace used to organize label and content. Label
    ///     and content under the same namespace with matching identifiers will
    ///     be paired together.
    public func accessibilityLabeledPair<ID>(role: AccessibilityLabeledPairRole, id: ID, in namespace: Namespace.ID) -> some View where ID : Hashable { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Rotates this view's rendered output in three dimensions around the given
    /// axis of rotation.
    ///
    /// Use `rotation3DEffect(_:axis:anchor:anchorZ:perspective:)` to rotate the
    /// view in three dimensions around the given axis of rotation, and
    /// optionally, position the view at a custom display order and perspective.
    ///
    /// In the example below, the text is rotated 45˚ about the `y` axis,
    /// front-most (the default `zIndex`) and default `perspective` (`1`):
    ///
    /// ```
    /// struct RotatedInSpaceView: View {
    ///     var body: some View {
    ///         Text("Rotation by passing an angle in degrees")
    ///             .rotation3DEffect(.degrees(45), axis: (x: 0.0, y: 1.0, z: 0.0))
    ///             .border(Color.gray)
    ///     }
    /// }
    /// ```
    ///
    /// [[rotation-effect]]
    ///
    /// - Parameters:
    ///   - angle: The angle at which to rotate the view.
    ///   - axis: The `x`, `y` and `z` elements that specify the axis of
    ///     rotation.
    ///   - anchor: The location with a default of `UnitPoint/center` that
    ///     defines a point in 3D space about which the rotation is anchored.
    ///   - anchorZ: The location with a default of `0` that defines a point in
    ///     3D space about which the rotation is anchored.
    ///   - perspective: The relative vanishing point with a default of `1` for
    ///     this rotation.
    @inlinable public func rotation3DEffect(_ angle: Angle, axis: (x: CGFloat, y: CGFloat, z: CGFloat), anchor: UnitPoint = .center, anchorZ: CGFloat = 0, perspective: CGFloat = 1) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Transforms the environment value of the specified key path with the
    /// given function.
    @inlinable public func transformEnvironment<V>(_ keyPath: WritableKeyPath<EnvironmentValues, V>, transform: @escaping (inout V) -> Void) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an accessibility scroll action to the view.
    public func accessibilityScrollAction(_ handler: @escaping (Edge) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Assigns a name to the view's coordinate space, so other code can operate
    /// on dimensions like points and sizes relative to the named space.
    ///
    /// Use `coordinateSpace(name:)` to allow another function to find and
    /// operate on a view and operate on dimensions relative to that view.
    ///
    /// The example below demonstrates how a nested view can find and operate on
    /// its enclosing view's coordinate space:
    ///
    ///     struct ContentView: View {
    ///         @State var location = CGPoint.zero
    ///
    ///         var body: some View {
    ///             VStack {
    ///                 Color.red.frame(width: 100, height: 100)
    ///                     .overlay(circle)
    ///                 Text("Location: \(Int(location.x)), \(Int(location.y))")
    ///             }
    ///             .coordinateSpace(name: "stack")
    ///         }
    ///
    ///         var circle: some View {
    ///             Circle()
    ///                 .frame(width: 25, height: 25)
    ///                 .gesture(drag)
    ///                 .padding(5)
    ///         }
    ///
    ///         var drag: some Gesture {
    ///             DragGesture(coordinateSpace: .named("stack"))
    ///                 .onChanged { info in location = info.location }
    ///         }
    ///     }
    ///
    /// Here, the `VStack` in the `ContentView` named “stack” is composed of a
    /// red frame with a custom `Circle` view `View/overlay(_:alignment:)`
    /// at its center.
    ///
    /// The `circle` view has an attached `DragGesture` that targets the
    /// enclosing VStack's coordinate space. As the gesture recognizer's closure
    /// registers events inside `circle` it stores them in the shared `location`
    /// state variable and the `VStack` displays the coordinates in a `Text`
    /// view.
    ///
    /// ![A screenshot showing an example of finding a named view and tracking
    /// relative locations in that view.](SwiftUI-View-coordinateSpace.png)
    ///
    /// - Parameter name: A name used to identify this coordinate space.
    @inlinable public func coordinateSpace<T>(name: T) -> some View where T : Hashable { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Changes the tappable area of a content shape for hit testing.
    ///
    /// When using a container view, such as ``ZStack`` or ``VStack``, tap gestures
    /// are only applied to elements in the container which have content. For example,
    /// a tap gesture on a ``VStack`` with a ``Spacer`` will not be triggered
    /// when clicking on the spacer. However, setting the content shape allows
    /// everything in the container view to be clickable.
    ///
    /// For example, to make an entire VStack container clickable:
    ///
    /// ![Content shape example 1](contentshape-example-1.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    @State private var toggleColor: Bool = false
    ///
    ///    var body: some View {
    ///        VStack {
    ///            Text("Top text").border(Color.black)
    ///            Spacer().frame(height: 50)
    ///
    ///            Rectangle()
    ///                .fill(toggleColor ? Color.red : Color.blue)
    ///                .frame(width: 150, height: 150)
    ///
    ///            Spacer().frame(height: 50)
    ///            Text("Bottom text").border(Color.black)
    ///        }
    ///        .contentShape(Rectangle())
    ///        .onTapGesture {
    ///            self.toggleColor.toggle()
    ///        }
    ///    }
    /// }
    /// ```
    ///
    /// For further clarification on how this works, see this animation of the
    /// same example from above _without_ any defined contentShape. Notice how
    /// the rectangle color does not toggle when clicking on the spacers.
    ///
    /// ![Content shape example 2](contentshape-example-2.gif)
    ///
    /// - Parameters:
    ///   - shape: The hit testing shape for the view.
    ///   - eoFill: A Boolean that indicates whether the shape is interpreted
    ///     with the even-odd winding number rule.
    ///
    /// - Returns: A view that uses the given shape for hit testing.
    @inlinable public func contentShape<S>(_ shape: S, eoFill: Bool = false) -> some View where S : Shape { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets a value for the given preference.
    @inlinable public func preference<K>(key: K.Type = K.self, value: K.Value) -> some View where K : PreferenceKey { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Applies the given transaction mutation function to all transactions used
    /// within the view.
    ///
    /// Use this modifier on leaf views rather than container views. The
    /// transformation applies to all child views within this view; calling
    /// `transaction(_:)` on a container view can lead to unbounded scope.
    ///
    /// - Parameter transform: The transformation to apply to transactions
    ///   within this view.
    ///
    /// - Returns: A view that wraps this view and applies `transformation` to
    ///   all transactions used within the view.
    @inlinable public func transaction(_ transform: @escaping (inout Transaction) -> Void) -> some View { }


    /// Applies the given animation to all animatable values within this view.
    ///
    /// Use this modifier on leaf views rather than container views. The
    /// animation applies to all child views within this view; calling
    /// `animation(_:)` on a container view can lead to unbounded scope.
    ///
    /// - Parameter animation: The animation to apply to animatable values
    ///   within this view.
    ///
    /// - Returns: A view that wraps this view and applies `animation` to all
    ///   animatable values used within the view.
    @inlinable public func animation(_ animation: Animation?) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Wraps this view as a new accessibility element.
    public func accessibilityElement(children: AccessibilityChildBehavior = .ignore) -> some View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Advertises a user activity type.
    ///
    /// You can use `userActivity(_:isActive:_:)` to start, stop, or modify the
    /// advertisement of a specific type of user activity.
    ///
    /// The scope of the activity applies only to the scene or window the
    /// view is in.
    ///
    /// - Parameters:
    ///   - activityType: The type of activity to advertise.
    ///   - isActive: When `false`, avoids advertising the activity. Defaults
    ///     to `true`.
    ///   - update: A function that modifies the passed-in activity for
    ///     advertisement.
    public func userActivity(_ activityType: String, isActive: Bool = true, _ update: @escaping (NSUserActivity) -> ()) -> some View { }


    /// Advertises a user activity type.
    ///
    /// The scope of the activity applies only to the scene or window the
    /// view is in.
    ///
    /// - Parameters:
    ///   - activityType: The type of activity to advertise.
    ///   - element: If the element is `nil`, the handler will not be
    ///     associated with the activity (and if there are no handlers, no
    ///     activity is advertised). The method passes the non-`nil` element to
    ///     the handler as a convenience so the handlers don't all need to
    ///     implement an early exit with
    ///     `guard element = element else { return }`.
    ///    - update: A function that modifies the passed-in activity for
    ///    advertisement.
    public func userActivity<P>(_ activityType: String, element: P?, _ update: @escaping (P, NSUserActivity) -> ()) -> some View { }


    /// Registers a handler to invoke when the view receives the specified
    /// activity type for the scene or window the view is in.
    ///
    /// - Parameters:
    ///   - activityType: The type of activity to handle.
    ///   - action: A function to call that takes a
    ///     <doc://com.apple.documentation/documentation/Foundation/NSUserActivity>
    ///     object as its parameter
    ///     when delivering the activity to the scene or window the view is in.
    public func onContinueUserActivity(_ activityType: String, perform action: @escaping (NSUserActivity) -> ()) -> some View { }


    /// Registers a handler to invoke when the view receives a url for the
    /// scene or window the view is in.
    ///
    /// > Note: This method handles the reception of Universal Links,
    ///   rather than a
    ///   <doc://com.apple.documentation/documentation/Foundation/NSUserActivity>.
    ///
    /// - Parameter action: A function that takes a
    ///  <doc://com.apple.documentation/documentation/Foundation/URL>
    ///  object as its parameter when delivering the URL to the scene or window
    ///  the view is in.
    public func onOpenURL(perform action: @escaping (URL) -> ()) -> some View { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Specifies a modifier indicating the Scene this View
    /// is in can handle matching incoming External Events.
    ///
    /// If no modifier is set in any Views within a Scene, the behavior
    /// is platform dependent. On macOS, a new Scene will be created to
    /// use for the External Event. On iOS, the system will choose an
    /// existing Scene to use.
    ///
    /// On platforms that only allow a single Window/Scene, this method is
    /// ignored, and incoming External Events are always routed to the
    /// existing single Scene.
    ///
    /// - Parameter preferring: A Set of Strings that are checked to see
    /// if they are contained in the targetContentIdenfifier to see if
    /// the Scene this View is in prefers to handle the Exernal Event.
    /// The empty Set and empty Strings never match. The String value
    /// "*" always matches. The String comparisons are case/diacritic
    /// insensitive
    ///
    /// - Parameter allowing: A Set of Strings that are checked to see
    /// if they are contained in the targetContentIdenfifier to see if
    /// the Scene this View is in allows handling the External Event.
    /// The empty Set and empty Strings never match. The String value
    /// "*" always matches.
    public func handlesExternalEvents(preferring: Set<String>, allowing: Set<String>) -> some View { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a system interface for allowing the user to export an in-memory
    /// document to a file on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `document` must not be `nil`. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - document: The in-memory document to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - defaultFilename: If provided, the default name to use for the
    ///     exported file, which will the user will have an opportunity to edit
    ///     prior to the export.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String? = nil, onCompletion: @escaping (Result<URL, Error>) -> Void) -> some View where D : FileDocument { }


    /// Presents a system interface for allowing the user to export a collection
    /// of in-memory documents to files on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `documents` must not be empty. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - documents: The collection of in-memory documents to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: @escaping (Result<[URL], Error>) -> Void) -> some View where C : Collection, C.Element : FileDocument { }


    /// Presents a system interface for allowing the user to export an in-memory
    /// document to a file on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `document` must not be `nil`. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - document: The in-memory document to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - defaultFilename: If provided, the default name to use for the
    ///     exported file, which will the user will have an opportunity to edit
    ///     prior to the export.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileExporter<D>(isPresented: Binding<Bool>, document: D?, contentType: UTType, defaultFilename: String? = nil, onCompletion: @escaping (Result<URL, Error>) -> Void) -> some View where D : ReferenceFileDocument { }


    /// Presents a system interface for allowing the user to export a collection
    /// of in-memory documents to files on disk.
    ///
    /// In order for the interface to appear, both `isPresented` must be `true`
    /// and `documents` must not be empty. When the operation is finished,
    /// `isPresented` will be set to `false` before `onCompletion` is called. If
    /// the user cancels the operation, `isPresented` will be set to `false` and
    /// `onCompletion` will not be called.
    ///
    /// The `contentType` provided must be included within the document type's
    /// `writableContentTypes`, otherwise the first valid writable content type
    /// will be used instead.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the interface should be shown.
    ///   - documents: The collection of in-memory documents to export.
    ///   - contentType: The content type to use for the exported file.
    ///   - onCompletion: A callback that will be invoked when the operation has
    ///     has succeeded or failed.
    ///   - result: A `Result` indicating whether the operation succeeded or
    ///     failed.
    public func fileExporter<C>(isPresented: Binding<Bool>, documents: C, contentType: UTType, onCompletion: @escaping (Result<[URL], Error>) -> Void) -> some View where C : Collection, C.Element : ReferenceFileDocument { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the priority by which a parent layout should apportion space to
    /// this child.
    ///
    /// Views typically have a default priority of `0` which causes space to be
    /// apportioned evenly to all sibling views. Raising a view's layout
    /// priority encourages the higher priority view to shrink later when the
    /// group is shrunk and stretch sooner when the group is stretched.
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        HStack {
    ///            Text("This is a moderately long string.")
    ///                .font(.largeTitle)
    ///                .border(Color.gray)
    ///
    ///            Spacer()
    ///
    ///            Text("This is a higher priority string.")
    ///                .font(.largeTitle)
    ///                .layoutPriority(1)
    ///                .border(Color.gray)
    ///        }
    ///    }
    /// }
    /// ```
    ///
    /// In the example above, the first `Text` element has the default
    /// priority `0` which causes its view to shrink dramatically due to the
    /// higher priority of the second `Text` element, even though all of their
    /// other attributes (font, font size and character count) are the same.
    ///
    /// ![A screenshot showing twoText views different layout
    /// priorities.](SwiftUI-View-layoutPriority.png)
    ///
    /// A parent layout offers the child views with the highest layout priority
    /// all the space offered to the parent minus the minimum space required for
    /// all its lower-priority children.
    ///
    /// - Parameter value: The priority by which a parent layout apportions
    ///   space to the child.
    @inlinable public func layoutPriority(_ value: Double) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Sets the style for text fields within this view.
    ///
    /// [[textfield-style]]
    public func textFieldStyle<S>(_ style: S) -> some View where S : TextFieldStyle { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Mask one view on top of another.
    ///
    /// Applying the `mask(_:)` modifier will make the modified view fully transparent, except for those pixels which overlap with the masked view.
    ///
    /// For example, without a mask, the following view renders as a normal rectangle:
    ///
    /// ![Rectangle Example](rounded-rectangle.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 10)
    ///             .fill(LinearGradient(
    ///                     gradient: Gradient(colors: [.green, .blue, .purple]),
    ///                     startPoint: .leading,
    ///                     endPoint: .trailing))
    ///             .padding()
    ///     }
    /// }
    /// ```
    ///
    /// Now if we apply a mask on a text view, we get the following result:
    ///
    /// ![Mask Example](mask-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         RoundedRectangle(cornerRadius: 10)
    ///             .fill(LinearGradient(
    ///                     gradient: Gradient(colors: [.green, .blue, .purple]),
    ///                     startPoint: .leading,
    ///                     endPoint: .trailing))
    ///             .mask(TextView())
    ///             .padding()
    ///     }
    /// }
    ///
    /// struct TextView: View {
    ///     var body: some View {
    ///         Text("Bananas are our favorite fruit.").font(.title).fontWeight(.bold)
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter mask: The view whose alpha the rendering system applies to
    ///   the specified view.
    @inlinable public func mask<Mask>(_ mask: Mask) -> some View where Mask : View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Configures the view's title for purposes of navigation.
    ///
    /// [[navigation-title]]
    ///
    /// A view's navigation title is used to visually display
    /// the current navigation state of an interface.
    /// On iOS and watchOS, when a view is navigated to inside
    /// of a navigation view, that view's title is displayed
    /// in the navigation bar. On iPadOS, the primary destination's
    /// navigation title is reflected as the window's title in the
    /// App Switcher. Similarly on macOS, the primary destination's title
    /// is used as the window title in the titlebar, Windows menu
    /// and Mission Control.
    ///
    /// - Parameter title: The title to display.
    public func navigationTitle(_ title: Text) -> some View { }


    /// Configures the view's title for purposes of navigation,
    /// using a localized string.
    ///
    /// [[navigation-title]]
    ///
    /// A view's navigation title is used to visually display
    /// the current navigation state of an interface.
    /// On iOS and watchOS, when a view is navigated to inside
    /// of a navigation view, that view's title is displayed
    /// in the navigation bar. On iPadOS, the primary destination's
    /// navigation title is reflected as the window's title in the
    /// App Switcher. Similarly on macOS, the primary destination's title
    /// is used as the window title in the titlebar, Windows menu
    /// and Mission Control.
    ///
    /// - Parameter titleKey: The key to a localized string to display.
    public func navigationTitle(_ titleKey: LocalizedStringKey) -> some View { }


    /// Configures the view's title for purposes of navigation, using a string.
    ///
    /// [[navigation-title]]
    ///
    /// A view's navigation title is used to visually display
    /// the current navigation state of an interface.
    /// On iOS and watchOS, when a view is navigated to inside
    /// of a navigation view, that view's title is displayed
    /// in the navigation bar. On iPadOS, the primary destination's
    /// navigation title is reflected as the window's title in the
    /// App Switcher. Similarly on macOS, the primary destination's title
    /// is used as the window title in the titlebar, Windows menu
    /// and Mission Control.
    ///
    /// - Parameter title: The string to display.
    public func navigationTitle<S>(_ title: S) -> some View where S : StringProtocol { }

}

@available(iOS 14.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Configures the title display mode for this view.
    ///
    /// [[navigation-title-display-mode]]
    ///
    /// - Parameter displayMode: The style to use for displaying the title.
    public func navigationBarTitleDisplayMode(_ displayMode: NavigationBarItem.TitleDisplayMode) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Adds an accessibility adjustable action to the view.
    public func accessibilityAdjustableAction(_ handler: @escaping (AccessibilityAdjustmentDirection) -> Void) -> ModifiedContent<Self, AccessibilityAttachmentModifier> { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// The default store used by `AppStorage` contained within the view.
    ///
    /// If unspecified, the default store for a view hierarchy is
    /// `UserDefaults.standard`, but can be set a to a custom one. For example,
    /// sharing defaults between an app and an extension can override the
    /// default store to one created with `UserDefaults.init(suiteName:_)`.
    ///
    /// - Parameter store: The user defaults to use as the default
    ///   store for `AppStorage`.
    public func defaultAppStorage(_ store: UserDefaults) -> some View { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Creates a drop-zone for drag & drop contents.
    ///
    /// `onDrop` modifies a view such that contents can be dropped there in a drag-and-drop operation. The dropped contents are handled with a specified closure.
    ///
    /// ### Basic Usage
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-1.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var text: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(text)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { _ in
    ///                     self.text = "Dropped My Bananas 🍌🍌!"
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Using `NSItemProvider` with `onDrop`
    /// `NSItemProvider` is a class that holds data on the dragged contents.
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-2.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var bananas: String = "🍌🍌"
    ///     @State var apples: String = "🍏🍏"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(bananas)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.bananas as NSString) }
    ///
    ///             Text(apples)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.apples as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { itemProvider in
    ///                     // Load the first item in the NSItemProvider array
    ///                     if let item = itemProvider.first {
    ///                         item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                             // Cast NSSecureCoding to Ddata
    ///                             if let data = text as? Data {
    ///                                 // Extract string from data
    ///                                 let droppedString = String(decoding: data, as: UTF8.self)
    ///
    ///                                 if droppedString == bananas {
    ///                                     bananas += "🍌"
    ///                                 } else if droppedString == apples {
    ///                                     apples += "🍏"
    ///                                 }
    ///                             }
    ///                         }
    ///                     }
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Paremeters:
    ///     - of: The type you want to drop. Accepts an array of `UTType`, which can include "Uniform Resource Identifiers", or URI for short. Common URI include "public.image", "public.text", "public.file-url", and "public.url".
    ///     - isTargeted: A binding to communicate when a user is dragging over this region.
    ///     - perform: The action to perform on drop. `perform` accepts an `NSItemProvider` and returns a boolean.
    public func onDrop(of supportedContentTypes: [UTType], isTargeted: Binding<Bool>?, perform action: @escaping ([NSItemProvider]) -> Bool) -> some View { }


    /// Creates a drop-zone for drag & drop contents and provides drop location data.
    ///
    /// `onDrop` modifies a view such that contents can be dropped there in a drag-and-drop operation. The dropped contents are handled with a specified closure. That closure includes a `CGPoint` of where the dragged contents were dropped.
    ///
    /// ### Basic Usage
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-1.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var text: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(text)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { _, _ in
    ///                     self.text = "Dropped My Bananas 🍌🍌!"
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Using `NSItemProvider` with `onDrop`
    /// `NSItemProvider` is a class that holds data on the dragged contents.
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-2.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var bananas: String = "🍌🍌"
    ///     @State var apples: String = "🍏🍏"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(bananas)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.bananas as NSString) }
    ///
    ///             Text(apples)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.apples as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { itemProvider, _ in
    ///                     // Load the first item in the NSItemProvider array
    ///                     if let item = itemProvider.first {
    ///                         item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                             // Cast NSSecureCoding to Ddata
    ///                             if let data = text as? Data {
    ///                                 // Extract string from data
    ///                                 let droppedString = String(decoding: data, as: UTF8.self)
    ///
    ///                                 if droppedString == bananas {
    ///                                     bananas += "🍌"
    ///                                 } else if droppedString == apples {
    ///                                     apples += "🍏"
    ///                                 }
    ///                             }
    ///                         }
    ///                     }
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Using `CGPoint` with `onDrop`
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-3.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var topBananas: String = "🍌🍌"
    ///     @State var bottomBananas: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         GeometryReader { geometry in
    ///             VStack {
    ///                 Spacer()
    ///
    ///                 HStack {
    ///                     Text(topBananas)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider() }
    ///                 }
    ///
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], isTargeted: nil, perform: { _, location in
    ///
    ///                         // If dropped on the bottom half the rectangle, add to bottom.
    ///                         if location.y > geometry.size.height/2 {
    ///                             bottomBananas += "🍌"
    ///                         } else {
    ///                             // Else, add to top
    ///                             topBananas += "🍌"
    ///                         }
    ///
    ///                         return true
    ///                     })
    ///
    ///                 HStack {
    ///                     Text(bottomBananas)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider() }
    ///                 }
    ///
    ///                 Spacer()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    ///
    /// - Paremeters:
    ///     - of: The type you want to drop. Accepts an array of "Uniform Resource Identifiers", or URI for short. Common URI include "public.image", "public.text", "public.file-url", and "public.url".
    ///     - isTargeted: A binding to communicate when a user is dragging over this region.
    ///     - perform: The action to perform on drop. `perform` accepts an `NSItemProvider` and a CGPoint which represents the drop location. It returns a boolean.
    public func onDrop(of supportedContentTypes: [UTType], isTargeted: Binding<Bool>?, perform action: @escaping ([NSItemProvider], CGPoint) -> Bool) -> some View { }


    /// Creates a drop-zone for drag & drop contents and provides drop location data.
    ///
    /// `onDrop` modifies a view such that contents can be dropped there in a drag-and-drop operation. The dropped contents are handled with a struct that conforms to the `DropDelegate` protocol.
    ///
    /// #### Conform to DropDelegate
    /// Implement `DropDelegate/performDrop(info:)` to create a structure that conforms to `DropDelegate`.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-1.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var text: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             // Text to drag
    ///             Text(text)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
    ///
    ///             // Area to drop
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["text"], delegate: MyDropDelegate(text: $text))
    ///         }
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var text: String
    ///
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         self.text = "Dropped My Bananas 🍌🍌!"
    ///         return true
    ///     }
    /// }
    /// ```
    ///
    /// ### Fully Featured `DropDelegate`
    /// Utalize `DropDelegate`s optional functions to provide additional behavior.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-3.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var backgroundColor: Color = .black
    ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
    ///
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 ForEach(self.fruits, id: \.self, content: { fruit in
    ///                     Text(fruit)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
    ///                 })
    ///             }
    ///
    ///             HStack {
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .fill(backgroundColor)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
    ///             }
    ///         }
    ///
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var color: Color
    ///
    ///     // Drop entered called
    ///     func dropEntered(info: DropInfo) {
    ///         // Change color if color was previously black
    ///         self.color = (self.color == .black) ? .gray : self.color
    ///     }
    ///
    ///     // Drop entered called
    ///     func dropExited(info: DropInfo) {
    ///         self.color = .init(white: 0.40)
    ///     }
    ///
    ///     // Drop has been updated
    ///     func dropUpdated(info: DropInfo) -> DropProposal? {
    ///         // Don't allow more items to be dropped if a Banana was dropped
    ///         if self.color == .yellow {
    ///             return DropProposal(operation: .forbidden)
    ///         } else {
    ///             return nil
    ///         }
    ///     }
    ///
    ///     // This function is executed when the user "drops" their object
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         // Check if there's an array of items with the URI "public.text" in the DropInfo
    ///         if let item = info.itemProviders(for: ["public.text"]).first {
    ///             //  Load the item
    ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                 //  Cast NSSecureCoding to Ddata
    ///                 if let data = text as? Data {
    ///                     //  Extract string from data
    ///                     let inputStr = String(decoding: data, as: UTF8.self)
    ///
    ///                     //  Conditionally change color given text string
    ///                     if inputStr == "🍌🍌" {
    ///                         self.color = .yellow
    ///                     } else if inputStr == "🍏🍏" {
    ///                         self.color = .green
    ///                     } else if inputStr == "🍑🍑" {
    ///                         self.color = .pink
    ///                     } else {
    ///                         self.color = .gray
    ///                     }
    ///                 }
    ///             }
    ///         } else {
    ///             //  If no text was received in our drop, return false
    ///             return false
    ///         }
    ///
    ///         return true
    ///     }
    /// }
    /// ```
    ///
    /// This example uses `DropDelegate/dropUpdated(info:)-72cd3` to prevent fruits from being dropped if the background is yellow.
    ///
    /// The example uses `DropDelegate/dropEntered(info:)-525fa` to change the color the first time a user drags over the drop zone.
    ///
    /// Finally, when a user drags out of the view, `DropDelegate/dropExited(info:)-3d540` changes the background color to a dark gray.
    ///
    /// Note: if the user deselects their dragged object while over the drop zone, `DropDelegate/dropExited(info:)-3d540` will **not** be called. `DropDelegate/dropExited(info:)-3d540` is only called when the user explicitly drags their dragged object **out** of the drop zone.
    ///
    ///
    /// - Paremeters:
    ///     - of: The type you want to drop. Accepts an array of UTType which include "Uniform Resource Identifiers", or URI for short. Common URI include "public.image", "public.text", "public.file-url", and "public.url".
    ///     - delegate: An object that conforms to  `DropDelegate`.
    public func onDrop(of supportedContentTypes: [UTType], delegate: DropDelegate) -> some View { }

}

@available(iOS, introduced: 13.4, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
@available(macOS, introduced: 10.15, deprecated: 100000.0, message: "Provide `UTType`s as the `supportedContentTypes` instead.")
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Creates a drop-zone for drag & drop contents.
    ///
    /// `onDrop` modifies a view such that contents can be dropped there in a drag-and-drop operation. The dropped contents are handled with a specified closure.
    ///
    /// ### Basic Usage
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-1.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var text: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(text)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { _ in
    ///                     self.text = "Dropped My Bananas 🍌🍌!"
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Using `NSItemProvider` with `onDrop`
    /// `NSItemProvider` is a class that holds data on the dragged contents.
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-2.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var bananas: String = "🍌🍌"
    ///     @State var apples: String = "🍏🍏"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(bananas)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.bananas as NSString) }
    ///
    ///             Text(apples)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.apples as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { itemProvider in
    ///                     //  Load the first item in the NSItemProvider array
    ///                     if let item = itemProvider.first {
    ///                         item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                             //  Cast NSSecureCoding to Ddata
    ///                             if let data = text as? Data {
    ///                                 //  Extract string from data
    ///                                 let droppedString = String(decoding: data, as: UTF8.self)
    ///
    ///                                 if droppedString == bananas {
    ///                                     bananas += "🍌"
    ///                                 } else if droppedString == apples {
    ///                                     apples += "🍏"
    ///                                 }
    ///                             }
    ///                         }
    ///                     }
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Paremeters:
    ///     - of: The type you want to drop. Accepts an array of `UTType`, which can include "Uniform Resource Identifiers", or URI for short. Common URI include "public.image", "public.text", "public.file-url", and "public.url".
    ///     - isTargeted: A binding to communicate when a user is dragging over this region.
    ///     - perform: The action to perform on drop. `perform` accepts an `NSItemProvider` and returns a boolean.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func onDrop(of supportedTypes: [String], isTargeted: Binding<Bool>?, perform action: @escaping ([NSItemProvider]) -> Bool) -> some View { }


    /// Creates a drop-zone for drag & drop contents and provides drop location data.
    ///
    /// `onDrop` modifies a view such that contents can be dropped there in a drag-and-drop operation. The dropped contents are handled with a specified closure. That closure includes a `CGPoint` of where the dragged contents were dropped.
    ///
    /// ### Basic Usage
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-1.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var text: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(text)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { _, _ in
    ///                     self.text = "Dropped My Bananas 🍌🍌!"
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Using `NSItemProvider` with `onDrop`
    /// `NSItemProvider` is a class that holds data on the dragged contents.
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-2.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var bananas: String = "🍌🍌"
    ///     @State var apples: String = "🍏🍏"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             Text(bananas)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.bananas as NSString) }
    ///
    ///             Text(apples)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.apples as NSString) }
    ///
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["public.text"], isTargeted: nil, perform: { itemProvider, _ in
    ///                     //  Load the first item in the NSItemProvider array
    ///                     if let item = itemProvider.first {
    ///                         item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                             //  Cast NSSecureCoding to Ddata
    ///                             if let data = text as? Data {
    ///                                 //  Extract string from data
    ///                                 let droppedString = String(decoding: data, as: UTF8.self)
    ///
    ///                                 if droppedString == bananas {
    ///                                     bananas += "🍌"
    ///                                 } else if droppedString == apples {
    ///                                     apples += "🍏"
    ///                                 }
    ///                             }
    ///                         }
    ///                     }
    ///                     return true
    ///                 })
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// ### Using `CGPoint` with `onDrop`
    ///
    /// ![Drop View](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/ondrop-example-3.gif)
    ///
    /// ```
    /// struct ContentView: View {
    ///     @State var topBananas: String = "🍌🍌"
    ///     @State var bottomBananas: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         GeometryReader { geometry in
    ///             VStack {
    ///                 Spacer()
    ///
    ///                 HStack {
    ///                     Text(topBananas)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider() }
    ///                 }
    ///
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], isTargeted: nil, perform: { _, location in
    ///
    ///                         //  If dropped on the bottom half the rectangle, add to bottom.
    ///                         if location.y > geometry.size.height/2 {
    ///                             bottomBananas += "🍌"
    ///                         } else {
    ///                             //  Else, add to top
    ///                             topBananas += "🍌"
    ///                         }
    ///
    ///                         return true
    ///                     })
    ///
    ///                 HStack {
    ///                     Text(bottomBananas)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider() }
    ///                 }
    ///
    ///                 Spacer()
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    ///
    ///
    /// - Paremeters:
    ///     - of: The type you want to drop. Accepts an array of "Uniform Resource Identifiers", or URI for short. Common URI include "public.image", "public.text", "public.file-url", and "public.url".
    ///     - isTargeted: A binding to communicate when a user is dragging over this region.
    ///     - perform: The action to perform on drop. `perform` accepts an `NSItemProvider` and a CGPoint which represents the drop location. It returns a boolean.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func onDrop(of supportedTypes: [String], isTargeted: Binding<Bool>?, perform action: @escaping ([NSItemProvider], CGPoint) -> Bool) -> some View { }


    /// Creates a drop-zone for drag & drop contents and provides drop location data.
    ///
    /// `onDrop` modifies a view such that contents can be dropped there in a drag-and-drop operation. The dropped contents are handled with a struct that conforms to the `DropDelegate` protocol.
    ///
    /// #### Conform to DropDelegate
    /// Implement `DropDelegate/performDrop(info:)` to create a structure that conforms to `DropDelegate`.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-1.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var text: String = "🍌🍌"
    ///
    ///     var body: some View {
    ///         HStack {
    ///             //  Text to drag
    ///             Text(text)
    ///                 .font(.title)
    ///                 .onDrag{ return NSItemProvider(object: self.text as NSString) }
    ///
    ///             //  Area to drop
    ///             RoundedRectangle(cornerRadius: 10)
    ///                 .frame(width: 150, height: 150)
    ///                 .onDrop(of: ["text"], delegate: MyDropDelegate(text: $text))
    ///         }
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var text: String
    ///
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         self.text = "Dropped My Bananas 🍌🍌!"
    ///         return true
    ///     }
    /// }
    /// ```
    ///
    /// ### Fully Featured `DropDelegate`
    /// Utalize `DropDelegate`s optional functions to provide additional behavior.
    ///
    /// ![Simple Drop](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/dropdelegate-example-3.gif)
    ///
    /// ```
    /// struct ExampleView: View {
    ///     @State var backgroundColor: Color = .black
    ///     let fruits: [String] = ["🍌🍌", "🍏🍏", "🍑🍑"]
    ///
    ///     var body: some View {
    ///         VStack {
    ///             HStack {
    ///                 ForEach(self.fruits, id: \.self, content: { fruit in
    ///                     Text(fruit)
    ///                         .font(.title)
    ///                         .onDrag{ return NSItemProvider(object: fruit as NSString) }
    ///                 })
    ///             }
    ///
    ///             HStack {
    ///                 RoundedRectangle(cornerRadius: 10)
    ///                     .fill(backgroundColor)
    ///                     .frame(width: 150, height: 150)
    ///                     .onDrop(of: ["public.text"], delegate: MyDropDelegate(color: $backgroundColor))
    ///             }
    ///         }
    ///
    ///     }
    /// }
    ///
    /// struct MyDropDelegate: DropDelegate {
    ///     @Binding var color: Color
    ///
    ///     //  Drop entered called
    ///     func dropEntered(info: DropInfo) {
    ///         //  Change color if color was previously black
    ///         self.color = (self.color == .black) ? .gray : self.color
    ///     }
    ///
    ///     //  Drop entered called
    ///     func dropExited(info: DropInfo) {
    ///         self.color = .init(white: 0.40)
    ///     }
    ///
    ///     //  Drop has been updated
    ///     func dropUpdated(info: DropInfo) -> DropProposal? {
    ///         ///  Don't allow more items to be dropped if a Banana was dropped
    ///         if self.color == .yellow {
    ///             return DropProposal(operation: .forbidden)
    ///         } else {
    ///             return nil
    ///         }
    ///     }
    ///
    ///     //  This function is executed when the user "drops" their object
    ///     func performDrop(info: DropInfo) -> Bool {
    ///         //  Check if there's an array of items with the URI "public.text" in the DropInfo
    ///         if let item = info.itemProviders(for: ["public.text"]).first {
    ///             //  Load the item
    ///             item.loadItem(forTypeIdentifier: "public.text", options: nil) { (text, err) in
    ///                 //  Cast NSSecureCoding to Ddata
    ///                 if let data = text as? Data {
    ///                     //  Extract string from data
    ///                     let inputStr = String(decoding: data, as: UTF8.self)
    ///
    ///                     //  Conditionally change color given text string
    ///                     if inputStr == "🍌🍌" {
    ///                         self.color = .yellow
    ///                     } else if inputStr == "🍏🍏" {
    ///                         self.color = .green
    ///                     } else if inputStr == "🍑🍑" {
    ///                         self.color = .pink
    ///                     } else {
    ///                         self.color = .gray
    ///                     }
    ///                 }
    ///             }
    ///         } else {
    ///             //  If no text was received in our drop, return false
    ///             return false
    ///         }
    ///
    ///         return true
    ///     }
    /// }
    /// ```
    ///
    /// This example uses `DropDelegate/dropUpdated(info:)-72cd3` to prevent fruits from being dropped if the background is yellow.
    ///
    /// The example uses `DropDelegate/dropEntered(info:)-525fa` to change the color the first time a user drags over the drop zone.
    ///
    /// Finally, when a user drags out of the view, `DropDelegate/dropExited(info:)-3d540` changes the background color to a dark gray.
    ///
    /// Note: if the user deselects their dragged object while over the drop zone, `DropDelegate/dropExited(info:)-3d540` will **not** be called. `DropDelegate/dropExited(info:)-3d540` is only called when the user explicitly drags their dragged object **out** of the drop zone.
    ///
    ///
    /// - Paremeters:
    ///     - of: The type you want to drop. Accepts an array of UTType which include "Uniform Resource Identifiers", or URI for short. Common URI include "public.image", "public.text", "public.file-url", and "public.url".
    ///     - delegate: An object that conforms to  `DropDelegate`.
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func onDrop(of supportedTypes: [String], delegate: DropDelegate) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Applies a projection transformation to this view's rendered output.
    ///
    /// Use `projectionEffect(_:)` to apply a 3D transformation to the view.
    ///
    /// The example below rotates the text 30˚ around the `z` axis, which is the
    /// axis pointing out of the screen:
    ///
    ///     // This transform represents a 30˚ rotation around the z axis.
    ///     let transform = CATransform3DMakeRotation(
    ///         -30 * (.pi / 180), 0.0, 0.0, 1.0)
    ///
    ///     Text("Projection effects using transforms")
    ///         .projectionEffect(.init(transform))
    ///         .border(Color.gray)
    ///
    /// ![A screenshot showing text rotated 30 degrees around the axis pointing
    /// out of the screen.](SwiftUI-View-projectionEffect.png)
    ///
    /// - Parameter transform: A `ProjectionTransform` to apply to the view.
    @inlinable public func projectionEffect(_ transform: ProjectionTransform) -> some View { }

}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension View {

    /// Adds help text to a view using a localized string that you provide.
    ///
    /// Adding help to a view configures the view's accessibility hint and
    /// its tooltip ("help tag") on macOS.
    ///
    /// For more information on using help tags, see [Help]
    /// (https://developer.apple.com/design/human-interface-guidelines/macos/user-interaction/help/)
    /// in the macOS Human Interface Guidelines.
    ///
    ///     Button(action: composeMessage) {
    ///         Image(systemName: "square.and.pencil")
    ///     }
    ///     .help("Compose a new message")
    ///
    /// - Parameter textKey: The key for the localized text to use as help.
    public func help(_ textKey: LocalizedStringKey) -> some View { }


    /// Adds help text to a view using a text view that you provide.
    ///
    /// Adding help to a view configures the view's accessibility hint and
    /// its tooltip ("help tag") on macOS.
    ///
    /// For more information on using help tags, see [Help]
    /// (https://developer.apple.com/design/human-interface-guidelines/macos/user-interaction/help/)
    /// in the macOS Human Interface Guidelines.
    ///
    ///     Slider("Opacity", value: $selectedShape.opacity)
    ///         .help(Text("Adjust the opacity of the selected \(selectedShape.name)"))
    ///
    /// - Parameter text: The Text view to use as help.
    public func help(_ text: Text) -> some View { }


    /// Adds help text to a view using a string that you provide.
    ///
    /// Adding help to a view configures the view's accessibility hint and
    /// its tooltip ("help tag") on macOS.
    ///
    /// For more information on using help tags, see [Help]
    /// (https://developer.apple.com/design/human-interface-guidelines/macos/user-interaction/help/)
    /// in the macOS Human Interface Guidelines.
    ///
    ///     Image(systemName: "pin.circle")
    ///         .foregroundColor(pointOfInterest.tintColor)
    ///         .help(pointOfInterest.name)
    ///
    /// - Parameter text: The text to use as help.
    public func help<S>(_ text: S) -> some View where S : StringProtocol { }

}

@available(iOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
extension View {

    /// Sets the visibility of the status bar.
    ///
    /// Use `statusBar(hidden:)` to show or hide the status bar.
    ///
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    ///   status bar.
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public func statusBar(hidden: Bool) -> some View { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Supplies an `ObservableObject` to a view subhierachy.
    ///
    /// `environmentObject` supplies an `ObservableObject` to a view subhierachy. See ``ObservableObject`` for more on passing data between views.
    ///
    /// [[environment-objects]]
    ///
    /// - Parameter object: the object to store and make available to
    ///     the view's subhiearchy.
    @inlinable public func environmentObject<T>(_ object: T) -> some View where T : ObservableObject { }

}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension View {

    /// Presents an alert to the user.
    ///
    /// - Parameters:
    ///   - item: A binding to an optional source of truth for the alert.
    ///     When representing a non-`nil` item, the system uses `content` to
    ///     create an alert representation of the item.
    ///     If the identity changes, the system dismisses a
    ///     currently-presented alert and replace it by a new alert.
    ///   - content: A closure returning the alert to present.
    public func alert<Item>(item: Binding<Item?>, content: (Item) -> Alert) -> some View where Item : Identifiable { }


    /// Presents an alert to the user.
    ///
    /// - Parameters:
    ///   - isPresented: A binding to whether the alert should be shown.
    ///   - content: A closure returning the alert to present.
    public func alert(isPresented: Binding<Bool>, content: () -> Alert) -> some View { }

}

extension View {

    /// Sets the navigation bar items for this view.
    ///
    /// [[navigation-bar-items]]
    ///
    /// Use `navigationBarItems(leading:trailing:)` to add navigation bar items
    /// to the leading and trailing edges of the navigation bar for this view.
    ///
    /// This modifier only takes effect when this view is inside of and visible
    /// within a `NavigationView`.
    ///
    /// On iOS 14 and later, the leading item supplements a visible back button,
    /// instead of replacing it, by default. To hide the back button, use
    /// `View/navigationBarBackButtonHidden(_:)`.
    ///
    /// The example below adds buttons to the leading and trailing edges of
    /// the button area of the navigation view:
    ///
    /// ```
    /// struct ExampleView: View {
    ///     var body: some View {
    ///         NavigationView {
    ///             List {
    ///                 Text("Banana 🍌🍌")
    ///                 Text("Apple 🍎🍎")
    ///                 Text("Peach 🍑🍑")
    ///             }
    ///             .navigationBarTitle(Text("Today‘s Fruits"))
    ///             .navigationBarItems(leading:
    ///                 HStack {
    ///                     Button("Hours") {
    ///                         print("Hours tapped!")
    ///                     }
    ///                 }, trailing:
    ///                 HStack {
    ///                     Button("Favorites") {
    ///                         print("Favorites tapped!")
    ///                     }
    ///                     Button("Specials") {
    ///                         print("Specials tapped!")
    ///                     }
    ///                 }
    ///             )
    ///         }
    ///     }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - leading: A view that appears on the leading edge of the title.
    ///   - trailing: A view that appears on the trailing edge of the title.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public func navigationBarItems<L, T>(leading: L, trailing: T) -> some View where L : View, T : View { }


    /// Sets the navigation bar items for this view.
    ///
    /// [[navigation-bar-items]]
    ///
    /// Use `navigationBarItems(leading:)` to add navigation bar items to the
    /// leading edge of the navigation bar for this view.
    ///
    /// This modifier only takes effect when this view is inside of and visible
    /// within a `NavigationView`.
    ///
    /// On iOS 14 and later, the leading item supplements a visible back button,
    /// instead of replacing it, by default. To hide the back button, use
    /// `View/navigationBarBackButtonHidden(_:)`.
    ///
    /// The example below adds buttons to the leading edge of the button area
    /// of the navigation view:
    ///
    ///     struct FlavorView: View {
    ///         var body: some View {
    ///             NavigationView {
    ///                 List {
    ///                     Text("Chocolate")
    ///                     Text("Vanilla")
    ///                     Text("Strawberry")
    ///                 }
    ///                 .navigationBarTitle(Text("Today's Flavors"))
    ///                 .navigationBarItems(leading:
    ///                     HStack {
    ///                         Button("Hours") {
    ///                             print("Hours tapped!")
    ///                         }
    ///
    ///                         Button("Help") {
    ///                             print("Help tapped!")
    ///                         }
    ///                     }
    ///                 )
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter leading: A view that appears on the leading edge of the
    ///   title.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public func navigationBarItems<L>(leading: L) -> some View where L : View { }


    /// Configures the navigation bar items for this view.
    ///
    /// [[navigation-bar-items]]
    ///
    /// Use `navigationBarItems(trailing:)` to add navigation bar items to the
    /// trailing edge of the navigation bar for this view. This modifier only
    /// takes effect when this view is inside of and visible within a
    /// `NavigationView`.
    ///
    /// The example below adds buttons to the trailing edge of the button area
    /// of the navigation view:
    ///
    ///     struct FlavorView: View {
    ///         var body: some View {
    ///             NavigationView {
    ///                 List {
    ///                     Text("Chocolate")
    ///                     Text("Vanilla")
    ///                     Text("Strawberry")
    ///                 }
    ///                 .navigationBarTitle(Text("Today‘s Flavors"))
    ///                 .navigationBarItems(trailing:
    ///                     HStack {
    ///                         Button("Hours") {
    ///                             print("Hours tapped!")
    ///                         }
    ///
    ///                         Button("Help") {
    ///                             print("Help tapped!")
    ///                         }
    ///                     }
    ///                 )
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameter trailing: A view shown on the trailing edge of the title.
    @available(iOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(tvOS, introduced: 13.0, deprecated: 100000.0, message: "Use toolbar(_:) with navigationBarLeading or navigationBarTrailing placement")
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public func navigationBarItems<T>(trailing: T) -> some View where T : View { }

}

/// A custom parameter attribute that constructs views from closures.
///
/// You typically use `ViewBuilder` as a parameter attribute for child
/// view-producing closure parameters, allowing those closures to provide
/// multiple child views. For example, the following `contextMenu` function
/// accepts a closure that produces one or more views via the view builder.
///
///     func contextMenu<MenuItems : View>({}
///         @ViewBuilder menuItems: () -> MenuItems
///     ) -> some View
///
/// Clients of this function can use multiple-statement closures to provide
/// several child views, as shown in the following example:
///
///     myView.contextMenu {
///         Text("Cut")
///         Text("Copy")
///         Text("Paste")
///         if isSymbol {
///             Text("Jump to Definition")
///         }
///     }
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@_functionBuilder public struct ViewBuilder {

    /// Builds an empty view from a block containing no statements.
    public static func buildBlock() -> EmptyView { }

    /// Passes a single view written as a child view through unmodified.
    ///
    /// An example of a single view written as a child view is
    /// `{ Text("Hello") }`.
    public static func buildBlock<Content>(_ content: Content) -> Content where Content : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

    /// Provides support for “if” statements in multi-statement closures,
    /// producing an optional view that is visible only when the condition
    /// evaluates to `true`.
    public static func buildIf<Content>(_ content: Content?) -> Content? where Content : View { }

    /// Provides support for "if" statements in multi-statement closures,
    /// producing conditional content for the "then" branch.
    public static func buildEither<TrueContent, FalseContent>(first: TrueContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent : View, FalseContent : View { }

    /// Provides support for "if-else" statements in multi-statement closures,
    /// producing conditional content for the "else" branch.
    public static func buildEither<TrueContent, FalseContent>(second: FalseContent) -> _ConditionalContent<TrueContent, FalseContent> where TrueContent : View, FalseContent : View { }
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ViewBuilder {

    /// Provides support for "if" statements with `#available()` clauses in
    /// multi-statement closures, producing conditional content for the "then"
    /// branch, i.e. the conditionally-available branch.
    public static func buildLimitedAvailability<Content>(_ content: Content) -> AnyView where Content : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 2 views in a view builder.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> TupleView<(C0, C1)> where C0 : View, C1 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 3 views in a view builder.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> TupleView<(C0, C1, C2)> where C0 : View, C1 : View, C2 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 4 views in a view builder.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> TupleView<(C0, C1, C2, C3)> where C0 : View, C1 : View, C2 : View, C3 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 5 views in a view builder.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> TupleView<(C0, C1, C2, C3, C4)> where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 6 views in a view builder.
    public static func buildBlock<C0, C1, C2, C3, C4, C5>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5) -> TupleView<(C0, C1, C2, C3, C4, C5)> where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 7 views in a view builder.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6) -> TupleView<(C0, C1, C2, C3, C4, C5, C6)> where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 8 views in a view builder.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7) -> TupleView<(C0, C1, C2, C3, C4, C5, C6, C7)> where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View, C7 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 9 views in a view builder.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8) -> TupleView<(C0, C1, C2, C3, C4, C5, C6, C7, C8)> where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View, C7 : View, C8 : View { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewBuilder {

	/// Builds a tuple view for display from 10 views in a view builder.
    public static func buildBlock<C0, C1, C2, C3, C4, C5, C6, C7, C8, C9>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -> TupleView<(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)> where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View, C7 : View, C8 : View, C9 : View { }
}

/// A view's size and its alignment guides in its own coordinate space.
///
/// Most frequently used when working with alignment guides. See ``View/alignmentGuide(_:_:)`` for more
/// on how to apply ViewDimensions.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public struct ViewDimensions {

    /// The view's width.
    public var width: CGFloat { get }

    /// The view's height.
    public var height: CGFloat { get }

    /// Gets the value of the given horizontal guide.
    ///
    /// It will return the position of the horizontal alignment value you pass
    /// as a parameter. See ``HorizontalAlignment`` for all the potential input values.
    /// For example:
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        Text("🍌🍌")
    ///            .alignmentGuide(HorizontalAlignment.leading, computeValue: { ViewDimensions in
    ///                return ViewDimensions[HorizontalAlignment.leading]
    ///            })
    ///    }
    /// }
    /// ```
    public subscript(guide: HorizontalAlignment) -> CGFloat { get }

    /// Gets the value of the given vertical guide.
    ///
    /// It will return the position of the vertical alignment value you pass
    /// as a parameter. See ``VerticalAlignment`` for all the potential input values.
    /// For example:
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        Text("🍌🍌")
    ///            .alignmentGuide(VerticalAlignment.center, computeValue: { ViewDimensions in
    ///                return ViewDimensions[VerticalAlignment.center]
    ///            })
    ///    }
    /// }
    /// ```
    public subscript(guide: VerticalAlignment) -> CGFloat { get }

    /// Gets the explicit value of the given alignment guide in this view, or
    /// `nil` if no such value exists.
    ///
    /// For example:
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        Text("🍌🍌")
    ///            .alignmentGuide(HorizontalAlignment.leading, computeValue: { ViewDimensions in
    ///                return ViewDimensions[HorizontalAlignment.leading]
    ///            })
    ///    }
    /// }
    /// ```
    ///
    /// See ``HorizontalAlignment`` for all the potential input values.
    public subscript(explicit guide: HorizontalAlignment) -> CGFloat? { get }

    /// Gets the explicit value of the given alignment guide in this view, or
    /// `nil` if no such value exists.
    ///
    /// For example:
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        Text("🍌🍌")
    ///            .alignmentGuide(VerticalAlignment.leading, computeValue: { ViewDimensions in
    ///                return ViewDimensions[VerticalAlignment.leading]
    ///            })
    ///    }
    /// }
    /// ```
    ///
    /// See ``VerticalAlignment`` for all the potential input values.
    public subscript(explicit guide: VerticalAlignment) -> CGFloat? { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewDimensions : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ViewDimensions, rhs: ViewDimensions) -> Bool { }
}

/// A modifier that you apply to a view or another view modifier, producing a
/// new view.
///
/// Adopt the `ViewModifier` protocol when you want to create a reusable
/// modifier that you can apply to any view. The example below combines several
/// modifiers to create a new modifier that you can use to create blue caption
/// text surrounded by a rounded rectangle:
///
/// ![View modifier example 1](view-modifier-example-1.png)
///
/// ```
/// struct ExampleView: View {
///    var body: some View {
///        VStack {
///            Text("Text without blue border")
///            Text("Text with blue border")
///                .modifier(BorderedCaption())
///        }
///    }
/// }
///
/// struct BorderedCaption: ViewModifier {
///    func body(content: Content) -> some View {
///        content
///            .font(.caption2)
///            .padding(10)
///            .overlay(
///                RoundedRectangle(cornerRadius: 15)
///                    .stroke(lineWidth: 1)
///            )
///            .foregroundColor(Color.blue)
///    }
/// }
/// ```
///
/// You can apply `View/modifier(_:)` directly to a view, but a more common and
/// idiomatic approach uses `View/modifier(_:)` to define an extension to
/// `View` itself that incorporates the view modifier:
///
///     extension View {
///         func borderedCaption() -> some View {
///             modifier(BorderedCaption())
///         }
///     }
///
/// You can then apply the bordered caption to any view, similar to this:
///
///     struct BusView: View {
///         var body: some View {
///             Image(systemName: "bus")
///                 .resizable()
///                 .frame(width:50, height:50)
///             Text("Downtown Bus")
///                 .borderedCaption()
///         }
///     }
///
/// ![A screenshot showing the image of a bus with a caption reading
/// Downtown Bus. A view extension, using custom a modifier, renders the
///  caption in blue text surrounded by a rounded
///  rectangle.](SwiftUI-View-ViewModifier.png)
///
/// Note: The ``View/modifier(_:)`` only accepts a single modifier as a parameter.
/// In order to use multiple modifiers on a single view, see ``ViewModifier/concat(_:)``
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol ViewModifier { }
extension ViewModifier {

    /// The type of view representing the body.
    associatedtype Body : View

    /// Gets the current body of the caller.
    ///
    /// The `content` parameter is a proxy for the view that will have the modifier
    /// represented by `Self` applied to it. In simpler terms, `content` is the
    /// view that is being transformed. For example:
    ///
    /// ```
    /// struct BorderedCaption: ViewModifier {
    ///    func body(content: Content) -> some View {
    ///        content
    ///            .font(.caption2)
    ///            .padding(10)
    ///            .overlay(
    ///                RoundedRectangle(cornerRadius: 15)
    ///                    .stroke(lineWidth: 1)
    ///            )
    ///            .foregroundColor(Color.blue)
    ///    }
    /// }
    /// ```
    func body(content: Self.Content) -> Self.Body { }

    /// The content view type passed to `body()`.
    typealias Content
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewModifier where Self.Body == Never {

    /// Gets the current body of the caller.
    ///
    /// The `content` parameter is a proxy for the view that will have the modifier
    /// represented by `Self` applied to it. In simpler terms, `content` is the
    /// view that is being transformed. For example:
    ///
    /// ```
    /// struct BorderedCaption: ViewModifier {
    ///    func body(content: Content) -> some View {
    ///        content
    ///            .font(.caption2)
    ///            .padding(10)
    ///            .overlay(
    ///                RoundedRectangle(cornerRadius: 15)
    ///                    .stroke(lineWidth: 1)
    ///            )
    ///            .foregroundColor(Color.blue)
    ///    }
    /// }
    /// ```
    public func body(content: Self.Content) -> Self.Body { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewModifier {

    /// Returns a new modifier that is the result of concatenating
    /// `self` with `modifier`.
    ///
    /// This allows you to chain multiple custom modifiers on a view.
    /// The ``View/modifier(_:)`` only accepts a single modifier as a parameter, which
    /// is why concat is needed. For example:
    ///
    /// ![View modifier concat example 1](view-modifier-concat-example-1.png)
    ///
    /// ```
    /// struct ExampleView: View {
    ///    var body: some View {
    ///        VStack {
    ///            Text("Text without blue border and padded shadow")
    ///            Text("Text with blue border and padded shadow")
    ///                .modifier(BorderedCaption().concat(PaddedShadow()))
    ///        }
    ///    }
    /// }
    ///
    /// struct BorderedCaption: ViewModifier {
    ///    func body(content: Content) -> some View {
    ///        content
    ///            .font(.caption2)
    ///            .padding(10)
    ///            .overlay(
    ///                RoundedRectangle(cornerRadius: 15)
    ///                    .stroke(lineWidth: 1)
    ///            )
    ///            .foregroundColor(Color.blue)
    ///    }
    /// }
    ///
    /// struct PaddedShadow: ViewModifier {
    ///    func body(content: Content) -> some View {
    ///        content
    ///            .padding(50)
    ///            .shadow(color: .blue, radius: 10)
    ///    }
    /// }
    /// ```
    @inlinable public func concat<T>(_ modifier: T) -> ModifiedContent<Self, T> { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension ViewModifier {

    /// Returns a new version of the modifier that will apply the
    /// transaction mutation function `transform` to all transactions
    /// within the modifier.
    @inlinable public func transaction(_ transform: @escaping (inout Transaction) -> Void) -> some ViewModifier { }


    /// Returns a new version of the modifier that will apply
    /// `animation` to all animatable values within the modifier.
    @inlinable public func animation(_ animation: Animation?) -> some ViewModifier { }

}

/// A date style that displays components as columns in a scrollable wheel.
///
/// ![WheelDatePickerStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/date-pickerstyle-wheel-example-1.gif)
///
///
///      struct ExampleView: View {
///          @State var date: Date = Date()
///          var body: some View {
///              DatePicker("Date",selection: $date)
///                  .datePickerStyle(WheelDatePickerStyle())
///                  .padding()
///          }
///      }
///
///
@available(iOS 13.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct WheelDatePickerStyle : DatePickerStyle {

	/// Creates a wheel date picker style.
    public init() { }
}

/// A picker style that presents the options in a scrollable wheel that shows
/// the selected option and a few neighboring options.
///
/// ![WheelPickerStyle Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/pickerstyle-wheel-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     var fruits = ["Banana🍌🍌","Apple🍎🍎", "Peach🍑🍑"]
///     @State private var selectedFruit = 0
///
///     var body: some View {
///         VStack {
///             Picker(selection: $selectedFruit, label: Text("Select Favorite Fruit")) {
///                 ForEach(0..<fruits.count) {
///                     Text(self.fruits[$0])
///                 }
///             }
///             Text("Your Favorite Fruit: \(self.fruits[selectedFruit])")
///         }
///         .pickerStyle(WheelPickerStyle())
///     }
/// }
/// ```
///
/// Because most options aren't visible, organize them in a predictable order,
/// such as alphabetically.
///
/// [pickerstyle-wheel ->]
/// Your app can also use explicit tags to identify picker content.
///
/// ![Wheel Example 1](/picker-style-7.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var favoriteFruit: MyFruit = MyFruit.banana
///
///     var fruitName: String {
///         switch favoriteFruit{
///         case .apple:
///             return "Apple 🍎🍎"
///         case .banana:
///             return "Banana 🍌🍌"
///         case .peach:
///             return "Peach 🍑🍑"
///         }
///     }
///
///     var body: some View {
///         Text("My Favorite Fruit: \(fruitName)")
///
///         Picker("My Picker", selection: $favoriteFruit) {
///             Text("Banana 🍌🍌")
///                 .tag(MyFruit.banana)
///             Text("Apple 🍎🍎")
///                 .tag(MyFruit.apple)
///             Text("Peach 🍑🍑")
///                 .tag(MyFruit.peach)
///         }.pickerStyle(WheelPickerStyle())
///     }
/// }
/// ```
///
/// [<-]
///
/// To apply this style to a picker, or to a view that contains pickers, use the
/// `View/pickerStyle(_:)` modifier.
@available(iOS 13.0, watchOS 6.0, *)
@available(macOS, unavailable)
@available(tvOS, unavailable)
public struct WheelPickerStyle : PickerStyle {

    /// Sets the picker style to display an item wheel from which the user makes
    /// a selection.
    public init() { }
}

/// The configuration and content of a widget to display on the Home screen or
/// in Notification Center.
///
/// Widgets show glanceable and relevant content from your app right on the iOS
/// Home screen or in Notification Center on macOS. Users can add, configure, and
/// arrange widgets to suit their individual needs. You can provide multiple
/// types of widgets, each presenting a specific kind of information. When
/// users want more information, like to read the full article for a headline
/// or to see the details of a package delivery, the widget lets them get to
/// the information in your app quickly.
///
/// There are three key components to a widget:
///
/// * A configuration. This configuration determines whether the widget is configurable,
///   identifies the widget, and defines the SwiftUI views that show the
///   widget's content.
/// * A timeline provider that drives the process of updating the widget's view
///   over time.
/// * SwiftUI views used by WidgetKit to display the widget.
///
/// To add a widget to your app go to: `File -> New -> Target`. Name your widget "Banana Widget" to use code from this tutorial.
///
/// Next, from the options, select "Widget"
///
/// ![All options](widget-1.png)
///
/// Select "Widget".
///
/// ![Widget](widget-2.png)
///
/// Your widget can now be styled similar to a standard SwiftUI view. For example, modify `Banana_WidgetEntryView` to create:
///
/// ![Widget](widget-3.png)
///
/// ```
/// struct Banana_WidgetEntryView : View {
///     var entry: Provider.Entry
///
///     var body: some View {
///         RoundedRectangle(cornerRadius: 10)
///             .fill(Color.yellow)
///             .overlay(Text("🍌🍌"))
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol Widget{ }
extension Widget {

    /// The type of configuration representing the content of the widget.
    ///
    /// When you create a custom widget, Swift infers this type from your
    /// implementation of the required `Widget/body-swift.property` property.
    associatedtype Body : WidgetConfiguration

    /// Creates a widget using `body` as its content.
    init() { }

    /// The content and behavior of the widget.
    ///
    /// For any widgets that you create, provide a computed `body` property that
    /// defines the widget as a composition of SwiftUI views.
    ///
    /// Swift infers the widget's `SwiftUI/Scene/Body-swift.associatedtype`
    /// associated type based on the contents of the `body` property.
    var body: Self.Body { get }
}

/// A container used to expose multiple widgets from a single widget extension.
///
/// To support multiple types of widgets, add the `@main` attribute to a
/// structure that conforms to `WidgetBundle`. For example, a game might have
/// one widget to display summary information about the game and a second
/// widget to display detailed information about individual characters.
///
///     @main
///     struct GameWidgets: WidgetBundle {
///        var body: some Widget {
///            GameStatusWidget()
///            CharacterDetailWidget()
///        }
///     }
///
/// Learn more about how to create a widget via the `Widget` documentation.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol WidgetBundle{ }
extension WidgetBundle {

    /// The type of widget that represents the content of the bundle.
    ///
    /// When you support more than one widget, Swift infers this type from your
    /// implementation of the required `WidgetBundle/body-swift.property`
    /// property.
    associatedtype Body : Widget

    /// Creates a widget bundle using the bundle's body as its content.
    init() { }

    /// Declares the group of widgets that an app supports.
    ///
    /// The order that the widgets appear in this property determines the order
    /// they are shown to the user when adding a widget. The following example
    /// shows how to use a widget bundle builder to define a body showing
    /// a game status widget first and a character detail widget second:
    ///
    ///     @main
    ///     struct GameWidgets: WidgetBundle {
    ///        var body: some Widget {
    ///            GameStatusWidget()
    ///            CharacterDetailWidget()
    ///        }
    ///     }
    ///
    @WidgetBundleBuilder var body: Self.Body { get }
}

/// A custom attribute that constructs a widget bundle's body.
///
/// Use the `@WidgetBundleBuilder` attribute to group multiple widgets listed
/// in the `WidgetBundle/body-swift.property` property of a widget bundle.
/// For example, the following code defines a widget bundle that consists of
/// two widgets.
///
///     @main
///     struct GameWidgets: WidgetBundle {
///        @WidgetBundleBuilder
///        var body: some Widget {
///            GameStatusWidget()
///            CharacterDetailWidget()
///        }
///     }
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_functionBuilder public struct WidgetBundleBuilder {

    /// Builds an empty Widget from an block containing no statements, `{ }`.
    public static func buildBlock() -> some Widget { }


    /// Builds a single Widget written as a child view (e..g, `{ MyWidget() }`)
    /// through unmodified.
    public static func buildBlock<Content>(_ content: Content) -> some Widget where Content : Widget { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension WidgetBundleBuilder {

	/// Builds a new widget from a block containing 2 widgets.
    public static func buildBlock<C0, C1>(_ c0: C0, _ c1: C1) -> some Widget where C0 : Widget, C1 : Widget { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension WidgetBundleBuilder {

	/// Builds a new widget from a block containing 3 widgets.
    public static func buildBlock<C0, C1, C2>(_ c0: C0, _ c1: C1, _ c2: C2) -> some Widget where C0 : Widget, C1 : Widget, C2 : Widget { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension WidgetBundleBuilder {

	/// Builds a new widget from a block containing 4 widgets.
    public static func buildBlock<C0, C1, C2, C3>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3) -> some Widget where C0 : Widget, C1 : Widget, C2 : Widget, C3 : Widget { }

}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension WidgetBundleBuilder {

	/// Builds a new widget from a block containing 5 widgets.
    public static func buildBlock<C0, C1, C2, C3, C4>(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4) -> some Widget where C0 : Widget, C1 : Widget, C2 : Widget, C3 : Widget, C4 : Widget { }

}

/// A type that describes a widget's content.
@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol WidgetConfiguration{ }
extension WidgetConfiguration {

    /// The type of widget configuration representing the body of
    /// this configuration.
    ///
    /// When you create a custom widget, Swift infers this type from your
    /// implementation of the required `body` property.
    associatedtype Body : WidgetConfiguration

    /// The content and behavior of this widget.
    var body: Self.Body { get }
}

/// `WindowGroup` is the default `Scene` type in SwiftUI.
///
/// Use a `WindowGroup` to contain the SwiftUI view hierarchy of your app.
///
/// ### Usage
///
/// ```
/// @main
/// struct MyApp: SwiftUI.App {
///     var body: some Scene {
///         WindowGroup {
///             Text("Bananas")
///         }
///     }
/// }
/// ```
///
/// Note:
///
/// - The default implementation of a `WindowGroup` allows multiple instances of the window to be created (either using ⌘N , or the "Show Tab Bar" command).
/// - Each instance of a window created from a window group contains the same SwiftUI hierarchy, but maintains an independent state. That means if the user creates two instances of your app's window, each window will maintain its own separate (independent) state, unaffected by what the user does on another window of your app.
///
/// ### Adding a title to a window
///
/// On macOS, a window's title is usually displayed in a window's title bar. A window's title bar contains a centered text item to display the window's title.
///
/// Use `WindowGroup/init(_:content)` to title a window. For example:
///
/// ````
/// @main
/// struct MyApp: App {
///     var body: some Scene {
///         WindowGroup("Fruit App") {
///             Text("Bananas")
///         }
///     }
/// }
/// ````
///
/// Note: The system may use the provided window title as a part of some default window command names. For example, the "New Window" command would become "New Fruit App Window".
/// [window-commands ->]
/// ### Adding commands to a window group
///
/// On macOS, a window can provide a set of contextual commands as menu items in the menu bar. To add a command menu to a `WindowGroup`, use `Scene/commands(_:)`.
///
/// For example:
///
/// ```
/// @main
/// struct MyApp: App {
///     var body: some Scene {
///         WindowGroup {
///             Text("Bananas")
///         }
///         .commands {
///             CommandMenu("Some Commands") {
///                 Text("A Command")
///             }
///         }
///     }
/// }
/// ```
/// [<-]
/// ### Disabling creating multiple window instances
///
/// Currently, SwiftUI offers no canonical way to disable the user from creating multiple instances of a window from a `WindowGroup` scene. This can be done in two ways:
///
/// - Using the "New Window" (⌘N) command to create a new window instance
/// - Using the "Show Tab Bar" command, and creating a new tab containing a new window instance
///
/// #### Disabling the "New Window" command
///
/// The "New Window" (⌘N) command can be disabled by replacing the "New Item" command group with an empty command group.
///
/// ```
/// @main
/// struct MyApp: App {
///     var body: some Scene {
///         WindowGroup {
///             Text("Bananas")
///         }
///         .commands {
///             CommandGroup(replacing: .newItem, addition: { })
///         }
///     }
/// }
/// ```
///
/// Caveat: This does not currently work on macCatalyst (as of Big Sur 11.2).
///
/// #### Disabling the "Show Tab Bar" command
///
/// To disable the "Show Tab Bar" command, use `NSApplication` to iterate over your app's windows at launch and set each window's `tabbingMode` to `.disallowed`.
///
/// For example:
///
/// ```
/// @main
/// struct MyApp: App {
///     var body: some Scene {
///         WindowGroup {
///             Text("Bananas")
///                 .onAppear {
///                     NSApplication.shared.windows.forEach({ $0.tabbingMode = .disallowed })
///                 }
///         }
///     }
/// }
/// ```
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct WindowGroup<Content> : Scene where Content : View {

    /// Creates a window group with an identifier.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    ///
    /// - Parameters:
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    public init(id: String, @ViewBuilder content: () -> Content) { }

    /// Creates a window group with a localized title and an identifier.
    ///
    /// The window group uses the given view as a template to form the content
    /// of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    /// The system ignores any text styling in the title.
    ///
    /// - Parameters:
    ///   - title: The `Text` view to use for the group's title.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    public init(_ title: Text, id: String, @ViewBuilder content: () -> Content) { }

    /// Creates a window group with a key for localized title string and an
    /// identifier.
    ///
    /// The window group uses the given view as a template to form the content
    /// of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    public init(_ titleKey: LocalizedStringKey, id: String, @ViewBuilder content: () -> Content) { }

    /// Creates a window group with a title string and an identifier.
    ///
    /// The window group uses the given view as a template to form the content
    /// of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - id: A string that uniquely identifies the window group. Identifiers
    ///     must be unique among the window groups in your app.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    public init<S>(_ title: S, id: String, @ViewBuilder content: () -> Content) where S : StringProtocol { }

    /// Creates a window group.
    ///
    /// The window group using the given view as a template to form the
    /// content of each window in the group.
    ///
    /// - Parameter content: A closure that creates the content for each
    ///   instance of the group.
    public init(@ViewBuilder content: () -> Content) { }

    /// Creates a window group with a localized title.
    ///
    /// The window group uses the given view as a
    /// template to form the content of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    /// The system ignores any text styling in the title.
    ///
    /// - Parameters:
    ///   - title: The `Text` view to use for the group's title.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    public init(_ title: Text, @ViewBuilder content: () -> Content) { }

    /// Creates a window group with a key for localized title string.
    ///
    /// The window group uses the given view as a template to form the content
    /// of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - titleKey: The title key to use for the group's title.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    public init(_ titleKey: LocalizedStringKey, @ViewBuilder content: () -> Content) { }

    /// Creates a window group with a title string.
    ///
    /// The window group uses the given view as a template to form the content
    /// of each window in the group.
    /// The system uses the title to distinguish the window group in the user
    /// interface, such as in the name of commands associated with the group.
    ///
    /// - Parameters:
    ///   - title: The string to use for the title of the group.
    ///   - content: A closure that creates the content for each instance
    ///     of the group.
    public init<S>(_ title: S, @ViewBuilder content: () -> Content) where S : StringProtocol { }

    /// The content and behavior of the scene.
    ///
    /// For any scene that you create, provide a computed `body` property that
    /// defines the scene as a composition of other scenes. You can assemble a
    /// scene from primitive scenes that SwiftUI provides, as well as other
    /// scenes that you've defined.
    ///
    /// Swift infers the scene's `SwiftUI/Scene/Body-swift.associatedtype`
    /// associated type based on the contents of the `body` property.
    public var body: some Scene { get }

    /// The type of scene that represents the body of this scene.
    ///
    /// When you create a custom scene, Swift infers this type from your
    /// implementation of the required `SwiftUI/Scene/body-swift.property`
    /// property.
    public typealias Body = some Scene
}

/// A view that arranges children on top of each other.
///
/// `ZStack` arranges views "into" and "out of" the screen. The result
/// is vies stacked on top of each other.
///
///     struct ExampleView: View {
///         var body: some View {
///             ZStack {
///                 Text("I am obscured by clouds")
///                 Text("☁️☁️☁️☁️")
///             }
///         }
///     }
///
/// Learn more about the properties of each alignment choice via the
/// `Alignment` struct.
///
/// `ZStack` uses a `ViewBuilder` to construct the content.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ZStack<Content> : View where Content : View {

    /// Creates a ZStack with the given alignment.
    ///
    /// See the ``Alignment`` struct for the 9 types of standard alignments.
    ///
    ///     struct ExampleView: View {
    ///         var body: some View {
    ///             ZStack {
    ///                 Text("I am obscured by clouds and rain")
    ///                 Text("☁️☁️☁️☁️")
    ///                 Text("💧💧💧💧")
    ///             }
    ///         }
    ///     }
    ///
    /// - Parameters:
    ///   - alignment: The guide for aligning the subviews in this stack on both
    ///     axis.
    ///   - content: A view builder that creates the content of this stack.
    @inlinable public init(alignment: Alignment = .center, @ViewBuilder content: () -> Content) { }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never
}

/// Creates a view animation.
///
/// This function sets the given `Animation` as the `Transaction/animation`
/// property of the thread's current `Transaction`.
///
/// `withAnimation(_:_:)` executes the code in it's closure, and displays the results of that execution according to the provided animation.
///
/// For example, use `withAnimation(_:_:)` to animate a toggle. Here, the action on the view is the `showBanana.toggle()`. Now, by using `withAnimation(_:_:)` the results of that action will be animated according to `.easeInOut`.
///
/// ![Toggle Animation](with-animation-2.gif)
///
/// ```
/// struct ExplicitTransitionView: View {
///     @State var showBanana = false
///
///     var body: some View {
///         Button("Toggle") {
///             withAnimation(.easeInOut) { showBanana.toggle() }
///         }
///         if showBanana {
///             Text("🍌")
///                 .transition(.slide)
///         }
///     }
/// }
/// ```
///
/// Or use `withAnimation(_:_)` for a shake effect, like so:
///
/// ![Animatable Example 1](https://bananadocs-documentation-assets.s3-us-west-2.amazonaws.com/Animatable-example-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State var numberOfShakes: CGFloat = 0
///
///     var body: some View {
///         VStack {
///             Text("Banana🍌🍌")
///                 .font(.largeTitle)
///                 .modifier(ShakeEffect(shakeNumber: numberOfShakes))
///                 .onAppear {
///                     withAnimation(.easeIn(duration: 2.0)) {
///                         numberOfShakes = 10
///                     }
///                 }
///         }
///     }
/// }
///
/// struct ShakeEffect: AnimatableModifier {
///     var shakeNumber: CGFloat = 0
///
///     var animatableData: CGFloat {
///         get {
///             shakeNumber
///         } set {
///             shakeNumber = newValue
///         }
///     }
///
///     func body(content: Content) -> some View {
///         content
///             .offset(x: sin(shakeNumber * .pi * 2) * 10)
///     }
/// }
/// ```
///
/// Alter the duration of your animation as follows:
///
/// ![Animation Basic](with-animation-1.gif)
///
/// ```
/// struct ExampleView: View {
///     @State private var opacity = 0.0
///
///     var body: some View {
///         Button("Cloud the Banana") {
///             withAnimation(.easeIn(duration: 4.0)) {
///                 opacity += 1.0
///             }
///         }
///         .padding()
///
///         ZStack {
///             Text("🍌🍌")
///             Text("☁️☁️☁️☁️")
///                 .opacity(opacity)
///         }
///     }
/// }
/// ```
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public func withAnimation<Result>(_ animation: Animation? = .default, _ body: () throws -> Result) rethrows -> Result { }

/// Executes a closure with the specified transaction and returns the result.
///
/// - Parameters:
///   - transaction : An instance of a transaction, set as the thread's current
///     transaction.
///   - body: A closure to execute.
///
/// - Returns: The result of executing the closure with the specified
///   transaction.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public func withTransaction<Result>(_ transaction: Transaction, _ body: () throws -> Result) rethrows -> Result { }

extension NSDirectionalEdgeInsets {

    /// Create edge insets from the equivalent EdgeInsets.
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
    @available(watchOS, unavailable)
    public init(_ edgeInsets: EdgeInsets) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Never {

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required `body` property.
    public typealias Body = Never

    /// The content and behavior of the view.
    public var body: Never { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension CGPoint {

	/// Applies a projection transform to a given `CGPoint` to return a new
	/// transofrmed point.
	///
	/// - Parameter m: The projection transform to apply to the point
	///
	/// - Returns: A projection transformed `CGPoint`.
    public func applying(_ m: ProjectionTransform) -> CGPoint { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Never : Gesture {

    /// The type representing the gesture's value.
    public typealias Value = Never
}

/// Extends `T?` to conform to `Gesture` type if `T` also conforms to
/// `Gesture`. A nil value is mapped to an empty (i.e. failing)
/// gesture.
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Optional : Gesture where Wrapped : Gesture {

    /// The type representing the gesture's value.
    public typealias Value = Wrapped.Value
}

@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension NSUserActivity {

    /// Error types when getting/setting typed payload
    @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
    public enum TypedPayloadError : Error {

        /// UserInfo is empty or invalid
        case invalidContent

        /// Content failed to encode into a valid Dictionary
        case encodingError

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NSUserActivity.TypedPayloadError, b: NSUserActivity.TypedPayloadError) -> Bool { }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        public var hashValue: Int { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
        ///   compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher) { }
    }

    /// Given a Codable Swift type, return an instance decoded from the
    /// NSUserActivity's userInfo dictionary
    ///
    /// - Parameter type: the instance type to be decoded from userInfo
    /// - Returns: the type safe instance or raises if it can't be decoded
    public func typedPayload<T>(_ type: T.Type) throws -> T where T : Decodable, T : Encodable { }

    /// Given an instance of a Codable Swift type, encode it into the
    /// NSUserActivity's userInfo dictionary
    ///
    /// - Parameter payload: the instance to be converted to userInfo
    public func setTypedPayload<T>(_ payload: T) throws where T : Decodable, T : Encodable { }
}

extension Never : Scene {
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Never : WidgetConfiguration {
}

extension Never : ToolbarContent, CustomizableToolbarContent {
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Optional : View where Wrapped : View {

    /// The type of gesture representing the body of `Self`.
    public typealias Body = Never
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Never : View {
}

extension RangeReplaceableCollection where Self : MutableCollection {

    /// Removes all the elements at the specified offsets from the collection.
    ///
    /// - Complexity: O(*n*) where *n* is the length of the collection.
    public mutating func remove(atOffsets offsets: IndexSet) { }
}

extension MutableCollection {

    /// Moves all the elements at the specified offsets to the specified
    /// destination offset, preserving ordering.
    ///
    /// - Complexity: O(*n* log *n*), where *n* is the length of the collection.
    public mutating func move(fromOffsets source: IndexSet, toOffset destination: Int) { }
}

extension UIColor {

	/// Creates a new `UIColor` from a SwiftUI `Color`.
	///
	/// - Parameter color: The SwiftUI `Color` object to use for creating a `UIColor`.
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, *)
    @available(macOS, unavailable)
    public convenience init(_ color: Color) { }
}

extension UIUserInterfaceStyle {

    /// Creates a user interface style from its ColorScheme equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ colorScheme: ColorScheme?) { }
}

extension UIAccessibilityContrast {

    /// Create a contrast from its ColorSchemeContrast equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ colorSchemeContrast: ColorSchemeContrast?) { }
}

extension UIContentSizeCategory {

    /// Create a size category from its ContentSizeCategory equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ sizeCategory: ContentSizeCategory?) { }
}

extension UITraitEnvironmentLayoutDirection {

    /// Create a direction from its LayoutDirection equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ layoutDirection: LayoutDirection) { }
}

extension UILegibilityWeight {

    /// Creates a legibility weight from its LegibilityWeight equivalent.
    @available(iOS 14.0, tvOS 14.0, *)
    @available(macOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ legibilityWeight: LegibilityWeight?) { }
}

extension UIUserInterfaceSizeClass {

    /// Create a size class from its UserInterfaceSizeClass equivalent.
    @available(iOS 14.0, *)
    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public init(_ sizeClass: UserInterfaceSizeClass?) { }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension CGPoint : Animatable {

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<CGFloat, CGFloat>

    /// The data to animate.
    public var animatableData: CGPoint.AnimatableData
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension CGSize : Animatable {

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<CGFloat, CGFloat>

    /// The data to animate.
    public var animatableData: CGSize.AnimatableData
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension CGRect : Animatable {

    /// The type defining the data to animate.
    public typealias AnimatableData = AnimatablePair<CGPoint.AnimatableData, CGSize.AnimatableData>

    /// The data to animate.
    public var animatableData: CGRect.AnimatableData
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Float : VectorArithmetic {

    /// Multiplies each component of this value by the given value.
    public mutating func scale(by rhs: Double) { }

    /// Returns the dot-product of this vector arithmetic instance with itself.
    public var magnitudeSquared: Double { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Double : VectorArithmetic {

    /// Multiplies each component of this value by the given value.
    public mutating func scale(by rhs: Double) { }

    /// Returns the dot-product of this vector arithmetic instance with itself.
    public var magnitudeSquared: Double { get }
}

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension CGFloat : VectorArithmetic {

    /// Multiplies each component of this value by the given value.
    public mutating func scale(by rhs: Double) { }

    /// Returns the dot-product of this vector arithmetic instance with itself.
    public var magnitudeSquared: Double { get }
}

@available(iOS 14.0, macOS 11.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Never : Commands {
}
